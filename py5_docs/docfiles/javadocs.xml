<?xml version="1.0" standalone="yes" ?>
<commenttrees>
<commenttree class="processing.core.ThinkDifferent" name="init" kind="METHOD">
<body>
<first>Initialize the sketch with the quit handler.</first>
<full>
Initialize the sketch with the quit handler. Initialize the sketch with the quit handler such that, if there is no known crash, the application will not exit on its own if this is the first quit attempt.
</full>
</body>
<blocktags>
<blocktag>@param sketch The sketch whose quit handler callback should be set.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.ThinkDifferent" name="cleanup" kind="METHOD">
<body>
<first>Remove the quit handler.</first>
<full>
Remove the quit handler.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.ThinkDifferent" name="setIconImage" kind="METHOD">
<body>
<first>Called via reflection from PSurfaceAWT and others, set the dock icon image.</first>
<full>
Called via reflection from PSurfaceAWT and others, set the dock icon image.
</full>
</body>
<blocktags>
<blocktag>@param image The image to provide for Processing icon.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.ThinkDifferent" name="getTaskbar" kind="METHOD">
<body>
<first>Get the taskbar where OS visual settings can be provided.</first>
<full>
Get the taskbar where OS visual settings can be provided.
</full>
</body>
<blocktags>
<blocktag>@return Cached taskbar singleton instance.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.ThinkDifferent" name="getDesktop" kind="METHOD">
<body>
<first>Get the desktop where OS behavior can be provided.</first>
<full>
Get the desktop where OS behavior can be provided.
</full>
</body>
<blocktags>
<blocktag>@return Cached desktop singleton instance.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="x" kind="FIELD">
<body>
<first>( begin auto-generated from PVector_x.xml ) The x component of the vector.</first>
<full>
The x component of the vector. This field (variable) can be used to both get and set the value (see above example.)
</full>
</body>
<blocktags>
<blocktag>@webref pvector:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief The x component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="y" kind="FIELD">
<body>
<first>( begin auto-generated from PVector_y.xml ) The y component of the vector.</first>
<full>
The y component of the vector. This field (variable) can be used to both get and set the value (see above example.)
</full>
</body>
<blocktags>
<blocktag>@webref pvector:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief The y component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="z" kind="FIELD">
<body>
<first>( begin auto-generated from PVector_z.xml ) The z component of the vector.</first>
<full>
The z component of the vector. This field (variable) can be used to both get and set the value (see above example.)
</full>
</body>
<blocktags>
<blocktag>@webref pvector:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief The z component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="array" kind="FIELD">
<body>
<first>Array so that this can be temporarily used in an array context</first>
<full>
Array so that this can be temporarily used in an array context
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructor for an empty vector: x, y, and z are set to 0.</first>
<full>
Constructor for an empty vector: x, y, and z are set to 0.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructor for a 3D vector.</first>
<full>
Constructor for a 3D vector.
</full>
</body>
<blocktags>
<blocktag>@param x the x coordinate.</blocktag>
<blocktag>@param y the y coordinate.</blocktag>
<blocktag>@param z the z coordinate.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructor for a 2D vector: z coordinate is set to 0.</first>
<full>
Constructor for a 2D vector: z coordinate is set to 0.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="set" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_set.xml ) Sets the x, y, and z component of the vector using two or three separate variables, the data from a PVector, or the values from a float array.</first>
<full>
Sets the x, y, and z component of the vector using two or three separate variables, the data from a PVector, or the values from a float array.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@param x the x component of the vector</blocktag>
<blocktag>@param y the y component of the vector</blocktag>
<blocktag>@param z the z component of the vector</blocktag>
<blocktag>@brief Set the components of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x the x component of the vector</blocktag>
<blocktag>@param y the y component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v any variable of type PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="set" kind="METHOD">
<body>
<first>Set the x, y (and maybe z) coordinates using a float[] array as the source.</first>
<full>
Set the x, y (and maybe z) coordinates using a float[] array as the source.
</full>
</body>
<blocktags>
<blocktag>@param source array to copy from</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random2D" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_random2D.xml ) Make a new 2D unit vector with a random direction.</first>
<full>
Make a new 2D unit vector with a random direction.  If you pass in "this" as an argument, it will use the PApplet's random number generator.  You can also pass in a target PVector to fill.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@return the random PVector</blocktag>
<blocktag>@brief Make a new 2D unit vector with a random direction.</blocktag>
<blocktag>@see PVector#random3D()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random2D" kind="METHOD">
<body>
<first>Make a new 2D unit vector with a random direction using Processing's current random number generator</first>
<full>
Make a new 2D unit vector with a random direction using Processing's current random number generator
</full>
</body>
<blocktags>
<blocktag>@param parent current PApplet instance</blocktag>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random2D" kind="METHOD">
<body>
<first>Set a 2D vector to a random unit vector with a random direction</first>
<full>
Set a 2D vector to a random unit vector with a random direction
</full>
</body>
<blocktags>
<blocktag>@param target the target vector (if null, a new vector will be created)</blocktag>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random2D" kind="METHOD">
<body>
<first>Make a new 2D unit vector with a random direction.</first>
<full>
Make a new 2D unit vector with a random direction. Pass in the parent PApplet if you want randomSeed() to work (and be predictable). Or leave it null and be... random.
</full>
</body>
<blocktags>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random3D" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_random3D.xml ) Make a new 3D unit vector with a random direction.</first>
<full>
Make a new 3D unit vector with a random direction.  If you pass in "this" as an argument, it will use the PApplet's random number generator.  You can also pass in a target PVector to fill.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@return the random PVector</blocktag>
<blocktag>@brief Make a new 3D unit vector with a random direction.</blocktag>
<blocktag>@see PVector#random2D()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random3D" kind="METHOD">
<body>
<first>Make a new 3D unit vector with a random direction using Processing's current random number generator</first>
<full>
Make a new 3D unit vector with a random direction using Processing's current random number generator
</full>
</body>
<blocktags>
<blocktag>@param parent current PApplet instance</blocktag>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random3D" kind="METHOD">
<body>
<first>Set a 3D vector to a random unit vector with a random direction</first>
<full>
Set a 3D vector to a random unit vector with a random direction
</full>
</body>
<blocktags>
<blocktag>@param target the target vector (if null, a new vector will be created)</blocktag>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="random3D" kind="METHOD">
<body>
<first>Make a new 3D unit vector with a random direction</first>
<full>
Make a new 3D unit vector with a random direction
</full>
</body>
<blocktags>
<blocktag>@return the random PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="fromAngle" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_sub.xml ) Make a new 2D unit vector from an angle.</first>
<full>
Make a new 2D unit vector from an angle.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Make a new 2D unit vector from an angle</blocktag>
<blocktag>@param angle the angle in radians</blocktag>
<blocktag>@return the new unit PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="fromAngle" kind="METHOD">
<body>
<first>Make a new 2D unit vector from an angle</first>
<full>
Make a new 2D unit vector from an angle
</full>
</body>
<blocktags>
<blocktag>@param target the target vector (if null, a new vector will be created)</blocktag>
<blocktag>@return the PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="copy" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_copy.xml ) Gets a copy of the vector, returns a PVector object.</first>
<full>
Gets a copy of the vector, returns a PVector object.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Get a copy of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="get" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param target</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="mag" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_mag.xml ) Calculates the magnitude (length) of the vector and returns the result as a float (this is simply the equation ,&lt;em&gt;,sqrt(x*x + y*y + z*z),&lt;/em&gt;,.) ( end auto-generated )</first>
<full>
Calculates the magnitude (length) of the vector and returns the result as a float (this is simply the equation&lt;em&gt;sqrt(x*x + y*y + z*z)&lt;/em&gt;.)
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Calculate the magnitude of the vector</blocktag>
<blocktag>@return magnitude (length) of the vector</blocktag>
<blocktag>@see PVector#magSq()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="magSq" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_mag.xml ) Calculates the squared magnitude of the vector and returns the result as a float (this is simply the equation ,&lt;em&gt;,(x*x + y*y + z*z),&lt;/em&gt;,.) Faster if the real length is not required in the case of comparing vectors, etc.</first>
<full>
Calculates the squared magnitude of the vector and returns the result as a float (this is simply the equation&lt;em&gt;(x*x + y*y + z*z)&lt;/em&gt;.) Faster if the real length is not required in the case of comparing vectors, etc.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Calculate the magnitude of the vector, squared</blocktag>
<blocktag>@return squared magnitude of the vector</blocktag>
<blocktag>@see PVector#mag()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="add" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_add.xml ) Adds x, y, and z components to a vector, adds one vector to another, or adds two independent vectors together.</first>
<full>
Adds x, y, and z components to a vector, adds one vector to another, or adds two independent vectors together. The version of the method that adds two vectors together is a static method and returns a PVector, the others have no return value -- they act directly on the vector. See the examples for more context.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v the vector to be added</blocktag>
<blocktag>@brief Adds x, y, and z components to a vector, one vector to another, or two independent vectors</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="add" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x x component of the vector</blocktag>
<blocktag>@param y y component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="add" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z z component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="add" kind="METHOD">
<body>
<first>Add two vectors</first>
<full>
Add two vectors
</full>
</body>
<blocktags>
<blocktag>@param v1 a vector</blocktag>
<blocktag>@param v2 another vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="add" kind="METHOD">
<body>
<first>Add two vectors into a target vector</first>
<full>
Add two vectors into a target vector
</full>
</body>
<blocktags>
<blocktag>@param target the target vector (if null, a new vector will be created)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="sub" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_sub.xml ) Subtracts x, y, and z components from a vector, subtracts one vector from another, or subtracts two independent vectors.</first>
<full>
Subtracts x, y, and z components from a vector, subtracts one vector from another, or subtracts two independent vectors. The version of the method that subtracts two vectors is a static method and returns a PVector, the others have no return value -- they act directly on the vector. See the examples for more context.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v any variable of type PVector</blocktag>
<blocktag>@brief Subtract x, y, and z components from a vector, one vector from another, or two independent vectors</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="sub" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x the x component of the vector</blocktag>
<blocktag>@param y the y component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="sub" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z the z component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="sub" kind="METHOD">
<body>
<first>Subtract one vector from another</first>
<full>
Subtract one vector from another
</full>
</body>
<blocktags>
<blocktag>@param v1 the x, y, and z components of a PVector object</blocktag>
<blocktag>@param v2 the x, y, and z components of a PVector object</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="sub" kind="METHOD">
<body>
<first>Subtract one vector from another and store in another vector</first>
<full>
Subtract one vector from another and store in another vector
</full>
</body>
<blocktags>
<blocktag>@param target PVector in which to store the result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="mult" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_mult.xml ) Multiplies a vector by a scalar or multiplies one vector by another.</first>
<full>
Multiplies a vector by a scalar or multiplies one vector by another.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Multiply a vector by a scalar</blocktag>
<blocktag>@param n the number to multiply with the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="mult" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v the vector to multiply by the scalar</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="mult" kind="METHOD">
<body>
<first>Multiply a vector by a scalar, and write the result into a target PVector.</first>
<full>
Multiply a vector by a scalar, and write the result into a target PVector.
</full>
</body>
<blocktags>
<blocktag>@param target PVector in which to store the result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="div" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_div.xml ) Divides a vector by a scalar or divides one vector by another.</first>
<full>
Divides a vector by a scalar or divides one vector by another.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Divide a vector by a scalar</blocktag>
<blocktag>@param n the number by which to divide the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="div" kind="METHOD">
<body>
<first>Divide a vector by a scalar and return the result in a new vector.</first>
<full>
Divide a vector by a scalar and return the result in a new vector.
</full>
</body>
<blocktags>
<blocktag>@param v the vector to divide by the scalar</blocktag>
<blocktag>@return a new vector that is v1 / n</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="div" kind="METHOD">
<body>
<first>Divide a vector by a scalar and store the result in another vector.</first>
<full>
Divide a vector by a scalar and store the result in another vector.
</full>
</body>
<blocktags>
<blocktag>@param target PVector in which to store the result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="dist" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_dist.xml ) Calculates the Euclidean distance between two points (considering a point as a vector object).</first>
<full>
Calculates the Euclidean distance between two points (considering a point as a vector object).
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v the x, y, and z coordinates of a PVector</blocktag>
<blocktag>@brief Calculate the distance between two points</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="dist" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 any variable of type PVector</blocktag>
<blocktag>@param v2 any variable of type PVector</blocktag>
<blocktag>@return the Euclidean distance between v1 and v2</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="dot" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_dot.xml ) Calculates the dot product of two vectors.</first>
<full>
Calculates the dot product of two vectors.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v any variable of type PVector</blocktag>
<blocktag>@return the dot product</blocktag>
<blocktag>@brief Calculate the dot product of two vectors</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="dot" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x x component of the vector</blocktag>
<blocktag>@param y y component of the vector</blocktag>
<blocktag>@param z z component of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="dot" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 any variable of type PVector</blocktag>
<blocktag>@param v2 any variable of type PVector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="cross" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_cross.xml ) Calculates and returns a vector composed of the cross product between two vectors.</first>
<full>
Calculates and returns a vector composed of the cross product between two vectors.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@param v the vector to calculate the cross product</blocktag>
<blocktag>@brief Calculate and return the cross product</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="cross" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v any variable of type PVector</blocktag>
<blocktag>@param target PVector to store the result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="cross" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 any variable of type PVector</blocktag>
<blocktag>@param v2 any variable of type PVector</blocktag>
<blocktag>@param target PVector to store the result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="normalize" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_normalize.xml ) Normalize the vector to length 1 (make it a unit vector).</first>
<full>
Normalize the vector to length 1 (make it a unit vector).
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Normalize the vector to a length of 1</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="normalize" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param target Set to null to create a new vector</blocktag>
<blocktag>@return a new vector (if target was null), or target</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="limit" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_limit.xml ) Limit the magnitude of this vector to the value used for the , `,max,` , parameter.</first>
<full>
Limit the magnitude of this vector to the value used for the `max` parameter.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param max the maximum magnitude for the vector</blocktag>
<blocktag>@brief Limit the magnitude of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="setMag" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_setMag.xml ) Set the magnitude of this vector to the value used for the , `,len,` , parameter.</first>
<full>
Set the magnitude of this vector to the value used for the `len` parameter.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param len the new length for this vector</blocktag>
<blocktag>@brief Set the magnitude of the vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="setMag" kind="METHOD">
<body>
<first>Sets the magnitude of this vector, storing the result in another vector.</first>
<full>
Sets the magnitude of this vector, storing the result in another vector.
</full>
</body>
<blocktags>
<blocktag>@param target Set to null to create a new vector</blocktag>
<blocktag>@param len the new length for the new vector</blocktag>
<blocktag>@return a new vector (if target was null), or target</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="heading" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_setMag.xml ) Calculate the angle of rotation for this vector (only 2D vectors) ( end auto-generated )</first>
<full>
Calculate the angle of rotation for this vector (only 2D vectors)
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@return the angle of rotation</blocktag>
<blocktag>@brief Calculate the angle of rotation for this vector</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="rotate" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_rotate.xml ) Rotate the vector by an angle (only 2D vectors), magnitude remains the same ( end auto-generated )</first>
<full>
Rotate the vector by an angle (only 2D vectors), magnitude remains the same
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Rotate the vector by an angle (2D only)</blocktag>
<blocktag>@param theta the angle of rotation</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="lerp" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_rotate.xml ) Linear interpolate the vector to another vector ( end auto-generated )</first>
<full>
Linear interpolate the vector to another vector
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Linear interpolate the vector to another vector</blocktag>
<blocktag>@param v the vector to lerp to</blocktag>
<blocktag>@param amt The amount of interpolation; some value between 0.0 (old vector) and 1.0 (new vector). 0.1 is very near the old vector; 0.5 is halfway in between.</blocktag>
<blocktag>@see PApplet#lerp(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="lerp" kind="METHOD">
<body>
<first>Linear interpolate between two vectors (returns a new PVector object)</first>
<full>
Linear interpolate between two vectors (returns a new PVector object)
</full>
</body>
<blocktags>
<blocktag>@param v1 the vector to start from</blocktag>
<blocktag>@param v2 the vector to lerp to</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="lerp" kind="METHOD">
<body>
<first>Linear interpolate the vector to x,y,z values</first>
<full>
Linear interpolate the vector to x,y,z values
</full>
</body>
<blocktags>
<blocktag>@param x the x component to lerp to</blocktag>
<blocktag>@param y the y component to lerp to</blocktag>
<blocktag>@param z the z component to lerp to</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="angleBetween" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_angleBetween.xml ) Calculates and returns the angle (in radians) between two vectors.</first>
<full>
Calculates and returns the angle (in radians) between two vectors.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 the x, y, and z components of a PVector</blocktag>
<blocktag>@param v2 the x, y, and z components of a PVector</blocktag>
<blocktag>@brief Calculate and return the angle between two vectors</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PVector" name="array" kind="METHOD">
<body>
<first>( begin auto-generated from PVector_array.xml ) Return a representation of this vector as a float array.</first>
<full>
Return a representation of this vector as a float array. This is only for temporary use. If used in any other fashion, the contents should be copied by using the `PVector.get()` method to copy into your own array.
</full>
</body>
<blocktags>
<blocktag>@webref pvector:method</blocktag>
<blocktag>@usage: web_application</blocktag>
<blocktag>@brief Return a representation of the vector as a float array</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurfaceNone" name="setTitle" kind="METHOD">
<body>
<first>Set the window (and dock, or whatever necessary) title.</first>
<full>
Set the window (and dock, or whatever necessary) title.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurfaceNone" name="setVisible" kind="METHOD">
<body>
<first>Show or hide the window.</first>
<full>
Show or hide the window.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurfaceNone" name="setResizable" kind="METHOD">
<body>
<first>Set true if we want to resize things (default is not resizable)</first>
<full>
Set true if we want to resize things (default is not resizable)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurfaceNone.AnimationThread" name="run" kind="METHOD">
<body>
<first>Main method for the primary animation thread.</first>
<full>
Main method for the primary animation thread.&lt;A HREF="http://java.sun.com/products/jfc/tsc/articles/painting/"&gt;Painting in AWT and Swing&lt;/A&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="MIN_WINDOW_WIDTH" kind="FIELD">
<body>
<first>Minimum dimensions for the window holding an applet.</first>
<full>
Minimum dimensions for the window holding an applet. This varies between platforms, Mac OS X 10.3 (confirmed with 10.7 and Java 6) can do any height but requires at least 128 pixels width. Windows XP has another set of limitations. And for all I know, Linux probably allows window sizes to be negative numbers.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="getNative" kind="METHOD">
<body>
<first>Get the native window object associated with this drawing surface.</first>
<full>
Get the native window object associated with this drawing surface. For Java2D, this will be an AWT Frame object. For OpenGL, the window. The data returned here is subject to the whims of the renderer, and using this method means you're willing to deal with underlying implementation changes and that you won't throw a fit like a toddler if your code breaks sometime in the future.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="setTitle" kind="METHOD">
<body>
<first>Set the window (and dock, or whatever necessary) title.</first>
<full>
Set the window (and dock, or whatever necessary) title.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="setVisible" kind="METHOD">
<body>
<first>Show or hide the window.</first>
<full>
Show or hide the window.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="setResizable" kind="METHOD">
<body>
<first>Set true if we want to resize things (default is not resizable)</first>
<full>
Set true if we want to resize things (default is not resizable)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="setAlwaysOnTop" kind="METHOD">
<body>
<first>Dumb name, but inherited from Frame and no better ideas.</first>
<full>
Dumb name, but inherited from Frame and no better ideas.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="openLink" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param url the link to open</blocktag>
<blocktag>@return false if unable to find a viable way to open</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="startThread" kind="METHOD">
<body>
<first>Start the animation thread</first>
<full>
Start the animation thread
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="pauseThread" kind="METHOD">
<body>
<first>On the next trip through the animation thread, things should go sleepy-bye.</first>
<full>
On the next trip through the animation thread, things should go sleepy-bye. Does not pause the thread immediately because that needs to happen on the animation thread itself, so fires on the next trip through draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PSurface" name="stopThread" kind="METHOD">
<body>
<first>Stop the animation thread (set it null)</first>
<full>
Stop the animation thread (set it null)
</full>
</body>
<blocktags>
<blocktag>@return false if already stopped</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="svgWidth" kind="FIELD">
<body>
<first>Width of containing SVG (used for percentages).</first>
<full>
Width of containing SVG (used for percentages).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="svgHeight" kind="FIELD">
<body>
<first>Height of containing SVG (used for percentages).</first>
<full>
Height of containing SVG (used for percentages).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="svgSizeXY" kind="FIELD">
<body>
<first>\u221a((w² + h²)/2) of containing SVG (used for percentages).</first>
<full>
\u221a((w² + h²)/2) of containing SVG (used for percentages).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="init" kind="CONSTRUCTOR">
<body>
<first>Initializes a new SVG object from the given XML object.</first>
<full>
Initializes a new SVG object from the given XML object.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="createShape" kind="METHOD">
<body>
<first>Factory method for subclasses.</first>
<full>
Factory method for subclasses.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parseChild" kind="METHOD">
<body>
<first>Parse a child XML element.</first>
<full>
Parse a child XML element. Override this method to add parsing for more SVG elements.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parseEllipse" kind="METHOD">
<body>
<first>Handles parsing ellipse and circle tags.</first>
<full>
Handles parsing ellipse and circle tags.
</full>
</body>
<blocktags>
<blocktag>@param circle true if this is a circle and not an ellipse</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parsePoly" kind="METHOD">
<body>
<first>Parse a polyline or polygon from an SVG file.</first>
<full>
Parse a polyline or polygon from an SVG file. Syntax defined at http://www.w3.org/TR/SVG/shapes.html#PointsBNF
</full>
</body>
<blocktags>
<blocktag>@param close true if shape is closed (polygon), false if not (polyline)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parseTransform" kind="METHOD">
<body>
<first>Parse the specified SVG matrix into a PMatrix2D.</first>
<full>
Parse the specified SVG matrix into a PMatrix2D. Note that PMatrix2D is rotated relative to the SVG definition, so parameters are rearranged here. More about the transformation matrices in&lt;a href="http://www.w3.org/TR/SVG/coords.html#TransformAttribute"&gt;this section&lt;/a&gt;of the SVG documentation.
</full>
</body>
<blocktags>
<blocktag>@param matrixStr text of the matrix param.</blocktag>
<blocktag>@return a good old-fashioned PMatrix2D</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parseSimpleColor" kind="METHOD">
<body>
<first>Parses the "color" datatype only, and prints an error if it is not of this form.</first>
<full>
Parses the "color" datatype only, and prints an error if it is not of this form. http://www.w3.org/TR/SVG/types.html#DataTypeColor
</full>
</body>
<blocktags>
<blocktag>@return 0xRRGGBB (no alpha). Zero on error.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="colorNames" kind="FIELD">
<body>
<first>Deliberately conforms to the HTML 4.01 color spec + en-gb grey, rather than the (unlikely to be useful) entire 147-color system used in SVG.</first>
<full>
Deliberately conforms to the HTML 4.01 color spec + en-gb grey, rather than the (unlikely to be useful) entire 147-color system used in SVG.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="getFloatWithUnit" kind="METHOD">
<body>
<first>Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).</first>
<full>
Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).
</full>
</body>
<blocktags>
<blocktag>@param element what to parse</blocktag>
<blocktag>@param attribute name of the attribute to get</blocktag>
<blocktag>@param relativeTo (float) Used for %. When relative to viewbox, should    be svgWidth for horizontal dimentions, svgHeight for vertical, and    svgXYSize for anything else.</blocktag>
<blocktag>@return unit-parsed version of the data</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="parseUnitSize" kind="METHOD">
<body>
<first>Parse a size that may have a suffix for its units.</first>
<full>
Parse a size that may have a suffix for its units. This assumes 90dpi, which implies, as given in the&lt;A HREF="http://www.w3.org/TR/SVG/coords.html#Units"&gt;units&lt;/A&gt;spec:

* "1pt" equals "1.25px" (and therefore 1.25 user units)
* "1pc" equals "15px" (and therefore 15 user units)
* "1mm" would be "3.543307px" (3.543307 user units)
* "1cm" equals "35.43307px" (and therefore 35.43307 user units)
* "1in" equals "90px" (and therefore 90 user units)

</full>
</body>
<blocktags>
<blocktag>@param relativeTo (float) Used for %. When relative to viewbox, should    be svgWidth for horizontal dimentions, svgHeight for vertical, and    svgXYSize for anything else.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="getChild" kind="METHOD">
<body>
<first>Get a particular element based on its SVG ID.</first>
<full>
Get a particular element based on its SVG ID. When editing SVG by hand, this is the id="" tag on any SVG element. When editing from Illustrator, these IDs can be edited by expanding the layers palette. The names used in the layers palette, both for the layers or the shapes and groups beneath them can be used here.

```
// This code grabs "Layer 3" and the shapes beneath it. PShape layer3 = svg.getChild("Layer 3");
```


</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeSVG" name="print" kind="METHOD">
<body>
<first>Prints out the SVG document.</first>
<full>
Prints out the SVG document. Useful for parsing.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShapeOBJ" name="init" kind="CONSTRUCTOR">
<body>
<first>Initializes a new OBJ Object with the given filename.</first>
<full>
Initializes a new OBJ Object with the given filename.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="PRIMITIVE" kind="FIELD">
<body>
<first>A line, ellipse, arc, image, etc.</first>
<full>
A line, ellipse, arc, image, etc.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="PATH" kind="FIELD">
<body>
<first>A series of vertex, curveVertex, and bezierVertex calls.</first>
<full>
A series of vertex, curveVertex, and bezierVertex calls.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="GEOMETRY" kind="FIELD">
<body>
<first>Collections of vertices created with beginShape().</first>
<full>
Collections of vertices created with beginShape().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="family" kind="FIELD">
<body>
<first>The shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY.</first>
<full>
The shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="kind" kind="FIELD">
<body>
<first>ELLIPSE, LINE, QUAD; TRIANGLE_FAN, QUAD_STRIP; etc.</first>
<full>
ELLIPSE, LINE, QUAD; TRIANGLE_FAN, QUAD_STRIP; etc.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="image" kind="FIELD">
<body>
<first>Texture or image data associated with this shape.</first>
<full>
Texture or image data associated with this shape.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="width" kind="FIELD">
<body>
<first>( begin auto-generated from PShape_width.xml ) The width of the PShape document.</first>
<full>
The width of the PShape document.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Shape document width</blocktag>
<blocktag>@see PShape#height</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="height" kind="FIELD">
<body>
<first>( begin auto-generated from PShape_height.xml ) The height of the PShape document.</first>
<full>
The height of the PShape document.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Shape document height</blocktag>
<blocktag>@see PShape#width</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="openShape" kind="FIELD">
<body>
<first>Retained shape being created with beginShape/endShape</first>
<full>
Retained shape being created with beginShape/endShape
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="style" kind="FIELD">
<body>
<first>Temporary toggle for whether styles should be honored.</first>
<full>
Temporary toggle for whether styles should be honored.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="params" kind="FIELD">
<body>
<first>For primitive shapes in particular, params like x/y/w/h or x1/y1/x2/y2.</first>
<full>
For primitive shapes in particular, params like x/y/w/h or x1/y1/x2/y2.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="vertices" kind="FIELD">
<body>
<first>When drawing POLYGON shapes, the second param is an array of length VERTEX_FIELD_COUNT.</first>
<full>
When drawing POLYGON shapes, the second param is an array of length VERTEX_FIELD_COUNT. When drawing PATH shapes, the second param has only two variables.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="vertexCodeCount" kind="FIELD">
<body>
<first>Array of VERTEX, BEZIER_VERTEX, and CURVE_VERTEX calls.</first>
<full>
Array of VERTEX, BEZIER_VERTEX, and CURVE_VERTEX calls.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="close" kind="FIELD">
<body>
<first>True if this is a closed path.</first>
<full>
True if this is a closed path.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorMode" kind="FIELD">
<body>
<first>The current colorMode</first>
<full>
The current colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeX" kind="FIELD">
<body>
<first>Max value for red (or hue) set by colorMode</first>
<full>
Max value for red (or hue) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeY" kind="FIELD">
<body>
<first>Max value for green (or saturation) set by colorMode</first>
<full>
Max value for green (or saturation) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeZ" kind="FIELD">
<body>
<first>Max value for blue (or value) set by colorMode</first>
<full>
Max value for blue (or value) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeA" kind="FIELD">
<body>
<first>Max value for alpha set by colorMode</first>
<full>
Max value for alpha set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeScale" kind="FIELD">
<body>
<first>True if colors are not in the range 0..1</first>
<full>
True if colors are not in the range 0..1
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorModeDefault" kind="FIELD">
<body>
<first>True if colorMode(RGB, 255)</first>
<full>
True if colorMode(RGB, 255)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="is3D" kind="FIELD">
<body>
<first>True if contains 3D data</first>
<full>
True if contains 3D data
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="isVisible" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_isVisible.xml ) Returns a boolean value "true" if the image is set to be visible, "false" if not.</first>
<full>
Returns a boolean value "true" if the image is set to be visible, "false" if not. This is modified with the `setVisible()` parameter.

The visibility of a shape is usually controlled by whatever program created the SVG file. For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Returns a boolean value "true" if the image is set to be visible, "false" if not</blocktag>
<blocktag>@see PShape#setVisible(boolean)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setVisible" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_setVisible.xml ) Sets the shape to be visible or invisible.</first>
<full>
Sets the shape to be visible or invisible. This is determined by the value of the `visible` parameter.

The visibility of a shape is usually controlled by whatever program created the SVG file. For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:mathod</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Sets the shape to be visible or invisible</blocktag>
<blocktag>@param visible "false" makes the shape invisible and "true" makes it visible</blocktag>
<blocktag>@see PShape#isVisible()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="disableStyle" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_disableStyle.xml ) Disables the shape's style data and uses Processing's current styles.</first>
<full>
Disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.

Advanced
--------

Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Disables the shape's style data and uses Processing styles</blocktag>
<blocktag>@see PShape#enableStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="enableStyle" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_enableStyle.xml ) Enables the shape's style data and ignores Processing's current styles.</first>
<full>
Enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Enables the shape's style data and ignores the Processing styles</blocktag>
<blocktag>@see PShape#disableStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getWidth" kind="METHOD">
<body>
<first>Get the width of the drawing area (not necessarily the shape boundary).</first>
<full>
Get the width of the drawing area (not necessarily the shape boundary).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getHeight" kind="METHOD">
<body>
<first>Get the height of the drawing area (not necessarily the shape boundary).</first>
<full>
Get the height of the drawing area (not necessarily the shape boundary).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getDepth" kind="METHOD">
<body>
<first>Get the depth of the shape area (not necessarily the shape boundary).</first>
<full>
Get the depth of the shape area (not necessarily the shape boundary). Only makes sense for 3D PShape subclasses, such as PShape3D.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="is2D" kind="METHOD">
<body>
<first>Return true if this shape is 2D.</first>
<full>
Return true if this shape is 2D. Defaults to true.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="is3D" kind="METHOD">
<body>
<first>Return true if this shape is 3D.</first>
<full>
Return true if this shape is 3D. Defaults to false.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="beginContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@brief Starts a new contour</blocktag>
<blocktag>@see PShape#endContour()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="endContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@brief Ends a contour</blocktag>
<blocktag>@see PShape#beginContour()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="beginShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Starts the creation of a new PShape</blocktag>
<blocktag>@see PApplet#endShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="endShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Finishes the creation of a new PShape</blocktag>
<blocktag>@see PApplet#beginShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="draw" kind="METHOD">
<body>
<first>Called by the following (the shape() command adds the g) PShape s = loadShape("blah.svg"); shape(s);</first>
<full>
Called by the following (the shape() command adds the g) PShape s = loadShape("blah.svg"); shape(s);
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="drawImpl" kind="METHOD">
<body>
<first>Draws the SVG document.</first>
<full>
Draws the SVG document.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="parseBase64Image" kind="METHOD">
<body>
<first>Parse a base 64 encoded image within an image path.</first>
<full>
Parse a base 64 encoded image within an image path.
</full>
</body>
<blocktags>
<blocktag>@param imagePath The image path containing the base 64 image data.</blocktag>
<blocktag>@return Newly loaded PImage.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getChildCount" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref</blocktag>
<blocktag>@brief Returns the number of children</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="crop" kind="METHOD">
<body>
<first>Resize the children[] array to be in line with childCount</first>
<full>
Resize the children[] array to be in line with childCount
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getChild" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_getChild.xml ) Extracts a child shape from a parent shape.</first>
<full>
Extracts a child shape from a parent shape. Specify the name of the shape with the `target` parameter. The shape is returned as a `PShape` object, or `null` is returned if there is an error.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Returns a child element of a shape as a PShape object</blocktag>
<blocktag>@param index the layer position of the shape to get</blocktag>
<blocktag>@see PShape#addChild(PShape)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getChild" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param target the name of the shape to get</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="findChild" kind="METHOD">
<body>
<first>Same as getChild(name), except that it first walks all the way up the hierarchy to the eldest grandparent, so that children can be found anywhere.</first>
<full>
Same as getChild(name), except that it first walks all the way up the hierarchy to the eldest grandparent, so that children can be found anywhere.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="addChild" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Adds a new child</blocktag>
<blocktag>@param who any variable of type PShape</blocktag>
<blocktag>@see PShape#getChild(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="addChild" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param idx the layer position in which to insert the new child</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="removeChild" kind="METHOD">
<body>
<first>Remove the child shape with index idx.</first>
<full>
Remove the child shape with index idx.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="addName" kind="METHOD">
<body>
<first>Add a shape to the name lookup table.</first>
<full>
Add a shape to the name lookup table.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getChildIndex" kind="METHOD">
<body>
<first>Returns the index of child who.</first>
<full>
Returns the index of child who.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getFamily" kind="METHOD">
<body>
<first>The shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY.</first>
<full>
The shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getVertexCount" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Returns the total number of vertices as an int</blocktag>
<blocktag>@see PShape#getVertex(int)</blocktag>
<blocktag>@see PShape#setVertex(int, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Returns the vertex at the index position</blocktag>
<blocktag>@param index the location of the vertex</blocktag>
<blocktag>@see PShape#setVertex(int, float, float)</blocktag>
<blocktag>@see PShape#getVertexCount()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vec PVector to assign the data to</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Sets the vertex at the index position</blocktag>
<blocktag>@param index the location of the vertex</blocktag>
<blocktag>@param x the x value for the vertex</blocktag>
<blocktag>@param y the y value for the vertex</blocktag>
<blocktag>@see PShape#getVertex(int)</blocktag>
<blocktag>@see PShape#getVertexCount()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z the z value for the vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vec the PVector to define the x, y, z coordinates</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setFill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setFill" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_setFill.xml ) The , `,setFill(),` , method defines the fill color of a , `,PShape,` ,.</first>
<full>
The `setFill()` method defines the fill color of a `PShape` . This method is used after shapes are created or when a shape is defined explicitly (e.g. `createShape(RECT, 20, 20, 80, 80)` ) as shown in the above example. When a shape is created with `beginShape()` and `endShape()` , its attributes may be changed with `fill()` and `stroke()` within `beginShape()` and `endShape()` . However, after the shape is created, only the `setFill()` method can define a new fill value for the `PShape` .
</full>
</body>
<blocktags>
<blocktag>@webref</blocktag>
<blocktag>@param fill</blocktag>
<blocktag>@brief Set the fill value</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setFill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setStroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setStroke" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_setStroke.xml ) The , `,setStroke(),` , method defines the outline color of a , `,PShape,` ,.</first>
<full>
The `setStroke()` method defines the outline color of a `PShape` . This method is used after shapes are created or when a shape is defined explicitly (e.g. `createShape(RECT, 20, 20, 80, 80)` ) as shown in the above example. When a shape is created with `beginShape()` and `endShape()` , its attributes may be changed with `fill()` and `stroke()` within `beginShape()` and `endShape()` . However, after the shape is created, only the `setStroke()` method can define a new stroke value for the `PShape` .
</full>
</body>
<blocktags>
<blocktag>@webref</blocktag>
<blocktag>@param stroke</blocktag>
<blocktag>@brief Set the stroke value</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="setStroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="getVertexCode" kind="METHOD">
<body>
<first>One of VERTEX, BEZIER_VERTEX, CURVE_VERTEX, or BREAK.</first>
<full>
One of VERTEX, BEZIER_VERTEX, CURVE_VERTEX, or BREAK.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="contains" kind="METHOD">
<body>
<first>Return true if this x, y coordinate is part of this shape.</first>
<full>
Return true if this x, y coordinate is part of this shape. Only works with PATH shapes or GROUP shapes that contain other GROUPs or PATHs.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="translate" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_translate.xml ) Specifies an amount to displace the shape.</first>
<full>
Specifies an amount to displace the shape. The `x` parameter specifies left/right translation, the `y` parameter specifies up/down translation, and the `z` parameter specifies translations toward/away from the screen. Subsequent calls to the method accumulates the effect. For example, calling `translate(50, 0)` and then `translate(20, 0)` is the same as `translate(70, 0)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.

Using this method with the `z` parameter requires using the P3D parameter in combination with size.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Displaces the shape</blocktag>
<blocktag>@param x left/right translation</blocktag>
<blocktag>@param y up/down translation</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="translate" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z forward/back translation</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="rotateX" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_rotateX.xml ) Rotates a shape around the x-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the x-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` method.

Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction. Subsequent calls to the method accumulates the effect. For example, calling `rotateX(HALF_PI)` and then `rotateX(HALF_PI)` is the same as `rotateX(PI)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.

This method requires a 3D renderer. You need to use P3D as a third parameter for the `size()` function as shown in the example above.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Rotates the shape around the x-axis</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#rotateY(float)</blocktag>
<blocktag>@see PShape#rotateZ(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="rotateY" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_rotateY.xml ) Rotates a shape around the y-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the y-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` method.

Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction. Subsequent calls to the method accumulates the effect. For example, calling `rotateY(HALF_PI)` and then `rotateY(HALF_PI)` is the same as `rotateY(PI)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.

This method requires a 3D renderer. You need to use P3D as a third parameter for the `size()` function as shown in the example above.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Rotates the shape around the y-axis</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#rotateX(float)</blocktag>
<blocktag>@see PShape#rotateZ(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="rotateZ" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_rotateZ.xml ) Rotates a shape around the z-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the z-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` method.

Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction. Subsequent calls to the method accumulates the effect. For example, calling `rotateZ(HALF_PI)` and then `rotateZ(HALF_PI)` is the same as `rotateZ(PI)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.

This method requires a 3D renderer. You need to use P3D as a third parameter for the `size()` function as shown in the example above.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Rotates the shape around the z-axis</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#rotateX(float)</blocktag>
<blocktag>@see PShape#rotateY(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="rotate" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_rotate.xml ) Rotates a shape the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` method.

Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect. For example, calling `rotate(HALF_PI)` and then `rotate(HALF_PI)` is the same as `rotate(PI)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Rotates the shape</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PShape#rotateX(float)</blocktag>
<blocktag>@see PShape#rotateY(float)</blocktag>
<blocktag>@see PShape#rotateZ(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="rotate" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="scale" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_scale.xml ) Increases or decreases the size of a shape by expanding and contracting vertices.</first>
<full>
Increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box. Scale values are specified as decimal percentages. For example, the method call `scale(2.0)` increases the dimension of a shape by 200%. Subsequent calls to the method multiply the effect. For example, calling `scale(2.0)` and then `scale(1.5)` is the same as `scale(3.0)` . This transformation is applied directly to the shape, it's not refreshed each time `draw()` is run.

Using this method with the `z` parameter requires using the P3D parameter in combination with size.
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Increases and decreases the size of a shape</blocktag>
<blocktag>@param s percentate to scale the object</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
<blocktag>@see PShape#resetMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="scale" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x percentage to scale the object in the x-axis</blocktag>
<blocktag>@param y percentage to scale the object in the y-axis</blocktag>
<blocktag>@param z percentage to scale the object in the z-axis</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="resetMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from PShape_resetMatrix.xml ) Replaces the current matrix of a shape with the identity matrix.</first>
<full>
Replaces the current matrix of a shape with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().
</full>
</body>
<blocktags>
<blocktag>@webref pshape:method</blocktag>
<blocktag>@brief Replaces the current matrix of a shape with the identity matrix</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PShape#rotate(float)</blocktag>
<blocktag>@see PShape#scale(float)</blocktag>
<blocktag>@see PShape#translate(float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="checkMatrix" kind="METHOD">
<body>
<first>Make sure that the shape's matrix is 1) not null, and 2) has a matrix that can handle ,&lt;em&gt;,at least,&lt;/em&gt;, the specified number of dimensions.</first>
<full>
Make sure that the shape's matrix is 1) not null, and 2) has a matrix that can handle&lt;em&gt;at least&lt;/em&gt;the specified number of dimensions.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorMode" kind="METHOD">
<body>
<first>Set the pivot point for all transformations.</first>
<full>
Set the pivot point for all transformations.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param max range for all color elements</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param maxX range for the red or hue depending on the current color mode</blocktag>
<blocktag>@param maxY range for the green or saturation depending on the current color mode</blocktag>
<blocktag>@param maxZ range for the blue or brightness depending on the current color mode</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PShape" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param maxA range for the alpha</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="get" kind="METHOD">
<body>
<first>Returns a copy of this PMatrix.</first>
<full>
Returns a copy of this PMatrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="get" kind="METHOD">
<body>
<first>Copies the matrix contents into a 16 entry float array.</first>
<full>
Copies the matrix contents into a 16 entry float array. If target is null (or not the correct size), a new array will be created.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="preApply" kind="METHOD">
<body>
<first>Apply the 3D equivalent of the 2D matrix supplied to the left of this one.</first>
<full>
Apply the 3D equivalent of the 2D matrix supplied to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="preApply" kind="METHOD">
<body>
<first>Apply the 3D equivalent of the 2D matrix supplied to the left of this one.</first>
<full>
Apply the 3D equivalent of the 2D matrix supplied to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="mult" kind="METHOD">
<body>
<first>Multiply source by this matrix, and return the result.</first>
<full>
Multiply source by this matrix, and return the result. The result will be stored in target if target is non-null, and target will then be the matrix returned. This improves performance if you reuse target, so it's recommended if you call this many times in draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="mult" kind="METHOD">
<body>
<first>Multiply a three or four element vector against this matrix.</first>
<full>
Multiply a three or four element vector against this matrix. If out is null or not length 3 or 4, a new float array (length 3) will be returned. Supplying and recycling a target array improves performance, so it's recommended if you call this many times in draw.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multX" kind="METHOD">
<body>
<first>Returns the x-coordinate of the result of multiplying the point (x, y) by this matrix.</first>
<full>
Returns the x-coordinate of the result of multiplying the point (x, y) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multY" kind="METHOD">
<body>
<first>Returns the y-coordinate of the result of multiplying the point (x, y) by this matrix.</first>
<full>
Returns the y-coordinate of the result of multiplying the point (x, y) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multX" kind="METHOD">
<body>
<first>Returns the x-coordinate of the result of multiplying the point (x, y, z) by this matrix.</first>
<full>
Returns the x-coordinate of the result of multiplying the point (x, y, z) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multY" kind="METHOD">
<body>
<first>Returns the y-coordinate of the result of multiplying the point (x, y, z) by this matrix.</first>
<full>
Returns the y-coordinate of the result of multiplying the point (x, y, z) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multZ" kind="METHOD">
<body>
<first>Returns the z-coordinate of the result of multiplying the point (x, y, z) by this matrix.</first>
<full>
Returns the z-coordinate of the result of multiplying the point (x, y, z) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multW" kind="METHOD">
<body>
<first>Returns the fourth element of the result of multiplying the vector (x, y, z) by this matrix.</first>
<full>
Returns the fourth element of the result of multiplying the vector (x, y, z) by this matrix. (Acts as if w = 1 was supplied.)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multX" kind="METHOD">
<body>
<first>Returns the x-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.</first>
<full>
Returns the x-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multY" kind="METHOD">
<body>
<first>Returns the y-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.</first>
<full>
Returns the y-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multZ" kind="METHOD">
<body>
<first>Returns the z-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.</first>
<full>
Returns the z-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="multW" kind="METHOD">
<body>
<first>Returns the w-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.</first>
<full>
Returns the w-coordinate of the result of multiplying the vector (x, y, z, w) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="transpose" kind="METHOD">
<body>
<first>Transpose this matrix; rows become columns and columns rows.</first>
<full>
Transpose this matrix; rows become columns and columns rows.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="invert" kind="METHOD">
<body>
<first>Invert this matrix.</first>
<full>
Invert this matrix. Will not necessarily succeed, because some matrices map more than one point to the same image point, and so are irreversible.
</full>
</body>
<blocktags>
<blocktag>@return true if successful</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="determinant3x3" kind="METHOD">
<body>
<first>Calculate the determinant of a 3x3 matrix.</first>
<full>
Calculate the determinant of a 3x3 matrix.
</full>
</body>
<blocktags>
<blocktag>@return result</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix3D" name="determinant" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@return the determinant of the matrix</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="init" kind="CONSTRUCTOR">
<body>
<first>Create a new matrix, set to the identity matrix.</first>
<full>
Create a new matrix, set to the identity matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="get" kind="METHOD">
<body>
<first>Returns a copy of this PMatrix.</first>
<full>
Returns a copy of this PMatrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="get" kind="METHOD">
<body>
<first>Copies the matrix contents into a 6 entry float array.</first>
<full>
Copies the matrix contents into a 6 entry float array. If target is null (or not the correct size), a new array will be created. Returned in the order{@code {m00, m01, m02, m10, m11, m12}}.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="set" kind="METHOD">
<body>
<first>If matrix is a PMatrix2D, sets this matrix to be a copy of it.</first>
<full>
If matrix is a PMatrix2D, sets this matrix to be a copy of it.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException If &lt;tt&gt;matrix&lt;/tt&gt; is not 2D.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="set" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D. Does nothing.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="set" kind="METHOD">
<body>
<first>Sets the matrix content.</first>
<full>
Sets the matrix content.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="set" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D. Does nothing.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="translate" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="rotateX" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="rotateY" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="rotate" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="scale" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="apply" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="apply" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="preApply" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="preApply" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D.
</full>
</body>
<blocktags>
<blocktag>@throws IllegalArgumentException</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="mult" kind="METHOD">
<body>
<first>{@inheritDoc}, Ignores any z component.</first>
<full>
{@inheritDoc}Ignores any z component.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="mult" kind="METHOD">
<body>
<first>Multiply a two element vector against this matrix.</first>
<full>
Multiply a two element vector against this matrix. If out is null or not length four, a new float array will be returned. The values for vec and out can be the same (though that's less efficient).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="multX" kind="METHOD">
<body>
<first>Returns the x-coordinate of the result of multiplying the point (x, y) by this matrix.</first>
<full>
Returns the x-coordinate of the result of multiplying the point (x, y) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="multY" kind="METHOD">
<body>
<first>Returns the y-coordinate of the result of multiplying the point (x, y) by this matrix.</first>
<full>
Returns the y-coordinate of the result of multiplying the point (x, y) by this matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="transpose" kind="METHOD">
<body>
<first>Unavailable in 2D.</first>
<full>
Unavailable in 2D. Does nothing.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix2D" name="determinant" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@return the determinant of the matrix</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="reset" kind="METHOD">
<body>
<first>Make this an identity matrix.</first>
<full>
Make this an identity matrix. Multiplying by it will have no effect.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="get" kind="METHOD">
<body>
<first>Returns a copy of this PMatrix.</first>
<full>
Returns a copy of this PMatrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="get" kind="METHOD">
<body>
<first>Copies the matrix contents into a float array.</first>
<full>
Copies the matrix contents into a float array. If target is null (or not the correct size), a new array will be created.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="set" kind="METHOD">
<body>
<first>Make this matrix become a copy of src.</first>
<full>
Make this matrix become a copy of src.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="set" kind="METHOD">
<body>
<first>Set the contents of this matrix to the contents of source.</first>
<full>
Set the contents of this matrix to the contents of source. Fills the matrix left-to-right, starting in the top row.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="set" kind="METHOD">
<body>
<first>Set the matrix content to this 2D matrix or its 3D equivalent.</first>
<full>
Set the matrix content to this 2D matrix or its 3D equivalent.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="set" kind="METHOD">
<body>
<first>Set the matrix content to the 3D matrix supplied, if this matrix is 3D.</first>
<full>
Set the matrix content to the 3D matrix supplied, if this matrix is 3D.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="apply" kind="METHOD">
<body>
<first>Multiply this matrix by another.</first>
<full>
Multiply this matrix by another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="apply" kind="METHOD">
<body>
<first>Multiply this matrix by another.</first>
<full>
Multiply this matrix by another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="apply" kind="METHOD">
<body>
<first>Multiply this matrix by another.</first>
<full>
Multiply this matrix by another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="apply" kind="METHOD">
<body>
<first>Multiply this matrix by another.</first>
<full>
Multiply this matrix by another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="apply" kind="METHOD">
<body>
<first>Multiply this matrix by another.</first>
<full>
Multiply this matrix by another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one. 3D only.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="preApply" kind="METHOD">
<body>
<first>Apply another matrix to the left of this one.</first>
<full>
Apply another matrix to the left of this one. 3D only.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="mult" kind="METHOD">
<body>
<first>Multiply source by this matrix, and return the result.</first>
<full>
Multiply source by this matrix, and return the result. The result will be stored in target if target is non-null, and target will then be the matrix returned. This improves performance if you reuse target, so it's recommended if you call this many times in draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="mult" kind="METHOD">
<body>
<first>Multiply a multi-element vector against this matrix.</first>
<full>
Multiply a multi-element vector against this matrix. Supplying and recycling a target array improves performance, so it's recommended if you call this many times in draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="transpose" kind="METHOD">
<body>
<first>Transpose this matrix; rows become columns and columns rows.</first>
<full>
Transpose this matrix; rows become columns and columns rows.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="invert" kind="METHOD">
<body>
<first>Invert this matrix.</first>
<full>
Invert this matrix. Will not necessarily succeed, because some matrices map more than one point to the same image point, and so are irreversible.
</full>
</body>
<blocktags>
<blocktag>@return true if successful</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PMatrix" name="determinant" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@return the determinant of the matrix</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="format" kind="FIELD">
<body>
<first>Format for this image, one of RGB, ARGB or ALPHA.</first>
<full>
Format for this image, one of RGB, ARGB or ALPHA. note that RGB images still require 0xff in the high byte because of how they'll be manipulated by other functions
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="pixels" kind="FIELD">
<body>
<first>( begin auto-generated from pixels.xml ) Array containing the values for all the pixels in the display window.</first>
<full>
Array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. The `index` value defines the position of a value within the array. For example, the statement `color b = pixels[230]` will set the variable `b` to be equal to the value at that location in the array.

Before accessing this array, the data must loaded with the `loadPixels()` function. After the array data has been modified, the `updatePixels()` function must be run to update the changes. Without `loadPixels()` , running the code may (or will in future releases) result in a NullPointerException.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Array containing the color of every pixel in the image</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="pixelDensity" kind="FIELD">
<body>
<first>1 for most images, 2 for hi-dpi/retina</first>
<full>
1 for most images, 2 for hi-dpi/retina
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="pixelWidth" kind="FIELD">
<body>
<first>Actual dimensions of pixels array, taking into account the 2x setting.</first>
<full>
Actual dimensions of pixels array, taking into account the 2x setting.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="width" kind="FIELD">
<body>
<first>( begin auto-generated from PImage_width.xml ) The width of the image in units of pixels.</first>
<full>
The width of the image in units of pixels.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Image width</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="height" kind="FIELD">
<body>
<first>( begin auto-generated from PImage_height.xml ) The height of the image in units of pixels.</first>
<full>
The height of the image in units of pixels.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:field</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@brief Image height</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="parent" kind="FIELD">
<body>
<first>Path to parent object that will be used with save().</first>
<full>
Path to parent object that will be used with save(). This prevents users from needing savePath() to use PImage.save().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="modified" kind="FIELD">
<body>
<first>modified portion of the image</first>
<full>
modified portion of the image
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="loaded" kind="FIELD">
<body>
<first>Loaded pixels flag</first>
<full>
Loaded pixels flag
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="init" kind="CONSTRUCTOR">
<body>
<first>( begin auto-generated from PImage.xml ) Datatype for storing images.</first>
<full>
Datatype for storing images. Processing can display `.gif` , `.jpg` , `.tga` , and `.png` images. Images may be displayed in 2D and 3D space. Before an image is used, it must be loaded with the `loadImage()` function. The `PImage` object contains fields for the `width` and `height` of the image, as well as an array called `pixels[]` which contains the values for every pixel in the image. A group of methods, described below, allow easy access to the image's pixels and alpha channel and simplify the process of compositing.

Before using the `pixels[]` array, be sure to use the `loadPixels()` method on the image to make sure that the pixel data is properly loaded.

To create a new image, use the `createImage()` function (do not use `new PImage()` ).
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
<blocktag>@see PApplet#imageMode(int)</blocktag>
<blocktag>@see PApplet#createImage(int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param width image width</blocktag>
<blocktag>@param height image height</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param format Either RGB, ARGB, ALPHA (grayscale alpha channel)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="init" kind="METHOD">
<body>
<first>Do not remove, see notes in the other variant.</first>
<full>
Do not remove, see notes in the other variant.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="init" kind="METHOD">
<body>
<first>Function to be used by subclasses of PImage to init later than at the constructor, or re-init later when things changes.</first>
<full>
Function to be used by subclasses of PImage to init later than at the constructor, or re-init later when things changes. Used by Capture and Movie classes (and perhaps others), because the width/height will not be known when super() is called. (Leave this public so that other libraries can do the same.)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="checkAlpha" kind="METHOD">
<body>
<first>Check the alpha on an image, using a really primitive loop.</first>
<full>
Check the alpha on an image, using a really primitive loop.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="loadPixels" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_loadPixels.xml ) Loads the pixel data for the image into its , `,pixels[],` , array.</first>
<full>
Loads the pixel data for the image into its `pixels[]` array. This function must always be called before reading from or writing to `pixels[]` .

renderers may or may not seem to require `loadPixels()` or `updatePixels()` . However, the rule is that any time you want to manipulate the `pixels[]` array, you must first call `loadPixels()` , and after changes have been made, call `updatePixels()` . Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.

Advanced
--------

Call this when you want to mess with the pixels[] array.

For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
</full>
</body>
<blocktags>
<blocktag>@webref pimage:pixels</blocktag>
<blocktag>@brief Loads the pixel data for the image into its pixels[] array</blocktag>
<blocktag>@usage web_application</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="updatePixels" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_updatePixels.xml ) Updates the image with the data in its , `,pixels[],` , array.</first>
<full>
Updates the image with the data in its `pixels[]` array. Use in conjunction with `loadPixels()` . If you're only reading pixels from the array, there's no need to call `updatePixels()` .

renderers may or may not seem to require `loadPixels()` or `updatePixels()` . However, the rule is that any time you want to manipulate the `pixels[]` array, you must first call `loadPixels()` , and after changes have been made, call `updatePixels()` . Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.

Currently, none of the renderers use the additional parameters to `updatePixels()` , however this may be implemented in the future.

Advanced
--------

Mark the pixels in this region as needing an update. This is not currently used by any of the renderers, however the api is structured this way in the hope of being able to use this to speed things up in the future.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:pixels</blocktag>
<blocktag>@brief Updates the image with the data in its pixels[] array</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param x x-coordinate of the upper-left corner</blocktag>
<blocktag>@param y y-coordinate of the upper-left corner</blocktag>
<blocktag>@param w width</blocktag>
<blocktag>@param h height</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="clone" kind="METHOD">
<body>
<first>Duplicate an image, returns new PImage object.</first>
<full>
Duplicate an image, returns new PImage object. The pixels[] array for the new object will be unique and recopied from the source image. This is implemented as an override of Object.clone(). We recommend using get() instead, because it prevents you from needing to catch the CloneNotSupportedException, and from doing a cast from the result.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="resize" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_resize.xml ) Resize the image to a new width and height.</first>
<full>
Resize the image to a new width and height. To make the image scale proportionally, use 0 as the value for the `wide` or `high` parameter. For instance, to make the width of an image 150 pixels, and change the height using the same proportion, use resize(150, 0).

Even though a PGraphics is technically a PImage, it is not possible to rescale the image data found in a PGraphics. (It's simply not possible to do this consistently across renderers: technically infeasible with P3D, or what would it even do with PDF?) If you want to resize PGraphics content, first get a copy of its image data using the `get()` method, and call `resize()` on the PImage that is returned.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:method</blocktag>
<blocktag>@brief Changes the size of an image to a new width and height</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param w the resized image width</blocktag>
<blocktag>@param h the resized image height</blocktag>
<blocktag>@see PImage#get(int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="get" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_get.xml ) Reads the color of any pixel or grabs a section of an image.</first>
<full>
Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned. Use the `x` and `y` parameters to get the value of one pixel. Get a section of the display window by specifying an additional `width` and `height` parameter. When getting an image, the `x` and `y` parameters define the coordinates for the upper-left corner of the image, regardless of the current `imageMode()` .

If the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with `colorMode(HSB)` , the numbers returned will be in RGB format.

Getting the color of a single pixel with `get(x, y)` is easy, but not as fast as grabbing the data directly from `pixels[]` . The equivalent statement to `get(x, y)` using `pixels[]` is `pixels[y*width+x]` . See the reference for `pixels[]` for more information.

Advanced
--------

Returns an ARGB "color" type (a packed 32 bit int with the color. If the coordinate is outside the image, zero is returned (black, but completely transparent).

If the image is in RGB format (i.e. on a PVideo object), the value will get its high bits set, just to avoid cases where they haven't been set already.

If the image is in ALPHA format, this returns a white with its alpha value set.

This function is included primarily for beginners. It is quite slow because it has to check to see if the x, y that was provided is inside the bounds, and then has to check to see what image type it is. If you want things to be more efficient, access the pixels[] array directly.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Reads the color of any pixel or grabs a rectangle of pixels</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param x x-coordinate of the pixel</blocktag>
<blocktag>@param y y-coordinate of the pixel</blocktag>
<blocktag>@see PApplet#set(int, int, int)</blocktag>
<blocktag>@see PApplet#pixels</blocktag>
<blocktag>@see PApplet#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="get" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param w width of pixel rectangle to get</blocktag>
<blocktag>@param h height of pixel rectangle to get</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="get" kind="METHOD">
<body>
<first>Returns a copy of this PImage.</first>
<full>
Returns a copy of this PImage. Equivalent to get(0, 0, width, height). Deprecated, just use copy() instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="getImpl" kind="METHOD">
<body>
<first>Internal function to actually handle getting a block of pixels that has already been properly cropped to a valid region.</first>
<full>
Internal function to actually handle getting a block of pixels that has already been properly cropped to a valid region. That is, x/y/w/h are guaranteed to be inside the image space, so the implementation can use the fastest possible pixel copying method.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="set" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_set.xml ) Changes the color of any pixel or writes an image directly into the display window.,
, ,
, The , `,x,` , and , `,y,` , parameters specify the pixel to change and the , `,color,` , parameter specifies the color value.</first>
<full>
Changes the color of any pixel or writes an image directly into the display window.

The `x` and `y` parameters specify the pixel to change and the `color` parameter specifies the color value. The color parameter is affected by the current color mode (the default is RGB values from 0 to 255). When setting an image, the `x` and `y` parameters define the coordinates for the upper-left corner of the image, regardless of the current `imageMode()` .

Setting the color of a single pixel with `set(x, y)` is easy, but not as fast as putting the data directly into `pixels[]` . The equivalent statement to `set(x, y, #000000)` using `pixels[]` is `pixels[y*width+x] = #000000` . See the reference for `pixels[]` for more information.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief writes a color to any pixel or writes an image into another</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param x x-coordinate of the pixel</blocktag>
<blocktag>@param y y-coordinate of the pixel</blocktag>
<blocktag>@param c any value of the color datatype</blocktag>
<blocktag>@see PImage#get(int, int, int, int)</blocktag>
<blocktag>@see PImage#pixels</blocktag>
<blocktag>@see PImage#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="set" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Efficient method of drawing an image's pixels directly to this surface. No variations are employed, meaning that any scale, tint, or imageMode settings will be ignored.
</full>
</body>
<blocktags>
<blocktag>@param img image to copy into the original image</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="setImpl" kind="METHOD">
<body>
<first>Internal function to actually handle setting a block of pixels that has already been properly cropped from the image to a valid region.</first>
<full>
Internal function to actually handle setting a block of pixels that has already been properly cropped from the image to a valid region.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="mask" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param maskArray array of integers used as the alpha channel, needs to be the same length as the image's pixel array.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="mask" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_mask.xml ) Masks part of an image from displaying by loading another image and using it as an alpha channel.</first>
<full>
Masks part of an image from displaying by loading another image and using it as an alpha channel. This mask image should only contain grayscale data, but only the blue color channel is used. The mask image needs to be the same size as the image to which it is applied.

In addition to using a mask image, an integer array containing the alpha channel data can be specified directly. This method is useful for creating dynamically generated alpha masks. This array must be of the same length as the target image's pixels array and should contain only grayscale data of values between 0-255.

Advanced
--------

Set alpha channel for an image. Black colors in the source image will make the destination image completely transparent, and white will make things fully opaque. Gray values will be in-between steps.

Strictly speaking the "blue" value from the source image is used as the alpha color. For a fully grayscale image, this is correct, but for a color image it's not 100% accurate. For a more accurate conversion, first use filter(GRAY) which will make the image into a "correct" grayscale by performing a proper luminance-based conversion.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param img image to use as the mask</blocktag>
<blocktag>@brief Masks part of an image with another image as an alpha channel</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="filter" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_filter.xml ) Filters an image as defined by one of the following modes:,
,
,THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.</first>
<full>
Filters an image as defined by one of the following modes:

THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.

GRAY - converts any colors in the image to grayscale equivalents

INVERT - sets each pixel to its inverse value

POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter

BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is used, the blur is equivalent to Guassian blur of radius 1

OPAQUE - sets the alpha channel to entirely opaque

ERODE - reduces the light areas with the amount defined by the level parameter

DILATE - increases the light areas with the amount defined by the level parameter

Advanced
--------

Method to apply a variety of basic filters to this image.



* filter(BLUR) provides a basic blur.
* filter(GRAY) converts the image to grayscale based on luminance.
* filter(INVERT) will invert the color components in the image.
* filter(OPAQUE) set all the high bits in the image to opaque
* filter(THRESHOLD) converts the image to black and white.
* filter(DILATE) grow white/light areas
* filter(ERODE) shrink white/light areas
Luminance conversion code contributed by&lt;A HREF="http://www.toxi.co.uk"&gt;toxi&lt;/A&gt;&lt;P/&gt;Gaussian blur code contributed by&lt;A HREF="http://incubator.quasimondo.com"&gt;Mario Klingemann&lt;/A&gt;
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Converts the image to grayscale or black and white</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param kind Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE</blocktag>
<blocktag>@param param unique for each, see above</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="opaque" kind="METHOD">
<body>
<first>Set the high bits of all pixels to opaque.</first>
<full>
Set the high bits of all pixels to opaque.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="buildBlurKernel" kind="METHOD">
<body>
<first>Optimized code for building the blur kernel.</first>
<full>
Optimized code for building the blur kernel. further optimized blur code (approx. 15% for radius=20) bigger speed gains for larger radii (~30%) added support for various image types (ALPHA, RGB, ARGB) [toxi 050728]
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="dilate" kind="METHOD">
<body>
<first>Generic dilate/erode filter using luminance values as decision factor.</first>
<full>
Generic dilate/erode filter using luminance values as decision factor. [toxi 050728]
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="copy" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_copy.xml ) Copies a region of pixels from one image into another.</first>
<full>
Copies a region of pixels from one image into another. If the source and destination regions aren't the same size, it will automatically resize source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.

As of release 0149, this function ignores `imageMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Copies the entire image</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param sx X coordinate of the source's upper left corner</blocktag>
<blocktag>@param sy Y coordinate of the source's upper left corner</blocktag>
<blocktag>@param sw source image width</blocktag>
<blocktag>@param sh source image height</blocktag>
<blocktag>@param dx X coordinate of the destination's upper left corner</blocktag>
<blocktag>@param dy Y coordinate of the destination's upper left corner</blocktag>
<blocktag>@param dw destination image width</blocktag>
<blocktag>@param dh destination image height</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PImage#blend(PImage, int, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="copy" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param src an image variable referring to the source image.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blendColor" kind="METHOD">
<body>
<first>( begin auto-generated from blendColor.xml ) Blends two color values together based on the blending mode given as the , `,MODE,` , parameter.</first>
<full>
Blends two color values together based on the blending mode given as the `MODE` parameter. The possible modes are described in the reference for the `blend()` function.

Advanced
--------



* REPLACE - destination colour equals colour of source pixel: C = A.     Sometimes called "Normal" or "Copy" in other software.
* BLEND - linear interpolation of colours:

```
C = A*factor + B
```


* ADD - additive blending with white clip:

```
C = min(A*factor + B, 255)
```

.     Clipped to 0..255, Photoshop calls this "Linear Burn",     and Director calls it "Add Pin".
* SUBTRACT - substractive blend with black clip:

```
C = max(B - A*factor, 0)
```

.     Clipped to 0..255, Photoshop calls this "Linear Dodge",     and Director calls it "Subtract Pin".
* DARKEST - only the darkest colour succeeds:

```
C = min(A*factor, B)
```

.     Illustrator calls this "Darken".
* LIGHTEST - only the lightest colour succeeds:

```
C = max(A*factor, B)
```

.     Illustrator calls this "Lighten".
* DIFFERENCE - subtract colors from underlying image.
* EXCLUSION - similar to DIFFERENCE, but less extreme.
* MULTIPLY - Multiply the colors, result will always be darker.
* SCREEN - Opposite multiply, uses inverse values of the colors.
* OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,     and screens light values.
* HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.
* SOFT_LIGHT - Mix of DARKEST and LIGHTEST.     Works like OVERLAY, but not as harsh.
* DODGE - Lightens light tones and increases contrast, ignores darks.     Called "Color Dodge" in Illustrator and Photoshop.
* BURN - Darker areas are applied, increasing contrast, ignores lights.     Called "Color Burn" in Illustrator and Photoshop.


A useful reference for blending modes and their algorithms can be found in the&lt;A HREF="http://www.w3.org/TR/SVG12/rendering.html"&gt;SVG&lt;/A&gt;specification.



It is important to note that Processing uses "fast" code, not necessarily "correct" code. No biggie, most software does. A nitpicker can find numerous "off by 1 division" problems in the blend code where

```
&gt;&gt;8
```

or

```
&gt;&gt;7
```

is used when strictly speaking

```
/255.0

or

```
/127.0
```

should have been used.



For instance, exclusion (not intended for real-time use) reads

```
r1 + r2 - ((2 * r1 * r2) / 255)
```

because

```
255 == 1.0
```

not

```
256 == 1.0
```

. In other words,

```
(255*255)&gt;&gt;8
```

is not the same as

```
(255*255)/255
```

. But for real-time use the shifts are preferrable, and the difference is insignificant for applications built with Processing.


</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param c1 the first color to blend</blocktag>
<blocktag>@param c2 the second color to blend</blocktag>
<blocktag>@param mode either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN</blocktag>
<blocktag>@see PImage#blend(PImage, int, int, int, int, int, int, int, int, int)</blocktag>
<blocktag>@see PApplet#color(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_blend.xml ) Blends a region of pixels into the image specified by the , `,img,` , parameter.</first>
<full>
Blends a region of pixels into the image specified by the `img` parameter. These copies utilize full alpha channel support and a choice of the following modes to blend the colors of source pixels (A) with the ones of pixels in the destination image (B):

BLEND - linear interpolation of colours: C = A*factor + B

ADD - additive blending with white clip: C = min(A*factor + B, 255)

SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)

DARKEST - only the darkest colour succeeds: C = min(A*factor, B)

LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)

DIFFERENCE - subtract colors from underlying image.

EXCLUSION - similar to DIFFERENCE, but less extreme.

MULTIPLY - Multiply the colors, result will always be darker.

SCREEN - Opposite multiply, uses inverse values of the colors.

OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.

HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.

SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.

DODGE - Lightens light tones and increases contrast, ignores darks. Called "Color Dodge" in Illustrator and Photoshop.

BURN - Darker areas are applied, increasing contrast, ignores lights. Called "Color Burn" in Illustrator and Photoshop.

All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the `srcImg` parameter is not used, the display window is used as the source image.

As of release 0149, this function ignores `imageMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Copies a pixel or rectangle of pixels using different blending modes</blocktag>
<blocktag>@param src an image variable referring to the source image</blocktag>
<blocktag>@param sx X coordinate of the source's upper left corner</blocktag>
<blocktag>@param sy Y coordinate of the source's upper left corner</blocktag>
<blocktag>@param sw source image width</blocktag>
<blocktag>@param sh source image height</blocktag>
<blocktag>@param dx X coordinate of the destinations's upper left corner</blocktag>
<blocktag>@param dy Y coordinate of the destinations's upper left corner</blocktag>
<blocktag>@param dw destination image width</blocktag>
<blocktag>@param dh destination image height</blocktag>
<blocktag>@param mode Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN</blocktag>
<blocktag>@see PApplet#alpha(int)</blocktag>
<blocktag>@see PImage#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
<blocktag>@see PImage#blendColor(int,int,int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="intersect" kind="METHOD">
<body>
<first>Check to see if two rectangles intersect one another</first>
<full>
Check to see if two rectangles intersect one another
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blit_resize" kind="METHOD">
<body>
<first>Internal blitter/resizer/copier from toxi.</first>
<full>
Internal blitter/resizer/copier from toxi. Uses bilinear filtering if smooth() has been enabled 'mode' determines the blending mode used in the process.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_blend" kind="METHOD">
<body>
<first>Blend O = S</first>
<full>
Blend O = S
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_add_pin" kind="METHOD">
<body>
<first>Add O = MIN(D + S, 1)</first>
<full>
Add O = MIN(D + S, 1)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_sub_pin" kind="METHOD">
<body>
<first>Subtract O = MAX(0, D - S)</first>
<full>
Subtract O = MAX(0, D - S)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_lightest" kind="METHOD">
<body>
<first>Lightest O = MAX(D, S)</first>
<full>
Lightest O = MAX(D, S)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_darkest" kind="METHOD">
<body>
<first>Darkest O = MIN(D, S)</first>
<full>
Darkest O = MIN(D, S)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_difference" kind="METHOD">
<body>
<first>Difference O = ABS(D - S)</first>
<full>
Difference O = ABS(D - S)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_exclusion" kind="METHOD">
<body>
<first>Exclusion O = (1 - S)D + S(1 - D) O = D + S - 2DS</first>
<full>
Exclusion O = (1 - S)D + S(1 - D) O = D + S - 2DS
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_screen" kind="METHOD">
<body>
<first>Screen O = 1 - (1 - D)(1 - S) O = D + S - DS</first>
<full>
Screen O = 1 - (1 - D)(1 - S) O = D + S - DS
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_overlay" kind="METHOD">
<body>
<first>Overlay O = 2 * MULTIPLY(D, S) = 2DS                   for D ,&lt;, 0.5 O = 2 * SCREEN(D, S) - 1 = 2(S + D - DS) - 1   otherwise</first>
<full>
Overlay O = 2 * MULTIPLY(D, S) = 2DS                   for D&lt;0.5 O = 2 * SCREEN(D, S) - 1 = 2(S + D - DS) - 1   otherwise
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_hard_light" kind="METHOD">
<body>
<first>Hard Light O = OVERLAY(S, D) O = 2 * MULTIPLY(D, S) = 2DS                   for S ,&lt;, 0.5 O = 2 * SCREEN(D, S) - 1 = 2(S + D - DS) - 1   otherwise</first>
<full>
Hard Light O = OVERLAY(S, D) O = 2 * MULTIPLY(D, S) = 2DS                   for S&lt;0.5 O = 2 * SCREEN(D, S) - 1 = 2(S + D - DS) - 1   otherwise
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_soft_light" kind="METHOD">
<body>
<first>Soft Light (Pegtop) O = (1 - D) * MULTIPLY(D, S) + D * SCREEN(D, S) O = (1 - D) * DS + D * (1 - (1 - D)(1 - S)) O = 2DS + DD - 2DDS</first>
<full>
Soft Light (Pegtop) O = (1 - D) * MULTIPLY(D, S) + D * SCREEN(D, S) O = (1 - D) * DS + D * (1 - (1 - D)(1 - S)) O = 2DS + DD - 2DDS
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_dodge" kind="METHOD">
<body>
<first>Dodge O = D / (1 - S)</first>
<full>
Dodge O = D / (1 - S)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="blend_burn" kind="METHOD">
<body>
<first>Burn O = 1 - (1 - A) / B</first>
<full>
Burn O = 1 - (1 - A) / B
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="loadTGA" kind="METHOD">
<body>
<first>Targa image loader for RLE-compressed TGA files.</first>
<full>
Targa image loader for RLE-compressed TGA files.

Rewritten for 0115 to read/write RLE-encoded targa images. For 0125, non-RLE encoded images are now supported, along with images whose y-order is reversed (which is standard for TGA files).

A version of this function is in MovieMaker.java. Any fixes here should be applied over in MovieMaker as well.

Known issue with RLE encoding and odd behavior in some apps: https://github.com/processing/processing/issues/2096 Please help!
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="saveTGA" kind="METHOD">
<body>
<first>Creates a Targa32 formatted byte sequence of specified pixel buffer using RLE compression.</first>
<full>
Creates a Targa32 formatted byte sequence of specified pixel buffer using RLE compression.&lt;/p&gt;Also figured out how to avoid parsing the image upside-down (there's a header flag to set the image origin to top-left)&lt;/p&gt;Starting with revision 0092, the format setting is taken into account:

* 

```
ALPHA
```

images written as 8bit grayscale (uses lowest byte)
* 

```
RGB
```

24 bits
* 

```
ARGB
```

32 bits
All versions are RLE compressed.&lt;/p&gt;Contributed by toxi 8-10 May 2005, based on this RLE&lt;A HREF="http://www.wotsit.org/download.asp?f=tga"&gt;specification&lt;/A&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PImage" name="save" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_save.xml ) Saves the image into a file.</first>
<full>
Saves the image into a file. Append a file extension to the name of the file, to indicate the file format to be used: either TIFF (.tif), TARGA (.tga), JPEG (.jpg), or PNG (.png). If no extension is included in the filename, the image will save in TIFF format and .tif will be added to the name.  These files are saved to the sketch's folder, which may be opened by selecting "Show sketch folder" from the "Sketch" menu.

To save an image created within the code, rather than through loading, it's necessary to make the image with the `createImage()` function so it is aware of the location of the program and can therefore save the file to the right place. See the `createImage()` reference for more information.

Advanced
--------

Save this image to disk.

As of revision 0100, this function requires an absolute path, in order to avoid confusion. To save inside the sketch folder, use the function savePath() from PApplet, or use saveFrame() instead. As of revision 0116, savePath() is not needed if this object has been created (as recommended) via createImage() or createGraphics() or one of its neighbors.

As of revision 0115, when using Java 1.4 and later, you can write to several formats besides tga and tiff. If Java 1.4 is installed and the extension used is supported (usually png, jpg, jpeg, bmp, and tiff), then those methods will be used to write the image. To get a list of the supported formats for writing, use:


```
println(javax.imageio.ImageIO.getReaderFormatNames())
```



To use the original built-in image writers, use .tga or .tif as the extension, or don't include an extension. When no extension is used, the extension .tif will be added to the file name.

The ImageIO API claims to support wbmp files, however they probably require a black and white image. Basic testing produced a zero-length file with no error.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:method</blocktag>
<blocktag>@brief Saves the image to a TIFF, TARGA, PNG, or JPEG file</blocktag>
<blocktag>@usage application</blocktag>
<blocktag>@param filename a sequence of letters and numbers</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="path" kind="FIELD">
<body>
<first>path to the file being saved for this renderer (if any)</first>
<full>
path to the file being saved for this renderer (if any)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="primaryGraphics" kind="FIELD">
<body>
<first>True if this is the main graphics context for a sketch.</first>
<full>
True if this is the main graphics context for a sketch. False for offscreen buffers retrieved via createGraphics().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="hints" kind="FIELD">
<body>
<first>Array of hint[] items.</first>
<full>
Array of hint[] items. These are hacks to get around various temporary workarounds inside the environment.

Note that this array cannot be static, as a hint() may result in a runtime change specific to a renderer. For instance, calling hint(DISABLE_DEPTH_TEST) has to call glDisable() right away on an instance of PGraphicsOpenGL.

The hints[] array is allocated early on because it might be used inside beginDraw(), allocate(), etc.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="cacheMap" kind="FIELD">
<body>
<first>Storage for renderer-specific image data.</first>
<full>
Storage for renderer-specific image data. In 1.x, renderers wrote cache data into the image object. In 2.x, the renderer has a weak-referenced map that points at any of the images it has worked on already. When the images go out of scope, they will be properly garbage collected.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="SR" kind="FIELD">
<body>
<first>stroke argb values</first>
<full>
stroke argb values
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="SW" kind="FIELD">
<body>
<first>stroke weight</first>
<full>
stroke weight
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorMode" kind="FIELD">
<body>
<first>The current colorMode</first>
<full>
The current colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeX" kind="FIELD">
<body>
<first>Max value for red (or hue) set by colorMode</first>
<full>
Max value for red (or hue) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeY" kind="FIELD">
<body>
<first>Max value for green (or saturation) set by colorMode</first>
<full>
Max value for green (or saturation) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeZ" kind="FIELD">
<body>
<first>Max value for blue (or value) set by colorMode</first>
<full>
Max value for blue (or value) set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeA" kind="FIELD">
<body>
<first>Max value for alpha set by colorMode</first>
<full>
Max value for alpha set by colorMode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeScale" kind="FIELD">
<body>
<first>True if colors are not in the range 0..1</first>
<full>
True if colors are not in the range 0..1
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorModeDefault" kind="FIELD">
<body>
<first>True if colorMode(RGB, 255).</first>
<full>
True if colorMode(RGB, 255). Defaults to true so that color() used as part of a field declaration will properly assign values.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tint" kind="FIELD">
<body>
<first>True if tint() is enabled (read-only).</first>
<full>
True if tint() is enabled (read-only). Using tint/tintColor seems a better option for naming than tintEnabled/tint because the latter seems ugly, even though g.tint as the actual color seems a little more intuitive, it's just that g.tintEnabled is even more unintuitive. Same goes for fill and stroke, et al.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tintColor" kind="FIELD">
<body>
<first>tint that was last set (read-only)</first>
<full>
tint that was last set (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fill" kind="FIELD">
<body>
<first>true if fill() is enabled, (read-only)</first>
<full>
true if fill() is enabled, (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fillColor" kind="FIELD">
<body>
<first>fill that was last set (read-only)</first>
<full>
fill that was last set (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="stroke" kind="FIELD">
<body>
<first>true if stroke() is enabled, (read-only)</first>
<full>
true if stroke() is enabled, (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeColor" kind="FIELD">
<body>
<first>stroke that was last set (read-only)</first>
<full>
stroke that was last set (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeWeight" kind="FIELD">
<body>
<first>Last value set by strokeWeight() (read-only).</first>
<full>
Last value set by strokeWeight() (read-only). This has a default setting, rather than fighting with renderers about whether that renderer supports thick lines.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeJoin" kind="FIELD">
<body>
<first>Set by strokeJoin() (read-only).</first>
<full>
Set by strokeJoin() (read-only). This has a default setting so that strokeJoin() need not be called by defaults, because subclasses may not implement it (i.e. PGraphicsGL)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeCap" kind="FIELD">
<body>
<first>Set by strokeCap() (read-only).</first>
<full>
Set by strokeCap() (read-only). This has a default setting so that strokeCap() need not be called by defaults, because subclasses may not implement it (i.e. PGraphicsGL)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rectMode" kind="FIELD">
<body>
<first>The current rect mode (read-only)</first>
<full>
The current rect mode (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ellipseMode" kind="FIELD">
<body>
<first>The current ellipse mode (read-only)</first>
<full>
The current ellipse mode (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shapeMode" kind="FIELD">
<body>
<first>The current shape alignment mode (read-only)</first>
<full>
The current shape alignment mode (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="imageMode" kind="FIELD">
<body>
<first>The current image alignment (read-only)</first>
<full>
The current image alignment (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textFont" kind="FIELD">
<body>
<first>The current text font (read-only)</first>
<full>
The current text font (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textAlign" kind="FIELD">
<body>
<first>The current text align (read-only)</first>
<full>
The current text align (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textAlignY" kind="FIELD">
<body>
<first>The current vertical text alignment (read-only)</first>
<full>
The current vertical text alignment (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textMode" kind="FIELD">
<body>
<first>The current text mode (read-only)</first>
<full>
The current text mode (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textSize" kind="FIELD">
<body>
<first>The current text size (read-only)</first>
<full>
The current text size (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textLeading" kind="FIELD">
<body>
<first>The current text leading (read-only)</first>
<full>
The current text leading (read-only)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="backgroundColor" kind="FIELD">
<body>
<first>Last background color that was set, zero if an image</first>
<full>
Last background color that was set, zero if an image
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="blendMode" kind="FIELD">
<body>
<first>The current blending mode.</first>
<full>
The current blending mode.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="MATRIX_STACK_DEPTH" kind="FIELD">
<body>
<first>Current model-view matrix transformation of the form m[row][column], which is a "column vector" (as opposed to "row vector") matrix.</first>
<full>
Current model-view matrix transformation of the form m[row][column], which is a "column vector" (as opposed to "row vector") matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="image" kind="FIELD">
<body>
<first>Java AWT Image object associated with this renderer.</first>
<full>
Java AWT Image object associated with this renderer. For the 1.0 version of P2D and P3D, this was associated with their MemoryImageSource. For PGraphicsJava2D, it will be the offscreen drawing buffer.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="surface" kind="FIELD">
<body>
<first>Surface object that we're talking to</first>
<full>
Surface object that we're talking to
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="cacheHsbKey" kind="FIELD">
<body>
<first>The last RGB value converted to HSB</first>
<full>
The last RGB value converted to HSB
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="cacheHsbValue" kind="FIELD">
<body>
<first>Result of the last conversion to HSB</first>
<full>
Result of the last conversion to HSB
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shape" kind="FIELD">
<body>
<first>Type of shape passed to beginShape(), zero if no shape is currently being drawn.</first>
<full>
Type of shape passed to beginShape(), zero if no shape is currently being drawn.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textBuffer" kind="FIELD">
<body>
<first>Internal buffer used by the text() functions because the String object is slow</first>
<full>
Internal buffer used by the text() functions because the String object is slow
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="normalX" kind="FIELD">
<body>
<first>Current normal vector.</first>
<full>
Current normal vector.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="normalY" kind="FIELD">
<body>
<first>Current normal vector.</first>
<full>
Current normal vector.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="normalZ" kind="FIELD">
<body>
<first>Current normal vector.</first>
<full>
Current normal vector.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureMode" kind="FIELD">
<body>
<first>Sets whether texture coordinates passed to vertex() calls will be based on coordinates that are based on the IMAGE or NORMALIZED.</first>
<full>
Sets whether texture coordinates passed to vertex() calls will be based on coordinates that are based on the IMAGE or NORMALIZED.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureU" kind="FIELD">
<body>
<first>Current horizontal coordinate for texture, will always be between 0 and 1, even if using textureMode(IMAGE).</first>
<full>
Current horizontal coordinate for texture, will always be between 0 and 1, even if using textureMode(IMAGE).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureV" kind="FIELD">
<body>
<first>Current vertical coordinate for texture, see above.</first>
<full>
Current vertical coordinate for texture, see above.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureImage" kind="FIELD">
<body>
<first>Current image being used as a texture</first>
<full>
Current image being used as a texture
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setPrimary" kind="METHOD">
<body>
<first>Set (or unset) this as the main drawing surface.</first>
<full>
Set (or unset) this as the main drawing surface. Meaning that it can safely be set to opaque (and given a default gray background), or anything else that goes along with that.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setSize" kind="METHOD">
<body>
<first>The final step in setting up a renderer, set its size of this renderer.</first>
<full>
The final step in setting up a renderer, set its size of this renderer. This was formerly handled by the constructor, but instead it's been broken out so that setParent/setPrimary/setPath can be handled differently. Important: this is ignored by the Methods task because otherwise it will override setSize() in PApplet/Applet/Component, which will 1) not call super.setSize(), and 2) will cause the renderer to be resized from the event thread (EDT), causing a nasty crash as it collides with the animation thread.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="dispose" kind="METHOD">
<body>
<first>Handle any takedown for this graphics context.</first>
<full>
Handle any takedown for this graphics context.

This is called when a sketch is shut down and this renderer was specified using the size() command, or inside endRecord() and endRaw(), in order to shut things off.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setCache" kind="METHOD">
<body>
<first>Store data of some kind for the renderer that requires extra metadata of some kind.</first>
<full>
Store data of some kind for the renderer that requires extra metadata of some kind. Usually this is a renderer-specific representation of the image data, for instance a BufferedImage with tint() settings applied for PGraphicsJava2D, or resized image data and OpenGL texture indices for PGraphicsOpenGL.
</full>
</body>
<blocktags>
<blocktag>@param image The image to be stored</blocktag>
<blocktag>@param storage The metadata required by the renderer</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="getCache" kind="METHOD">
<body>
<first>Get cache storage data for the specified renderer.</first>
<full>
Get cache storage data for the specified renderer. Because each renderer will cache data in different formats, it's necessary to store cache data keyed by the renderer object. Otherwise, attempting to draw the same image to both a PGraphicsJava2D and a PGraphicsOpenGL will cause errors.
</full>
</body>
<blocktags>
<blocktag>@return metadata stored for the specified renderer</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="removeCache" kind="METHOD">
<body>
<first>Remove information associated with this renderer from the cache, if any.</first>
<full>
Remove information associated with this renderer from the cache, if any.
</full>
</body>
<blocktags>
<blocktag>@param image The image whose cache data should be removed</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginDraw" kind="METHOD">
<body>
<first>( begin auto-generated from PGraphics_beginDraw.xml ) Sets the default properties for a PGraphics object.</first>
<full>
Sets the default properties for a PGraphics object. It should be called before anything is drawn into the object.

Advanced
--------

When creating your own PGraphics, you should call this before drawing anything.
</full>
</body>
<blocktags>
<blocktag>@webref pgraphics:method</blocktag>
<blocktag>@brief Sets the default properties for a PGraphics object</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="endDraw" kind="METHOD">
<body>
<first>( begin auto-generated from PGraphics_endDraw.xml ) Finalizes the rendering of a PGraphics object so that it can be shown on screen.</first>
<full>
Finalizes the rendering of a PGraphics object so that it can be shown on screen.

Advanced
--------



When creating your own PGraphics, you should call this when you're finished drawing.
</full>
</body>
<blocktags>
<blocktag>@webref pgraphics:method</blocktag>
<blocktag>@brief Finalizes the rendering of a PGraphics object</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="defaultSettings" kind="METHOD">
<body>
<first>Set engine's default values.</first>
<full>
Set engine's default values. This has to be called by PApplet, somewhere inside setup() or draw() because it talks to the graphics buffer, meaning that for subclasses like OpenGL, there needs to be a valid graphics context to mess with otherwise you'll get some good crashing action. This is currently called by checkSettings(), during beginDraw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="reapplySettings" kind="METHOD">
<body>
<first>Re-apply current settings.</first>
<full>
Re-apply current settings. Some methods, such as textFont(), require that their methods be called (rather than simply setting the textFont variable) because they affect the graphics context, or they require parameters from the context (e.g. getting native fonts for text). This will only be called from an allocate(), which is only called from size(), which is safely called from inside beginDraw(). And it cannot be called before defaultSettings(), so we should be safe.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="hint" kind="METHOD">
<body>
<first>( begin auto-generated from hint.xml ) Set various hints and hacks for the renderer.</first>
<full>
Set various hints and hacks for the renderer. This is used to handle obscure rendering features that cannot be implemented in a consistent manner across renderers. Many options will often graduate to standard features instead of hints over time.

hint(ENABLE_OPENGL_4X_SMOOTH) - Enable 4x anti-aliasing for P3D. This can help force anti-aliasing if it has not been enabled by the user. On some graphics cards, this can also be set by the graphics driver's control panel, however not all cards make this available. This hint must be called immediately after the size() command because it resets the renderer, obliterating any settings and anything drawn (and like size(), re-running the code that came before it again).

hint(DISABLE_OPENGL_2X_SMOOTH) - In Processing 1.0, Processing always enables 2x smoothing when the P3D renderer is used. This hint disables the default 2x smoothing and returns the smoothing behavior found in earlier releases, where smooth() and noSmooth() could be used to enable and disable smoothing, though the quality was inferior.

hint(ENABLE_NATIVE_FONTS) - Use the native version fonts when they are installed, rather than the bitmapped version from a .vlw file. This is useful with the default (or JAVA2D) renderer setting, as it will improve font rendering speed. This is not enabled by default, because it can be misleading while testing because the type will look great on your machine (because you have the font installed) but lousy on others' machines if the identical font is unavailable. This option can only be set per-sketch, and must be called before any use of textFont().

hint(DISABLE_DEPTH_TEST) - Disable the zbuffer, allowing you to draw on top of everything at will. When depth testing is disabled, items will be drawn to the screen sequentially, like a painting. This hint is most often used to draw in 3D, then draw in 2D on top of it (for instance, to draw GUI controls in 2D on top of a 3D interface). Starting in release 0149, this will also clear the depth buffer. Restore the default with hint(ENABLE_DEPTH_TEST), but note that with the depth buffer cleared, any 3D drawing that happens later in draw() will ignore existing shapes on the screen.

hint(ENABLE_DEPTH_SORT) - Enable primitive z-sorting of triangles and lines in P3D and OPENGL. This can slow performance considerably, and the algorithm is not yet perfect. Restore the default with hint(DISABLE_DEPTH_SORT).

hint(DISABLE_OPENGL_ERROR_REPORT) - Speeds up the P3D renderer setting by not checking for errors while running. Undo with hint(ENABLE_OPENGL_ERROR_REPORT).

hint(ENABLE_BUFFER_READING) - Depth and stencil buffers in P2D/P3D will be downsampled to make PGL#readPixels work with multisampling. Enabling this introduces some overhead, so if you experience bad performance, disable multisampling with noSmooth() instead. This hint is not intended to be enabled and disabled repeatedely, so call this once in setup() or after creating your PGraphics2D/3D. You can restore the default with hint(DISABLE_BUFFER_READING) if you don't plan to read depth from this PGraphics anymore.

hint(ENABLE_KEY_REPEAT) - Auto-repeating key events are discarded by default (works only in P2D/P3D); use this hint to get all the key events (including auto-repeated). Call hint(DISABLE_KEY_REPEAT) to get events only when the key goes physically up or down.

hint(DISABLE_ASYNC_SAVEFRAME) - P2D/P3D only - save() and saveFrame() will not use separate threads for saving and will block until the image is written to the drive. This was the default behavior in 3.0b7 and before. To enable, call hint(ENABLE_ASYNC_SAVEFRAME).

As of release 0149, unhint() has been removed in favor of adding additional ENABLE/DISABLE constants to reset the default behavior. This prevents the double negatives, and also reinforces which hints can be enabled or disabled.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param which name of the hint to be enabled or disabled</blocktag>
<blocktag>@see PGraphics</blocktag>
<blocktag>@see PApplet#createGraphics(int, int, String, String)</blocktag>
<blocktag>@see PApplet#size(int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginShape" kind="METHOD">
<body>
<first>Start a new shape of type POLYGON</first>
<full>
Start a new shape of type POLYGON
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginShape" kind="METHOD">
<body>
<first>( begin auto-generated from beginShape.xml ) Using the , `,beginShape(),` , and , `,endShape(),` , functions allow creating more complex forms.</first>
<full>
Using the `beginShape()` and `endShape()` functions allow creating more complex forms. `beginShape()` begins recording vertices for a shape and `endShape()` stops recording. The value of the `MODE` parameter tells it which types of shapes to create from the provided vertices. With no mode specified, the shape can be any irregular polygon. The parameters available for beginShape() are POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `beginShape()` function, a series of `vertex()` commands must follow. To stop drawing the shape, call `endShape()` . The `vertex()` function with two parameters specifies a position in 2D and the `vertex()` function with three parameters specifies a position in 3D. Each shape will be outlined with the current stroke color and filled with the fill color.

Transformations such as `translate()` , `rotate()` , and `scale()` do not work within `beginShape()` . It is also not possible to use other shapes, such as `ellipse()` or `rect()` within `beginShape()` .

The P3D renderer settings allow `stroke()` and `fill()` settings to be altered per-vertex, however the default P2D renderer does not. Settings such as `strokeWeight()` , `strokeCap()` , and `strokeJoin()` cannot be changed while inside a `beginShape()` / `endShape()` block with any renderer.
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param kind Either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#endShape()</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="edge" kind="METHOD">
<body>
<first>Sets whether the upcoming vertex is part of an edge.</first>
<full>
Sets whether the upcoming vertex is part of an edge. Equivalent to glEdgeFlag(), for people familiar with OpenGL.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="normal" kind="METHOD">
<body>
<first>( begin auto-generated from normal.xml ) Sets the current normal vector.</first>
<full>
Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and specifies a vector perpendicular to the surface of the shape which determines how lighting affects it. Processing attempts to automatically assign normals to shapes, but since that's imperfect, this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@param nx x direction</blocktag>
<blocktag>@param ny y direction</blocktag>
<blocktag>@param nz z direction</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureMode" kind="METHOD">
<body>
<first>( begin auto-generated from textureMode.xml ) Sets the coordinate space for texture mapping.</first>
<full>
Sets the coordinate space for texture mapping. There are two options, IMAGE, which refers to the actual coordinates of the image, and NORMAL, which refers to a normalized space of values ranging from 0 to 1. The default mode is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200). The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param mode either IMAGE or NORMAL</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
<blocktag>@see PGraphics#textureWrap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textureWrap" kind="METHOD">
<body>
<first>( begin auto-generated from textureWrap.xml ) Description to come...</first>
<full>
Description to come... ( end auto-generated from textureWrap.xml )
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param wrap Either CLAMP (default) or REPEAT</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
<blocktag>@see PGraphics#textureMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="texture" kind="METHOD">
<body>
<first>( begin auto-generated from texture.xml ) Sets a texture to be applied to vertex points.</first>
<full>
Sets a texture to be applied to vertex points. The `texture()` function must be called between `beginShape()` and `endShape()` and before any calls to `vertex()` .

When textures are in use, the fill color is ignored. Instead, use tint() to specify the color of the texture as it is applied to the shape.
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param image reference to a PImage object</blocktag>
<blocktag>@see PGraphics#textureMode(int)</blocktag>
<blocktag>@see PGraphics#textureWrap(int)</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noTexture" kind="METHOD">
<body>
<first>Removes texture image for current shape.</first>
<full>
Removes texture image for current shape. Needs to be called between beginShape and endShape
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="vertex" kind="METHOD">
<body>
<first>Used by renderer subclasses or PShape to efficiently pass in already formatted vertex information.</first>
<full>
Used by renderer subclasses or PShape to efficiently pass in already formatted vertex information.
</full>
</body>
<blocktags>
<blocktag>@param v vertex parameters, as a float array of length VERTEX_FIELD_COUNT</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="vertex" kind="METHOD">
<body>
<first>( begin auto-generated from vertex.xml ) All shapes are constructed by connecting a series of vertices.</first>
<full>
All shapes are constructed by connecting a series of vertices. `vertex()` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the `beginShape()` and `endShape()` function.

Drawing a vertex in 3D using the `z` parameter requires the P3D parameter in combination with size as shown in the above example.

This function is also used to map a texture onto the geometry. The `texture()` function declares the texture to apply to the geometry and the `u` and `v` coordinates set define the mapping of this texture to the form. By default, the coordinates used for `u` and `v` are specified in relation to the image's size in pixels, but this relation can be changed with `textureMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x x-coordinate of the vertex</blocktag>
<blocktag>@param y y-coordinate of the vertex</blocktag>
<blocktag>@param z z-coordinate of the vertex</blocktag>
<blocktag>@param u horizontal coordinate for the texture mapping</blocktag>
<blocktag>@param v vertical coordinate for the texture mapping</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="vertexTexture" kind="METHOD">
<body>
<first>Set (U, V) coords for the next vertex in the current shape.</first>
<full>
Set (U, V) coords for the next vertex in the current shape. This is ugly as its own function, and will (almost?) always be coincident with a call to vertex. As of beta, this was moved to the protected method you see here, and called from an optional param of and overloaded vertex().

The parameters depend on the current textureMode. When using textureMode(IMAGE), the coordinates will be relative to the size of the image texture, when used with textureMode(NORMAL), they'll be in the range 0..1.

Used by both PGraphics2D (for images) and PGraphics3D.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="endContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="endShape" kind="METHOD">
<body>
<first>( begin auto-generated from endShape.xml ) The , `,endShape(),` , function is the companion to , `,beginShape(),` , and may only be called after , `,beginShape(),` ,.</first>
<full>
The `endShape()` function is the companion to `beginShape()` and may only be called after `beginShape()` . When `endshape()` is called, all of image data defined since the previous call to `beginShape()` is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param mode use CLOSE to close the shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="loadShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape</blocktag>
<blocktag>@param filename name of file to load, can be .svg or .obj</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PApplet#createShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="loadShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="createShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PShape#endShape()</blocktag>
<blocktag>@see PApplet#loadShape(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="createShapeFamily" kind="METHOD">
<body>
<first>Override this method to return an appropriate shape for your renderer</first>
<full>
Override this method to return an appropriate shape for your renderer
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="createShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind either POINT, LINE, TRIANGLE, QUAD, RECT, ELLIPSE, ARC, BOX, SPHERE</blocktag>
<blocktag>@param p parameters that match the kind of shape</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="createShapePrimitive" kind="METHOD">
<body>
<first>Override this to have a custom shape object used by your renderer.</first>
<full>
Override this to have a custom shape object used by your renderer.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="loadShader" kind="METHOD">
<body>
<first>( begin auto-generated from loadShader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
<blocktag>@param fragFilename name of fragment shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="loadShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vertFilename name of vertex shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shader" kind="METHOD">
<body>
<first>( begin auto-generated from shader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
<blocktag>@param shader name of shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind type of shader, either POINTS, LINES, or TRIANGLES</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="resetShader" kind="METHOD">
<body>
<first>( begin auto-generated from resetShader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="resetShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind type of shader, either POINTS, LINES, or TRIANGLES</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="filter" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param shader the fragment shader to apply</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="clip" kind="METHOD">
<body>
<first>( begin auto-generated from clip.xml ) Limits the rendering to the boundaries of a rectangle defined by the parameters.</first>
<full>
Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the `imageMode()` fuction, either CORNER, CORNERS, or CENTER.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param a x-coordinate of the rectangle, by default</blocktag>
<blocktag>@param b y-coordinate of the rectangle, by default</blocktag>
<blocktag>@param c width of the rectangle, by default</blocktag>
<blocktag>@param d height of the rectangle, by default</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noClip" kind="METHOD">
<body>
<first>( begin auto-generated from noClip.xml ) Disables the clipping previously started by the , `,clip(),` , function.</first>
<full>
Disables the clipping previously started by the `clip()` function.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="blendMode" kind="METHOD">
<body>
<first>( begin auto-generated from blendMode.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param mode the blending mode to use</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="bezierVertex" kind="METHOD">
<body>
<first>( begin auto-generated from bezierVertex.xml ) Specifies vertex coordinates for Bezier curves.</first>
<full>
Specifies vertex coordinates for Bezier curves. Each call to `bezierVertex()` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `bezierVertex()` is used within a `beginShape()` call, it must be prefaced with a call to `vertex()` to set the first anchor point. This function must be used between `beginShape()` and `endShape()` and only when there is no MODE parameter specified to `beginShape()` . Using the 3D version requires rendering with P3D (see the Environment reference for more information).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x2 the x-coordinate of the 1st control point</blocktag>
<blocktag>@param y2 the y-coordinate of the 1st control point</blocktag>
<blocktag>@param z2 the z-coordinate of the 1st control point</blocktag>
<blocktag>@param x3 the x-coordinate of the 2nd control point</blocktag>
<blocktag>@param y3 the y-coordinate of the 2nd control point</blocktag>
<blocktag>@param z3 the z-coordinate of the 2nd control point</blocktag>
<blocktag>@param x4 the x-coordinate of the anchor point</blocktag>
<blocktag>@param y4 the y-coordinate of the anchor point</blocktag>
<blocktag>@param z4 the z-coordinate of the anchor point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="quadraticVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param cx the x-coordinate of the control point</blocktag>
<blocktag>@param cy the y-coordinate of the control point</blocktag>
<blocktag>@param x3 the x-coordinate of the anchor point</blocktag>
<blocktag>@param y3 the y-coordinate of the anchor point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="quadraticVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param cz the z-coordinate of the control point</blocktag>
<blocktag>@param z3 the z-coordinate of the anchor point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveVertexCheck" kind="METHOD">
<body>
<first>Perform initialization specific to curveVertex(), and handle standard error modes.</first>
<full>
Perform initialization specific to curveVertex(), and handle standard error modes. Can be overridden by subclasses that need the flexibility.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveVertex" kind="METHOD">
<body>
<first>( begin auto-generated from curveVertex.xml ) Specifies vertex coordinates for curves.</first>
<full>
Specifies vertex coordinates for curves. This function may only be used between `beginShape()` and `endShape()` and only when there is no MODE parameter specified to `beginShape()` . The first and last points in a series of `curveVertex()` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `curveVertex()` will draw the curve between the second, third, and fourth points. The `curveVertex()` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x the x-coordinate of the vertex</blocktag>
<blocktag>@param y the y-coordinate of the vertex</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z the z-coordinate of the vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveVertexSegment" kind="METHOD">
<body>
<first>Handle emitting a specific segment of Catmull-Rom curve.</first>
<full>
Handle emitting a specific segment of Catmull-Rom curve. This can be overridden by subclasses that need more efficient rendering options.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveVertexSegment" kind="METHOD">
<body>
<first>Handle emitting a specific segment of Catmull-Rom curve.</first>
<full>
Handle emitting a specific segment of Catmull-Rom curve. This can be overridden by subclasses that need more efficient rendering options.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="point" kind="METHOD">
<body>
<first>( begin auto-generated from point.xml ) Draws a point, a coordinate in space at the dimension of one pixel.</first>
<full>
Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point, and the optional third value is the depth value. Drawing this shape in 3D with the `z` parameter requires the P3D parameter in combination with `size()` as shown in the above example.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the point</blocktag>
<blocktag>@param y y-coordinate of the point</blocktag>
<blocktag>@see PGraphics#stroke(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="point" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z z-coordinate of the point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="line" kind="METHOD">
<body>
<first>( begin auto-generated from line.xml ) Draws a line (a direct path between two points) to the screen.</first>
<full>
Draws a line (a direct path between two points) to the screen. The version of `line()` with four parameters draws the line in 2D.  To color a line, use the `stroke()` function. A line cannot be filled, therefore the `fill()` function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the `strokeWeight()` function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the `z` parameter requires the P3D parameter in combination with `size()` as shown in the above example.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first point</blocktag>
<blocktag>@param y1 y-coordinate of the first point</blocktag>
<blocktag>@param x2 x-coordinate of the second point</blocktag>
<blocktag>@param y2 y-coordinate of the second point</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
<blocktag>@see PGraphics#beginShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="line" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z1 z-coordinate of the first point</blocktag>
<blocktag>@param z2 z-coordinate of the second point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="triangle" kind="METHOD">
<body>
<first>( begin auto-generated from triangle.xml ) A triangle is a plane created by connecting three points.</first>
<full>
A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first point</blocktag>
<blocktag>@param y1 y-coordinate of the first point</blocktag>
<blocktag>@param x2 x-coordinate of the second point</blocktag>
<blocktag>@param y2 y-coordinate of the second point</blocktag>
<blocktag>@param x3 x-coordinate of the third point</blocktag>
<blocktag>@param y3 y-coordinate of the third point</blocktag>
<blocktag>@see PApplet#beginShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="quad" kind="METHOD">
<body>
<first>( begin auto-generated from quad.xml ) A quad is a quadrilateral, a four sided polygon.</first>
<full>
A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first corner</blocktag>
<blocktag>@param y1 y-coordinate of the first corner</blocktag>
<blocktag>@param x2 x-coordinate of the second corner</blocktag>
<blocktag>@param y2 y-coordinate of the second corner</blocktag>
<blocktag>@param x3 x-coordinate of the third corner</blocktag>
<blocktag>@param y3 y-coordinate of the third corner</blocktag>
<blocktag>@param x4 x-coordinate of the fourth corner</blocktag>
<blocktag>@param y4 y-coordinate of the fourth corner</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rectMode" kind="METHOD">
<body>
<first>( begin auto-generated from rectMode.xml ) Modifies the location from which rectangles draw.</first>
<full>
Modifies the location from which rectangles draw. The default mode is `rectMode(CORNER)` , which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of `rect()` to specify the width and height. The syntax `rectMode(CORNERS)` uses the first and second parameters of `rect()` to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax `rectMode(CENTER)` draws the image from its center point and uses the third and forth parameters of `rect()` to specify the image's width and height. The syntax `rectMode(RADIUS)` draws the image from its center point and uses the third and forth parameters of `rect()` to specify half of the image's width and height. The parameter must be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the mode named CENTER_RADIUS was shortened to RADIUS.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param mode either CORNER, CORNERS, CENTER, or RADIUS</blocktag>
<blocktag>@see PGraphics#rect(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rect" kind="METHOD">
<body>
<first>( begin auto-generated from rect.xml ) Draws a rectangle to the screen.</first>
<full>
Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. These parameters may be changed with the `rectMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the rectangle by default</blocktag>
<blocktag>@param b y-coordinate of the rectangle by default</blocktag>
<blocktag>@param c width of the rectangle by default</blocktag>
<blocktag>@param d height of the rectangle by default</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
<blocktag>@see PGraphics#quad(float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rect" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param r radii for all four corners</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rect" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param tl radius for top-left corner</blocktag>
<blocktag>@param tr radius for top-right corner</blocktag>
<blocktag>@param br radius for bottom-right corner</blocktag>
<blocktag>@param bl radius for bottom-left corner</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="square" kind="METHOD">
<body>
<first>( begin auto-generated from square.xml ) Draws a square to the screen.</first>
<full>
Draws a square to the screen. A square is a four-sided shape with every angle at ninety degrees and each side is the same length. By default, the first two parameters set the location of the upper-left corner, the third sets the width and height. The way these parameters are interpreted, however, may be changed with the `rectMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the rectangle by default</blocktag>
<blocktag>@param y y-coordinate of the rectangle by default</blocktag>
<blocktag>@param extent width and height of the rectangle by default</blocktag>
<blocktag>@see PGraphics#rect(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ellipseMode" kind="METHOD">
<body>
<first>( begin auto-generated from ellipseMode.xml ) The origin of the ellipse is modified by the , `,ellipseMode(),` , function.</first>
<full>
The origin of the ellipse is modified by the `ellipseMode()` function. The default configuration is `ellipseMode(CENTER)` , which specifies the location of the ellipse as the center of the shape. The `RADIUS` mode is the same, but the width and height parameters to `ellipse()` specify the radius of the ellipse, rather than the diameter. The `CORNER` mode draws the shape from the upper-left corner of its bounding box. The `CORNERS` mode uses the four parameters to `ellipse()` to set two opposing corners of the ellipse's bounding box. The parameter must be written in ALL CAPS because Processing is a case-sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param mode either CENTER, RADIUS, CORNER, or CORNERS</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#arc(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ellipse" kind="METHOD">
<body>
<first>( begin auto-generated from ellipse.xml ) Draws an ellipse (oval) in the display window.</first>
<full>
Draws an ellipse (oval) in the display window. An ellipse with an equal `width` and `height` is a circle. The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be changed with the `ellipseMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the ellipse</blocktag>
<blocktag>@param b y-coordinate of the ellipse</blocktag>
<blocktag>@param c width of the ellipse by default</blocktag>
<blocktag>@param d height of the ellipse by default</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
<blocktag>@see PApplet#arc(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="arc" kind="METHOD">
<body>
<first>( begin auto-generated from arc.xml ) Draws an arc in the display window.</first>
<full>
Draws an arc in the display window. Arcs are drawn along the outer edge of an ellipse defined by the `x` , `y` , `width` and `height` parameters. The origin or the arc's ellipse may be changed with the `ellipseMode()` function. The `start` and `stop` parameters specify the angles at which to draw the arc.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the arc's ellipse</blocktag>
<blocktag>@param b y-coordinate of the arc's ellipse</blocktag>
<blocktag>@param c width of the arc's ellipse by default</blocktag>
<blocktag>@param d height of the arc's ellipse by default</blocktag>
<blocktag>@param start angle to start the arc, specified in radians</blocktag>
<blocktag>@param stop angle to stop the arc, specified in radians</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
<blocktag>@see PApplet#degrees(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="arcImpl" kind="METHOD">
<body>
<first>Start and stop are in radians, converted by the parent function.</first>
<full>
Start and stop are in radians, converted by the parent function. Note that the radians can be greater (or less) than TWO_PI. This is so that an arc can be drawn that crosses zero mark, and the user will still collect $200.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="circle" kind="METHOD">
<body>
<first>( begin auto-generated from circle.xml ) Draws a circle to the screen.</first>
<full>
Draws a circle to the screen. By default, the first two parameters set the location of the center, and the third sets the shape's width and height. The origin may be changed with the `ellipseMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the ellipse</blocktag>
<blocktag>@param y y-coordinate of the ellipse</blocktag>
<blocktag>@param extent width and height of the ellipse by default</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="box" kind="METHOD">
<body>
<first>( begin auto-generated from box.xml ) A box is an extruded rectangle.</first>
<full>
A box is an extruded rectangle. A box with equal dimension on all sides is a cube.
</full>
</body>
<blocktags>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@param size dimension of the box in all dimensions (creates a cube)</blocktag>
<blocktag>@see PGraphics#sphere(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="box" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param w dimension of the box in the x-dimension</blocktag>
<blocktag>@param h dimension of the box in the y-dimension</blocktag>
<blocktag>@param d dimension of the box in the z-dimension</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="sphereDetail" kind="METHOD">
<body>
<first>( begin auto-generated from sphereDetail.xml ) Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh.</first>
<full>
Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you're going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `sphereDetail()` is called again with a new parameter and so should&lt;i&gt;not&lt;/i&gt;be called prior to every `sphere()` statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.

Advanced
--------

Code for sphereDetail() submitted by toxi [031031]. Code for enhanced u/v version from davbol [080801].
</full>
</body>
<blocktags>
<blocktag>@param res number of segments (minimum 3) used per full circle revolution</blocktag>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@see PGraphics#sphere(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="sphereDetail" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param ures number of segments used longitudinally per full circle revolutoin</blocktag>
<blocktag>@param vres number of segments used latitudinally from top to bottom</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="sphere" kind="METHOD">
<body>
<first>( begin auto-generated from sphere.xml ) A sphere is a hollow ball made from tessellated triangles.</first>
<full>
A sphere is a hollow ball made from tessellated triangles.

Advanced
--------



Implementation notes:

cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point

sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something

```
[toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@param r the radius of the sphere</blocktag>
<blocktag>@see PGraphics#sphereDetail(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="bezierPoint" kind="METHOD">
<body>
<first>( begin auto-generated from bezierPoint.xml ) Evaluates the Bezier at point t for points a, b, c, d.</first>
<full>
Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.

Advanced
--------

For instance, to convert the following example:

```
stroke(255, 102, 0); line(85, 20, 10, 10); line(90, 90, 15, 80); stroke(0, 0, 0); bezier(85, 20, 10, 10, 90, 90, 15, 80); // draw it in gray, using 10 steps instead of the default 20 // this is a slower way to do it, but useful if you need // to do things with the coordinates at each step stroke(128); beginShape(LINE_STRIP); for (int i = 0; i&lt;= 10; i++) {   float t = i / 10.0f;   float x = bezierPoint(85, 10, 90, 15, t);   float y = bezierPoint(20, 10, 90, 80, t);   vertex(x, y); } endShape();
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="bezierTangent" kind="METHOD">
<body>
<first>( begin auto-generated from bezierTangent.xml ) Calculates the tangent of a point on a Bezier curve.</first>
<full>
Calculates the tangent of a point on a Bezier curve. There is a good definition of&lt;a href="http://en.wikipedia.org/wiki/Tangent"target="new"&gt;&lt;em&gt;tangent&lt;/em&gt;on Wikipedia&lt;/a&gt;.

Advanced
--------

Code submitted by Dave Bollinger (davol) for release 0136.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="bezierDetail" kind="METHOD">
<body>
<first>( begin auto-generated from bezierDetail.xml ) Sets the resolution at which Beziers display.</first>
<full>
Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param detail resolution of the curves</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="bezier" kind="METHOD">
<body>
<first>( begin auto-generated from bezier.xml ) Draws a Bezier curve on the screen.</first>
<full>
Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).

Advanced
--------

Draw a cubic bezier curve. The first and last points are the on-curve points. The middle two are the 'control' points, or 'handles' in an application like Illustrator.

Identical to typing:

```
beginShape(); vertex(x1, y1); bezierVertex(x2, y2, x3, y3, x4, y4); endShape();
```

In Postscript-speak, this would be:

```
moveto(x1, y1); curveto(x2, y2, x3, y3, x4, y4);
```

If you were to try and continue that curve like so:

```
curveto(x5, y5, x6, y6, x7, y7);
```

This would be done in processing by adding these statements:

```
bezierVertex(x5, y5, x6, y6, x7, y7)
```

To draw a quadratic (instead of cubic) curve, use the control point twice by doubling it:

```
bezier(x1, y1, cx, cy, cx, cy, x2, y2);
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param x1 coordinates for the first anchor point</blocktag>
<blocktag>@param y1 coordinates for the first anchor point</blocktag>
<blocktag>@param z1 coordinates for the first anchor point</blocktag>
<blocktag>@param x2 coordinates for the first control point</blocktag>
<blocktag>@param y2 coordinates for the first control point</blocktag>
<blocktag>@param z2 coordinates for the first control point</blocktag>
<blocktag>@param x3 coordinates for the second control point</blocktag>
<blocktag>@param y3 coordinates for the second control point</blocktag>
<blocktag>@param z3 coordinates for the second control point</blocktag>
<blocktag>@param x4 coordinates for the second anchor point</blocktag>
<blocktag>@param y4 coordinates for the second anchor point</blocktag>
<blocktag>@param z4 coordinates for the second anchor point</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curvePoint" kind="METHOD">
<body>
<first>( begin auto-generated from curvePoint.xml ) Evalutes the curve at point t for points a, b, c, d.</first>
<full>
Evalutes the curve at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are the control points, and b and c are the points on the curve. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a curve at t.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first control point</blocktag>
<blocktag>@param b coordinate of first point on the curve</blocktag>
<blocktag>@param c coordinate of second point on the curve</blocktag>
<blocktag>@param d coordinate of second control point</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#bezierPoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveTangent" kind="METHOD">
<body>
<first>( begin auto-generated from curveTangent.xml ) Calculates the tangent of a point on a curve.</first>
<full>
Calculates the tangent of a point on a curve. There's a good definition of&lt;em&gt;&lt;a href="http://en.wikipedia.org/wiki/Tangent"target="new"&gt;tangent&lt;/em&gt;on Wikipedia&lt;/a&gt;.

Advanced
--------

Code thanks to Dave Bollinger (Bug #715)
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierTangent(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveDetail" kind="METHOD">
<body>
<first>( begin auto-generated from curveDetail.xml ) Sets the resolution at which curves display.</first>
<full>
Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param detail resolution of the curves</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveTightness" kind="METHOD">
<body>
<first>( begin auto-generated from curveTightness.xml ) Modifies the quality of forms created with , `,curve(),` , and , `,curveVertex(),` ,.</first>
<full>
Modifies the quality of forms created with `curve()` and `curveVertex()` . The parameter `squishy` determines how the curve fits to the vertex points. The value 0.0 is the default value for `squishy` (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param tightness amount of deformation from the original vertices</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curveInit" kind="METHOD">
<body>
<first>Set the number of segments to use when drawing a Catmull-Rom curve, and setting the s parameter, which defines how tightly the curve fits to each vertex.</first>
<full>
Set the number of segments to use when drawing a Catmull-Rom curve, and setting the s parameter, which defines how tightly the curve fits to each vertex. Catmull-Rom curves are actually a subset of this curve type where the s is set to zero.

(This function is not optimized, since it's not expected to be called all that often. there are many juicy and obvious opimizations in here, but it's probably better to keep the code more readable)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curve" kind="METHOD">
<body>
<first>( begin auto-generated from curve.xml ) Draws a curved line on the screen.</first>
<full>
Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `curve()` functions together or using `curveVertex()` . An additional function called `curveTightness()` provides control for the visual quality of the curve. The `curve()` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).

Advanced
--------

As of revision 0070, this function no longer doubles the first and last points. The curves are a bit more boring, but it's more mathematically correct, and properly mirrored in curvePoint().

Identical to typing out:

```
beginShape(); curveVertex(x1, y1); curveVertex(x2, y2); curveVertex(x3, y3); curveVertex(x4, y4); endShape();
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param x1 coordinates for the beginning control point</blocktag>
<blocktag>@param y1 coordinates for the beginning control point</blocktag>
<blocktag>@param x2 coordinates for the first point</blocktag>
<blocktag>@param y2 coordinates for the first point</blocktag>
<blocktag>@param x3 coordinates for the second point</blocktag>
<blocktag>@param y3 coordinates for the second point</blocktag>
<blocktag>@param x4 coordinates for the ending control point</blocktag>
<blocktag>@param y4 coordinates for the ending control point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="curve" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z1 coordinates for the beginning control point</blocktag>
<blocktag>@param z2 coordinates for the first point</blocktag>
<blocktag>@param z3 coordinates for the second point</blocktag>
<blocktag>@param z4 coordinates for the ending control point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="splineForward" kind="METHOD">
<body>
<first>Setup forward-differencing matrix to be used for speedy curve rendering.</first>
<full>
Setup forward-differencing matrix to be used for speedy curve rendering. It's based on using a specific number of curve segments and just doing incremental adds for each vertex of the segment, rather than running the mathematically expensive cubic equation.
</full>
</body>
<blocktags>
<blocktag>@param segments number of curve segments to use when drawing</blocktag>
<blocktag>@param matrix target object for the new matrix</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="imageMode" kind="METHOD">
<body>
<first>( begin auto-generated from imageMode.xml ) Modifies the location from which images draw.</first>
<full>
Modifies the location from which images draw. The default mode is `imageMode(CORNER)` , which specifies the location to be the upper left corner and uses the fourth and fifth parameters of `image()` to set the image's width and height. The syntax `imageMode(CORNERS)` uses the second and third parameters of `image()` to set the location of one corner of the image and uses the fourth and fifth parameters to set the opposite corner. Use `imageMode(CENTER)` to draw images centered at the given x and y position.

The parameter to `imageMode()` must be written in ALL CAPS because Processing is a case-sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param mode either CORNER, CORNERS, or CENTER</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="image" kind="METHOD">
<body>
<first>( begin auto-generated from image.xml ) Displays images to the screen.</first>
<full>
Displays images to the screen. The images must be in the sketch's "data" directory to load correctly. Select "Add file..." from the "Sketch" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The `img` parameter specifies the image to display and the `x` and `y` parameters define the location of the image from its upper-left corner. The image is displayed at its original size unless the `width` and `height` parameters specify a different size.

The `imageMode()` function changes the way the parameters work. For example, a call to `imageMode(CORNERS)` will change the `width` and `height` parameters to define the x and y values of the opposite corner of the image.

The color of an image may be modified with the `tint()` function. This function will maintain transparency for GIF and PNG images.

Advanced
--------

Starting with release 0124, when using the default (JAVA2D) renderer, smooth() will also improve image quality of resized images.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param img the image to display</blocktag>
<blocktag>@param a x-coordinate of the image by default</blocktag>
<blocktag>@param b y-coordinate of the image by default</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics#imageMode(int)</blocktag>
<blocktag>@see PGraphics#tint(float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="image" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c width to display the image by default</blocktag>
<blocktag>@param d height to display the image by default</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="image" kind="METHOD">
<body>
<first>Draw an image(), also specifying u/v coordinates.</first>
<full>
Draw an image(), also specifying u/v coordinates. In this method, the  u, v coordinates are always based on image space location, regardless of the current textureMode().
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="imageImpl" kind="METHOD">
<body>
<first>Expects x1, y1, x2, y2 coordinates where (x2 ,&gt;,= x1) and (y2 ,&gt;,= y1).</first>
<full>
Expects x1, y1, x2, y2 coordinates where (x2&gt;= x1) and (y2&gt;= y1). If tint() has been called, the image will be colored.

The default implementation draws an image as a textured quad. The (u, v) coordinates are in image space (they're ints, after all..)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shapeMode" kind="METHOD">
<body>
<first>( begin auto-generated from shapeMode.xml ) Modifies the location from which shapes draw.</first>
<full>
Modifies the location from which shapes draw. The default mode is `shapeMode(CORNER)` , which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of `shape()` to specify the width and height. The syntax `shapeMode(CORNERS)` uses the first and second parameters of `shape()` to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax `shapeMode(CENTER)` draws the shape from its center point and uses the third and forth parameters of `shape()` to specify the width and height. The parameter must be written in "ALL CAPS" because Processing is a case sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref shape:loading_displaying</blocktag>
<blocktag>@param mode either CORNER, CORNERS, CENTER</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#shape(PShape)</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shape" kind="METHOD">
<body>
<first>( begin auto-generated from shape.xml ) Displays shapes to the screen.</first>
<full>
Displays shapes to the screen. The shapes must be in the sketch's "data" directory to load correctly. Select "Add file..." from the "Sketch" menu to add the shape. Processing currently works with SVG shapes only. The `sh` parameter specifies the shape to display and the `x` and `y` parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the `width` and `height` parameters specify a different size. The `shapeMode()` function changes the way the parameters work. A call to `shapeMode(CORNERS)` , for example, will change the width and height parameters to define the x and y values of the opposite corner of the shape.

Note complex shapes may draw awkwardly with P3D. This renderer does not yet support shapes that have holes or complicated breaks.
</full>
</body>
<blocktags>
<blocktag>@webref shape:loading_displaying</blocktag>
<blocktag>@param shape the shape to display</blocktag>
<blocktag>@param x x-coordinate of the shape</blocktag>
<blocktag>@param y y-coordinate of the shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PApplet#loadShape(String)</blocktag>
<blocktag>@see PGraphics#shapeMode(int) Convenience method to draw at a particular location.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param a x-coordinate of the shape</blocktag>
<blocktag>@param b y-coordinate of the shape</blocktag>
<blocktag>@param c width to display the shape</blocktag>
<blocktag>@param d height to display the shape</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="createDefaultFont" kind="METHOD">
<body>
<first>Used by PGraphics to remove the requirement for loading a font.</first>
<full>
Used by PGraphics to remove the requirement for loading a font.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textAlign" kind="METHOD">
<body>
<first>( begin auto-generated from textAlign.xml ) Sets the current alignment for drawing text.</first>
<full>
Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the `x` and `y` parameters of the `text()` function.

In Processing 0125 and later, an optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current `textDescent()` . For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.

When using `text()` with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)

The vertical alignment is based on the value of `textAscent()` , which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of `textAscent()` or `textDescent()` so that the hack works even if you change the size of the font.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param alignX horizontal alignment, either LEFT, CENTER, or RIGHT</blocktag>
<blocktag>@param alignY vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textAscent" kind="METHOD">
<body>
<first>( begin auto-generated from textAscent.xml ) Returns ascent of the current font at its current size.</first>
<full>
Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `textAscent()` and `textDescent()` values will give you the total height of the line.
</full>
</body>
<blocktags>
<blocktag>@webref typography:metrics</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textDescent" kind="METHOD">
<body>
<first>( begin auto-generated from textDescent.xml ) Returns descent of the current font at its current size.</first>
<full>
Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the `textAscent()` and `textDescent()` values will give you the total height of the line.
</full>
</body>
<blocktags>
<blocktag>@webref typography:metrics</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textFont" kind="METHOD">
<body>
<first>( begin auto-generated from textFont.xml ) Sets the current font that will be drawn with the , `,text(),` , function.</first>
<full>
Sets the current font that will be drawn with the `text()` function. Fonts must be loaded with `loadFont()` before it can be used. This font will be used in all subsequent calls to the `text()` function. If no `size` parameter is input, the font will appear at its original size (the size it was created at with the "Create Font..." tool) until it is changed with `textSize()` .

Because fonts are usually bitmaped, you should create fonts at the sizes that will be used most commonly. Using `textFont()` without the size parameter will result in the cleanest-looking text.

With the default (JAVA2D) and PDF renderers, it's also possible to enable the use of native fonts via the command `hint(ENABLE_NATIVE_FONTS)` . This will produce vector text in JAVA2D sketches and PDF output in cases where the vector data is available: when the font is still installed, or the font is created via the `createFont()` function (rather than the Create Font tool).
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param which any variable of the type PFont</blocktag>
<blocktag>@see PApplet#createFont(String, float, boolean)</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textFont" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param size the size of the letters in units of pixels</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textFontImpl" kind="METHOD">
<body>
<first>Called from textFont.</first>
<full>
Called from textFont. Check the validity of args and print possible errors to the user before calling this. Subclasses will want to override this one.
</full>
</body>
<blocktags>
<blocktag>@param which font to set, not null</blocktag>
<blocktag>@param size size to set, greater than zero</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textLeading" kind="METHOD">
<body>
<first>( begin auto-generated from textLeading.xml ) Sets the spacing between lines of text in units of pixels.</first>
<full>
Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the `text()` function.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param leading the size in pixels for spacing between lines</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textMode" kind="METHOD">
<body>
<first>( begin auto-generated from textMode.xml ) Sets the way text draws to the screen.</first>
<full>
Sets the way text draws to the screen. In the default configuration, the `MODEL` mode, it's possible to rotate, scale, and place letters in two and three dimensional space.

The `SHAPE` mode draws text using the the glyph outlines of individual characters rather than as textures. This mode is only supported with the `PDF` and `P3D` renderer settings. With the `PDF` renderer, you must call `textMode(SHAPE)` before any other drawing occurs. If the outlines are not available, then `textMode(SHAPE)` will be ignored and `textMode(MODEL)` will be used instead.

The `textMode(SHAPE)` option in `P3D` can be combined with `beginRaw()` to write vector-accurate text to 2D and 3D output files, for instance `DXF` or `PDF` . The `SHAPE` mode is not currently optimized for `P3D` , so if recording shape data, use `textMode(MODEL)` until you're ready to capture the geometry with `beginRaw()` .
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param mode either MODEL or SHAPE</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#beginRaw(PGraphics)</blocktag>
<blocktag>@see PApplet#createFont(String, float, boolean)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textSize" kind="METHOD">
<body>
<first>( begin auto-generated from textSize.xml ) Sets the current font size.</first>
<full>
Sets the current font size. This size will be used in all subsequent calls to the `text()` function. Font size is measured in units of pixels.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param size the size of the letters in units of pixels</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textSizeImpl" kind="METHOD">
<body>
<first>Called from textSize() after validating size.</first>
<full>
Called from textSize() after validating size. Subclasses will want to override this one.
</full>
</body>
<blocktags>
<blocktag>@param size size of the text, greater than zero</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="handleTextSize" kind="METHOD">
<body>
<first>Sets the actual size.</first>
<full>
Sets the actual size. Called from textSizeImpl and from textFontImpl after setting the font.
</full>
</body>
<blocktags>
<blocktag>@param size size of the text, greater than zero</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textWidth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c the character to measure</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textWidth" kind="METHOD">
<body>
<first>( begin auto-generated from textWidth.xml ) Calculates and returns the width of any character or text string.</first>
<full>
Calculates and returns the width of any character or text string.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param str the String of characters to measure</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textWidth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textWidthImpl" kind="METHOD">
<body>
<first>Implementation of returning the text width of the chars [start, stop) in the buffer.</first>
<full>
Implementation of returning the text width of the chars [start, stop) in the buffer. Unlike the previous version that was inside PFont, this will return the size not of a 1 pixel font, but the actual current size.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>( begin auto-generated from text.xml ) Draws text to the screen.</first>
<full>
Draws text to the screen. Displays the information specified in the `data` or `stringdata` parameters on the screen in the position specified by the `x` and `y` parameters and the optional `z` parameter. A default font will be used unless a font is set with the `textFont()` function. Change the color of the text with the `fill()` function. The text displays in relation to the `textAlign()` function, which gives the option to draw to the left, right, and center of the coordinates.

The `x2` and `y2` parameters define a rectangular area to display within and may only be used with string data. For text drawn inside a rectangle, the coordinates are interpreted based on the current `rectMode()` setting.
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param c the alphanumeric character to be displayed</blocktag>
<blocktag>@param x x-coordinate of text</blocktag>
<blocktag>@param y y-coordinate of text</blocktag>
<blocktag>@see PGraphics#textAlign(int, int)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textMode(int)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
<blocktag>@see PGraphics#textLeading(float)</blocktag>
<blocktag>@see PGraphics#textWidth(String)</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
<blocktag>@see PGraphics#fill(int, float)</blocktag>
<blocktag>@see_external String</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z z-coordinate of text</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Draw a chunk of text. Newlines that are \n (Unix newline or linefeed char, ascii 10) are honored, but \r (carriage return, Windows and Mac OS) are ignored.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Method to draw text from an array of chars. This method will usually be more efficient than drawing from a String object, because the String will not be converted to a char array before drawing.
</full>
</body>
<blocktags>
<blocktag>@param chars the alphanumberic symbols to be displayed</blocktag>
<blocktag>@param start array index at which to start writing characters</blocktag>
<blocktag>@param stop array index at which to stop writing characters</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>Same as above but with a z coordinate.</first>
<full>
Same as above but with a z coordinate.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Draw text in a box that is constrained to a particular size. The current rectMode() determines what the coordinates mean (whether x1/y1/x2/y2 or x/y/w/h).&lt;P/&gt;Note that the x,y coords of the start of the box will align with the *ascent* of the text, not the baseline, as is the case for the other text() functions.&lt;P/&gt;Newlines that are \n (Unix newline or linefeed char, ascii 10) are honored, and \r (carriage return, Windows and Mac OS) are ignored.
</full>
</body>
<blocktags>
<blocktag>@param x1 by default, the x-coordinate of text, see rectMode() for more info</blocktag>
<blocktag>@param y1 by default, the y-coordinate of text, see rectMode() for more info</blocktag>
<blocktag>@param x2 by default, the width of the text box, see rectMode() for more info</blocktag>
<blocktag>@param y2 by default, the height of the text box, see rectMode() for more info</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textSentence" kind="METHOD">
<body>
<first>Emit a sentence of text, defined as a chunk of text without any newlines.</first>
<full>
Emit a sentence of text, defined as a chunk of text without any newlines.
</full>
</body>
<blocktags>
<blocktag>@param stop non-inclusive, the end of the text in question</blocktag>
<blocktag>@return false if cannot fit</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="text" kind="METHOD">
<body>
<first>This does a basic number formatting, to avoid the generally ugly appearance of printing floats.</first>
<full>
This does a basic number formatting, to avoid the generally ugly appearance of printing floats. Users who want more control should use their own nf() cmmand, or if they want the long, ugly version of float, use String.valueOf() to convert the float to a String first.
</full>
</body>
<blocktags>
<blocktag>@param num the numeric value to be displayed</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textLineAlignImpl" kind="METHOD">
<body>
<first>Handles placement of a text line, then calls textLineImpl to actually render at the specific point.</first>
<full>
Handles placement of a text line, then calls textLineImpl to actually render at the specific point.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="textLineImpl" kind="METHOD">
<body>
<first>Implementation of actual drawing for a line of text.</first>
<full>
Implementation of actual drawing for a line of text.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="push" kind="METHOD">
<body>
<first>( begin auto-generated from push.xml ) The , `,push(),` , function saves the current drawing style settings and transformations, while , `,pop(),` , restores these settings.</first>
<full>
The `push()` function saves the current drawing style settings and transformations, while `pop()` restores these settings. Note that these functions are always used together. They allow you to change the style and transformation settings and later return to what you had. When a new state is started with push(), it builds on the current style and transform information.

 `push()` stores information related to the current transformation state and style settings controlled by the following functions: `rotate()` , `translate()` , `scale()` , `fill()` , `stroke()` , `tint()` , `strokeWeight()` , `strokeCap()` , `strokeJoin()` , `imageMode()` , `rectMode()` , `ellipseMode()` , `colorMode()` , `textAlign()` , `textFont()` , `textMode()` , `textSize()` , `textLeading()` .

The `push()` and `pop()` functions were added with Processing 3.5. They can be used in place of `pushMatrix()` , `popMatrix()` , `pushStyles()` , and `popStyles()` . The difference is that push() and pop() control both the transformations (rotate, scale, translate) and the drawing styles at the same time.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#pop()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="pop" kind="METHOD">
<body>
<first>( begin auto-generated from pop.xml ) The , `,pop(),` , function restores the previous drawing style settings and transformations after , `,push(),` , has changed them.</first>
<full>
The `pop()` function restores the previous drawing style settings and transformations after `push()` has changed them. Note that these functions are always used together. They allow you to change the style and transformation settings and later return to what you had. When a new state is started with push(), it builds on the current style and transform information.


 `push()` stores information related to the current transformation state and style settings controlled by the following functions: `rotate()` , `translate()` , `scale()` , `fill()` , `stroke()` , `tint()` , `strokeWeight()` , `strokeCap()` , `strokeJoin()` , `imageMode()` , `rectMode()` , `ellipseMode()` , `colorMode()` , `textAlign()` , `textFont()` , `textMode()` , `textSize()` , `textLeading()` .

The `push()` and `pop()` functions were added with Processing 3.5. They can be used in place of `pushMatrix()` , `popMatrix()` , `pushStyles()` , and `popStyles()` . The difference is that push() and pop() control both the transformations (rotate, scale, translate) and the drawing styles at the same time.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#push()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="pushMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from pushMatrix.xml ) Pushes the current transformation matrix onto the matrix stack.</first>
<full>
Pushes the current transformation matrix onto the matrix stack. Understanding `pushMatrix()` and `popMatrix()` requires understanding the concept of a matrix stack. The `pushMatrix()` function saves the current coordinate system to the stack and `popMatrix()` restores the prior coordinate system. `pushMatrix()` and `popMatrix()` are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#scale(float)</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="popMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from popMatrix.xml ) Pops the current transformation matrix off the matrix stack.</first>
<full>
Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The `pushMatrix()` function saves the current coordinate system to the stack and `popMatrix()` restores the prior coordinate system. `pushMatrix()` and `popMatrix()` are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="translate" kind="METHOD">
<body>
<first>( begin auto-generated from translate.xml ) Specifies an amount to displace objects within the display window.</first>
<full>
Specifies an amount to displace objects within the display window. The `x` parameter specifies left/right translation, the `y` parameter specifies up/down translation, and the `z` parameter specifies translations toward/away from the screen. Using this function with the `z` parameter requires using P3D as a parameter in combination with size as shown in the above example. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `translate(50, 0)` and then `translate(20, 0)` is the same as `translate(70, 0)` . If `translate()` is called within `draw()` , the transformation is reset when the loop begins again. This function can be further controlled by the `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param x left/right translation</blocktag>
<blocktag>@param y up/down translation</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="translate" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z forward/backward translation</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rotate" kind="METHOD">
<body>
<first>( begin auto-generated from rotate.xml ) Rotates a shape the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` function.

Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotate(HALF_PI)` and then `rotate(HALF_PI)` is the same as `rotate(PI)` . All tranformations are reset when `draw()` begins again.

Technically, `rotate()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rotateX" kind="METHOD">
<body>
<first>( begin auto-generated from rotateX.xml ) Rotates a shape around the x-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the x-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateX(PI/2)` and then `rotateX(PI/2)` is the same as `rotateX(PI)` . If `rotateX()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the example above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rotateY" kind="METHOD">
<body>
<first>( begin auto-generated from rotateY.xml ) Rotates a shape around the y-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the y-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateY(PI/2)` and then `rotateY(PI/2)` is the same as `rotateY(PI)` . If `rotateY()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the examples above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rotateZ" kind="METHOD">
<body>
<first>( begin auto-generated from rotateZ.xml ) Rotates a shape around the z-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the z-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateZ(PI/2)` and then `rotateZ(PI/2)` is the same as `rotateZ(PI)` . If `rotateZ()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the examples above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="rotate" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Rotate about a vector in space. Same as the glRotatef() function.
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param x</blocktag>
<blocktag>@param y</blocktag>
<blocktag>@param z</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="scale" kind="METHOD">
<body>
<first>( begin auto-generated from scale.xml ) Increases or decreases the size of a shape by expanding and contracting vertices.</first>
<full>
Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `scale(2.0)` increases the dimension of a shape by 200%. Transformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `scale(2.0)` and then `scale(1.5)` is the same as `scale(3.0)` . If `scale()` is called within `draw()` , the transformation is reset when the loop begins again. Using this fuction with the `z` parameter requires using P3D as a parameter for `size()` as shown in the example above. This function can be further controlled by `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param s percentage to scale the object</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="scale" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Scale in X and Y. Equivalent to scale(sx, sy, 1). Not recommended for use in 3D, because the z-dimension is just scaled by 1, since there's no way to know what else to scale it by.
</full>
</body>
<blocktags>
<blocktag>@param x percentage to scale the object in the x-axis</blocktag>
<blocktag>@param y percentage to scale the object in the y-axis</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="scale" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z percentage to scale the object in the z-axis</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shearX" kind="METHOD">
<body>
<first>( begin auto-generated from shearX.xml ) Shears a shape around the x-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Shears a shape around the x-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `shearX(PI/2)` and then `shearX(PI/2)` is the same as `shearX(PI)` . If `shearX()` is called within the `draw()` , the transformation is reset when the loop begins again.

Technically, `shearX()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of shear specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#shearY(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shearY" kind="METHOD">
<body>
<first>( begin auto-generated from shearY.xml ) Shears a shape around the y-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Shears a shape around the y-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `shearY(PI/2)` and then `shearY(PI/2)` is the same as `shearY(PI)` . If `shearY()` is called within the `draw()` , the transformation is reset when the loop begins again.

Technically, `shearY()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of shear specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#shearX(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="resetMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from resetMatrix.xml ) Replaces the current matrix with the identity matrix.</first>
<full>
Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
<blocktag>@see PGraphics#printMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="applyMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from applyMatrix.xml ) Multiplies the current matrix by the one specified through the parameters.</first>
<full>
Multiplies the current matrix by the one specified through the parameters. This is very slow because it will try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function in OpenGL is glMultMatrix().
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@source</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#printMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="applyMatrix" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param n00 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n01 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n02 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n10 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n11 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n12 numbers which define the 4x4 matrix to be multiplied</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="applyMatrix" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param n03 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n13 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n20 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n21 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n22 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n23 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n30 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n31 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n32 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n33 numbers which define the 4x4 matrix to be multiplied</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="getMatrix" kind="METHOD">
<body>
<first>Copy the current transformation matrix into the specified target.</first>
<full>
Copy the current transformation matrix into the specified target. Pass in null to create a new matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="getMatrix" kind="METHOD">
<body>
<first>Copy the current transformation matrix into the specified target.</first>
<full>
Copy the current transformation matrix into the specified target. Pass in null to create a new matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation matrix to the contents of another.</first>
<full>
Set the current transformation matrix to the contents of another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation to the contents of the specified source.</first>
<full>
Set the current transformation to the contents of the specified source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation to the contents of the specified source.</first>
<full>
Set the current transformation to the contents of the specified source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="printMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from printMatrix.xml ) Prints the current matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginCamera" kind="METHOD">
<body>
<first>( begin auto-generated from beginCamera.xml ) The , `,beginCamera(),` , and , `,endCamera(),` , functions enable advanced customization of the camera space.</first>
<full>
The `beginCamera()` and `endCamera()` functions enable advanced customization of the camera space. The functions are useful if you want to more control over camera movement, however for most users, the `camera()` function will be sufficient.

The camera functions will replace any transformations (such as `rotate()` or `translate()` ) that occur before them in `draw()` , but they will not automatically replace the camera transform itself. For this reason, camera functions should be placed at the beginning of `draw()` (so that transformations happen afterwards), and the `camera()` function can be used after `beginCamera()` if you want to reset the camera before applying transformations.

This function sets the matrix mode to the camera matrix so calls such as `translate()` , `rotate()` , applyMatrix() and resetMatrix() affect the camera. `beginCamera()` should always be used with a following `endCamera()` and pairs of `beginCamera()` and `endCamera()` cannot be nested.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="endCamera" kind="METHOD">
<body>
<first>( begin auto-generated from endCamera.xml ) The , `,beginCamera(),` , and , `,endCamera(),` , functions enable advanced customization of the camera space.</first>
<full>
The `beginCamera()` and `endCamera()` functions enable advanced customization of the camera space. Please see the reference for `beginCamera()` for a description of how the functions are used.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="camera" kind="METHOD">
<body>
<first>( begin auto-generated from camera.xml ) Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing upward.</first>
<full>
Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be seen from different angles. The version without any parameters sets the camera to the default position, pointing to the center of the display window with the Y axis as up. The default values are `camera(width/2.0, height/2.0, (height/2.0) / tan(PI*30.0 / 180.0), width/2.0, height/2.0, 0, 0, 1, 0)` . This function is similar to `gluLookAt()` in OpenGL, but it first clears the current camera settings.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#frustum(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="camera" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param eyeX x-coordinate for the eye</blocktag>
<blocktag>@param eyeY y-coordinate for the eye</blocktag>
<blocktag>@param eyeZ z-coordinate for the eye</blocktag>
<blocktag>@param centerX x-coordinate for the center of the scene</blocktag>
<blocktag>@param centerY y-coordinate for the center of the scene</blocktag>
<blocktag>@param centerZ z-coordinate for the center of the scene</blocktag>
<blocktag>@param upX usually 0.0, 1.0, or -1.0</blocktag>
<blocktag>@param upY usually 0.0, 1.0, or -1.0</blocktag>
<blocktag>@param upZ usually 0.0, 1.0, or -1.0</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="printCamera" kind="METHOD">
<body>
<first>( begin auto-generated from printCamera.xml ) Prints the current camera matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current camera matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ortho" kind="METHOD">
<body>
<first>( begin auto-generated from ortho.xml ) Sets an orthographic projection and defines a parallel clipping volume.</first>
<full>
Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear the same size, regardless of whether they are near or far from the camera. The parameters to this function specify the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default is used: ortho(0, width, 0, height, -10, 10).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ortho" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param left left plane of the clipping volume</blocktag>
<blocktag>@param right right plane of the clipping volume</blocktag>
<blocktag>@param bottom bottom plane of the clipping volume</blocktag>
<blocktag>@param top top plane of the clipping volume</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ortho" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param near maximum distance from the origin to the viewer</blocktag>
<blocktag>@param far maximum distance from the origin away from the viewer</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="perspective" kind="METHOD">
<body>
<first>( begin auto-generated from perspective.xml ) Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones.</first>
<full>
Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more accurately than orthographic projection. The version of perspective without parameters sets the default perspective and the version with four parameters allows the programmer to set the area precisely. The default values are: perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="perspective" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param fovy field-of-view angle (in radians) for vertical direction</blocktag>
<blocktag>@param aspect ratio of width to height</blocktag>
<blocktag>@param zNear z-position of nearest clipping plane</blocktag>
<blocktag>@param zFar z-position of farthest clipping plane</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="frustum" kind="METHOD">
<body>
<first>( begin auto-generated from frustum.xml ) Sets a perspective matrix defined through the parameters.</first>
<full>
Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current perspective matrix rather than muliplying itself with it.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@param left left coordinate of the clipping plane</blocktag>
<blocktag>@param right right coordinate of the clipping plane</blocktag>
<blocktag>@param bottom bottom coordinate of the clipping plane</blocktag>
<blocktag>@param top top coordinate of the clipping plane</blocktag>
<blocktag>@param near near component of the clipping plane; must be greater than zero</blocktag>
<blocktag>@param far far component of the clipping plane; must be greater than the near value</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#perspective(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="printProjection" kind="METHOD">
<body>
<first>( begin auto-generated from printProjection.xml ) Prints the current projection matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current projection matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="screenX" kind="METHOD">
<body>
<first>( begin auto-generated from screenX.xml ) Takes a three-dimensional X, Y, Z position and returns the X value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the X value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenY(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="screenY" kind="METHOD">
<body>
<first>( begin auto-generated from screenY.xml ) Takes a three-dimensional X, Y, Z position and returns the Y value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the Y value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenX(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="screenX" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="screenY" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="screenZ" kind="METHOD">
<body>
<first>( begin auto-generated from screenZ.xml ) Takes a three-dimensional X, Y, Z position and returns the Z value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the Z value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenX(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenY(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="modelX" kind="METHOD">
<body>
<first>( begin auto-generated from modelX.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the X value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The X value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelY(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="modelY" kind="METHOD">
<body>
<first>( begin auto-generated from modelY.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the Y value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Y value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelX(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="modelZ" kind="METHOD">
<body>
<first>( begin auto-generated from modelZ.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the Z value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Z value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelX(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelY(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="pushStyle" kind="METHOD">
<body>
<first>( begin auto-generated from pushStyle.xml ) The , `,pushStyle(),` , function saves the current style settings and , `,popStyle(),` , restores the prior settings.</first>
<full>
The `pushStyle()` function saves the current style settings and `popStyle()` restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `pushStyle()` , it builds on the current style information. The `pushStyle()` and `popStyle()` functions can be embedded to provide more control (see the second example above for a demonstration.)

The style information controlled by the following functions are included in the style: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#popStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="popStyle" kind="METHOD">
<body>
<first>( begin auto-generated from popStyle.xml ) The , `,pushStyle(),` , function saves the current style settings and , `,popStyle(),` , restores the prior settings; these functions are always used together.</first>
<full>
The `pushStyle()` function saves the current style settings and `popStyle()` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `pushStyle()` , it builds on the current style information. The `pushStyle()` and `popStyle()` functions can be embedded to provide more control (see the second example above for a demonstration.)
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#pushStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeWeight" kind="METHOD">
<body>
<first>( begin auto-generated from strokeWeight.xml ) Sets the width of the stroke used for lines, points, and the border around shapes.</first>
<full>
Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.

When drawing with P3D, series of connected lines (such as the stroke around a polygon, triangle, or ellipse) produce unattractive results when a thick stroke weight is set (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). With P3D, the minimum and maximum values for `strokeWeight()` are controlled by the graphics card and the operating system's OpenGL implementation. For instance, the thickness may not go higher than 10 pixels.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param weight the weight (in pixels) of the stroke</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeJoin" kind="METHOD">
<body>
<first>( begin auto-generated from strokeJoin.xml ) Sets the style of the joints which connect line segments.</first>
<full>
Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.

This function is not available with the P3D renderer, (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). More information about the renderers can be found in the `size()` reference.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param join either MITER, BEVEL, ROUND</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="strokeCap" kind="METHOD">
<body>
<first>( begin auto-generated from strokeCap.xml ) Sets the style for rendering line endings.</first>
<full>
Sets the style for rendering line endings. These ends are either squared, extended, or rounded and specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.

This function is not available with the P3D renderer (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). More information about the renderers can be found in the `size()` reference.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param cap either SQUARE, PROJECT, or ROUND</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PApplet#size(int, int, String, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noStroke" kind="METHOD">
<body>
<first>( begin auto-generated from noStroke.xml ) Disables drawing the stroke (outline).</first>
<full>
Disables drawing the stroke (outline). If both `noStroke()` and `noFill()` are called, nothing will be drawn to the screen.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#fill(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="stroke" kind="METHOD">
<body>
<first>( begin auto-generated from stroke.xml ) Sets the color used to draw lines and borders around shapes.</first>
<full>
Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current `colorMode()` (the default color space is RGB, with each value in the range from 0 to 255).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.
</full>
</body>
<blocktags>
<blocktag>@param rgb color value in hexadecimal notation</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
<blocktag>@see PGraphics#fill(int, float)</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
<blocktag>@see PGraphics#tint(int, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#colorMode(int, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the stroke</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@webref color:setting</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noTint" kind="METHOD">
<body>
<first>( begin auto-generated from noTint.xml ) Removes the current fill value for displaying images and reverts to displaying images with their original hues.</first>
<full>
Removes the current fill value for displaying images and reverts to displaying images with their original hues.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#tint(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tint" kind="METHOD">
<body>
<first>( begin auto-generated from tint.xml ) Sets the fill value for displaying images.</first>
<full>
Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by setting the alpha.

To make an image transparent, but not change it's color, use white as the tint color and specify an alpha value. For instance, tint(255, 128) will make an image 50% transparent (unless `colorMode()` has been used).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.

The `tint()` function is also used to control the coloring of textures in 3D.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color value in hexadecimal notation</blocktag>
<blocktag>@see PGraphics#noTint()</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the image</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noFill" kind="METHOD">
<body>
<first>( begin auto-generated from noFill.xml ) Disables filling geometry.</first>
<full>
Disables filling geometry. If both `noStroke()` and `noFill()` are called, nothing will be drawn to the screen.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#fill(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fill" kind="METHOD">
<body>
<first>( begin auto-generated from fill.xml ) Sets the color used to fill shapes.</first>
<full>
Sets the color used to fill shapes. For example, if you run `fill(204, 102, 0)` , all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current `colorMode()` (the default color space is RGB, with each value in the range from 0 to 255).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.

To change the color of an image (or a texture), use tint().
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color variable or hex value</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
<blocktag>@see PGraphics#tint(int, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#colorMode(int, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the fill</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray number specifying value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ambient" kind="METHOD">
<body>
<first>( begin auto-generated from ambient.xml ) Sets the ambient reflectance for shapes drawn to the screen.</first>
<full>
Sets the ambient reflectance for shapes drawn to the screen. This is combined with the ambient light component of environment. The color components set through the parameters define the reflectance. For example in the default color mode, setting v1=255, v2=126, v3=0, would cause all the red light to reflect and half of the green light to reflect. Used in combination with `emissive()` , `specular()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ambient" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray number specifying value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ambient" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="specular" kind="METHOD">
<body>
<first>( begin auto-generated from specular.xml ) Sets the specular color of the materials used for shapes drawn to the screen, which sets the color of hightlights.</first>
<full>
Sets the specular color of the materials used for shapes drawn to the screen, which sets the color of hightlights. Specular refers to light which bounces off a surface in a perferred direction (rather than bouncing in all directions like a diffuse light). Used in combination with `emissive()` , `ambient()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color to set</blocktag>
<blocktag>@see PGraphics#lightSpecular(float, float, float)</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="specular" kind="METHOD">
<body>
<first>gray number specifying value between white and black</first>
<full>
gray number specifying value between white and black
</full>
</body>
<blocktags>
<blocktag>@param gray value between black and white, by default 0 to 255</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="specular" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="shininess" kind="METHOD">
<body>
<first>( begin auto-generated from shininess.xml ) Sets the amount of gloss in the surface of shapes.</first>
<full>
Sets the amount of gloss in the surface of shapes. Used in combination with `ambient()` , `specular()` , and `emissive()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param shine degree of shininess</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="emissive" kind="METHOD">
<body>
<first>( begin auto-generated from emissive.xml ) Sets the emissive color of the material used for drawing shapes drawn to the screen.</first>
<full>
Sets the emissive color of the material used for drawing shapes drawn to the screen. Used in combination with `ambient()` , `specular()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color to set</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="emissive" kind="METHOD">
<body>
<first>gray number specifying value between white and black</first>
<full>
gray number specifying value between white and black
</full>
</body>
<blocktags>
<blocktag>@param gray value between black and white, by default 0 to 255</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="emissive" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="lights" kind="METHOD">
<body>
<first>( begin auto-generated from lights.xml ) Sets the default ambient light, directional light, falloff, and specular values.</first>
<full>
Sets the default ambient light, directional light, falloff, and specular values. The defaults are ambientLight(128, 128, 128) and directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#noLights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="noLights" kind="METHOD">
<body>
<first>( begin auto-generated from noLights.xml ) Disable all lighting.</first>
<full>
Disable all lighting. Lighting is turned off by default and enabled with the `lights()` function. This function can be used to disable lighting so that 2D geometry (which does not require lighting) can be drawn after a set of lighted 3D geometry.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ambientLight" kind="METHOD">
<body>
<first>( begin auto-generated from ambientLight.xml ) Adds an ambient light.</first>
<full>
Adds an ambient light. Ambient light doesn't come from a specific direction, the rays have light have bounced around so much that objects are evenly lit from all sides. Ambient lights are almost always used in combination with other types of lights. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The effect of the parameters is determined by the current color mode.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="ambientLight" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="directionalLight" kind="METHOD">
<body>
<first>( begin auto-generated from directionalLight.xml ) Adds a directional light.</first>
<full>
Adds a directional light. Directional light comes from one direction and is stronger when hitting a surface squarely and weaker if it hits at a a gentle angle. After hitting a surface, a directional lights scatters in all directions. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `nx` , `ny` , and `nz` parameters specify the direction the light is facing. For example, setting `ny` to -1 will cause the geometry to be lit from below (the light is facing directly upward).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param nx direction along the x-axis</blocktag>
<blocktag>@param ny direction along the y-axis</blocktag>
<blocktag>@param nz direction along the z-axis</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="pointLight" kind="METHOD">
<body>
<first>( begin auto-generated from pointLight.xml ) Adds a point light.</first>
<full>
Adds a point light. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `x` , `y` , and `z` parameters set the position of the light.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="spotLight" kind="METHOD">
<body>
<first>( begin auto-generated from spotLight.xml ) Adds a spot light.</first>
<full>
Adds a spot light. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `x` , `y` , and `z` parameters specify the position of the light and `nx` , `ny` , `nz` specify the direction or light. The `angle` parameter affects angle of the spotlight cone.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
<blocktag>@param nx direction along the x axis</blocktag>
<blocktag>@param ny direction along the y axis</blocktag>
<blocktag>@param nz direction along the z axis</blocktag>
<blocktag>@param angle angle of the spotlight cone</blocktag>
<blocktag>@param concentration exponent determining the center bias of the cone</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="lightFalloff" kind="METHOD">
<body>
<first>( begin auto-generated from lightFalloff.xml ) Sets the falloff rates for point lights, spot lights, and ambient lights.</first>
<full>
Sets the falloff rates for point lights, spot lights, and ambient lights. The parameters are used to determine the falloff with the following equation:

d = distance from light position to vertex position
falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)

Like `fill()` , it affects only the elements which are created after it in the code. The default value if `LightFalloff(1.0, 0.0, 0.0)` . Thinking about an ambient light with a falloff can be tricky. It is used, for example, if you wanted a region of your scene to be lit ambiently one color and another region to be lit ambiently by another color, you would use an ambient light with location and falloff. You can think of it as a point light that doesn't care which direction a surface is facing.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param constant constant value or determining falloff</blocktag>
<blocktag>@param linear linear value for determining falloff</blocktag>
<blocktag>@param quadratic quadratic value for determining falloff</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#lightSpecular(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="lightSpecular" kind="METHOD">
<body>
<first>( begin auto-generated from lightSpecular.xml ) Sets the specular color for lights.</first>
<full>
Sets the specular color for lights. Like `fill()` , it affects only the elements which are created after it in the code. Specular refers to light which bounces off a surface in a perferred direction (rather than bouncing in all directions like a diffuse light) and is used for creating highlights. The specular quality of a light interacts with the specular material qualities set through the `specular()` and `shininess()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="background" kind="METHOD">
<body>
<first>( begin auto-generated from background.xml ) The , `,background(),` , function sets the color used for the background of the Processing window.</first>
<full>
The `background()` function sets the color used for the background of the Processing window. The default background is light gray. In the `draw()` function, the background color is used to clear the display window at the beginning of each frame.

An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window. To resize an image 'b' to the size of the sketch window, use b.resize(width, height).

Images used as background will ignore the current `tint()` setting.

It is not possible to use transparency (alpha) in background colors with the main drawing surface, however they will work properly with `createGraphics()` .

Advanced
--------



Clear the background with a color that includes an alpha value. This can only be used with objects created by createGraphics(), because the main drawing surface cannot be set transparent.&lt;/p&gt;

It might be tempting to use this function to partially clear the screen on each frame, however that's not how this function works. When calling background(), the pixels will be replaced with pixels that have that level of transparency. To do a semi-transparent overlay, use fill() with alpha and draw a rectangle.&lt;/p&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#stroke(float)</blocktag>
<blocktag>@see PGraphics#fill(float)</blocktag>
<blocktag>@see PGraphics#tint(float)</blocktag>
<blocktag>@see PGraphics#colorMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the background</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on the current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on the current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on the current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="clear" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="background" kind="METHOD">
<body>
<first>Takes an RGB or ARGB image and sets it as the background.</first>
<full>
Takes an RGB or ARGB image and sets it as the background. The width and height of the image must be the same size as the sketch. Use image.resize(width, height) to make short work of such a task.

Note that even if the image is set as RGB, the high 8 bits of each pixel should be set opaque (0xFF000000) because the image data will be copied directly to the screen, and non-opaque background images may have strange behavior. Use image.filter(OPAQUE) to handle this easily.

When using 3D, this will also clear the zbuffer (if it exists).
</full>
</body>
<blocktags>
<blocktag>@param image PImage to set as background (must be same size as the sketch window)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="backgroundImpl" kind="METHOD">
<body>
<first>Actually set the background image.</first>
<full>
Actually set the background image. This is separated from the error handling and other semantic goofiness that is shared across renderers.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="backgroundImpl" kind="METHOD">
<body>
<first>Actual implementation of clearing the background, now that the internal variables for background color have been set.</first>
<full>
Actual implementation of clearing the background, now that the internal variables for background color have been set. Called by the backgroundFromCalc() method, which is what all the other background() methods call once the work is done.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorMode" kind="METHOD">
<body>
<first>( begin auto-generated from colorMode.xml ) Changes the way Processing interprets color data.</first>
<full>
Changes the way Processing interprets color data. By default, the parameters for `fill()` , `stroke()` , `background()` , and `color()` are defined by values between 0 and 255 using the RGB color model. The `colorMode()` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling `colorMode(RGB, 1.0)` will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters range1, range2, range3, and range 4.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness</blocktag>
<blocktag>@see PGraphics#background(float)</blocktag>
<blocktag>@see PGraphics#fill(float)</blocktag>
<blocktag>@see PGraphics#stroke(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param max range for all color elements</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param max1 range for the red or hue depending on the current color mode</blocktag>
<blocktag>@param max2 range for the green or saturation depending on the current color mode</blocktag>
<blocktag>@param max3 range for the blue or brightness depending on the current color mode</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param maxA range for the alpha</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorCalc" kind="METHOD">
<body>
<first>Set the fill to either a grayscale value or an ARGB int.</first>
<full>
Set the fill to either a grayscale value or an ARGB int.

The problem with this code is that it has to detect between these two situations automatically. This is done by checking to see if the high bits (the alpha for 0xAA000000) is set, and if not, whether the color value that follows is less than colorModeX (first param passed to colorMode).

This auto-detect would break in the following situation:

```
size(256, 256); for (int i = 0; i&lt;256; i++) {   color c = color(0, 0, 0, i);   stroke(c);   line(i, 0, i, 256); }
```

...on the first time through the loop, where (i == 0), since the color itself is zero (black) then it would appear indistinguishable from code that reads "fill(0)". The solution is to use the four parameter versions of stroke or fill to more directly specify the desired result.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="colorCalcARGB" kind="METHOD">
<body>
<first>Unpacks AARRGGBB color for direct use with colorCalc.</first>
<full>
Unpacks AARRGGBB color for direct use with colorCalc.

Handled here with its own function since this is indepenent of the color mode.

Strangely the old version of this code ignored the alpha value. not sure if that was a bug or what.

Note, no need for a bounds check for 'argb' since it's a 32 bit number. Bounds now checked on alpha, however (rev 0225).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="color" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c can be packed ARGB or a gray in this case</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="color" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c can be packed ARGB or a gray in this case</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="alpha" kind="METHOD">
<body>
<first>( begin auto-generated from alpha.xml ) Extracts the alpha value from a color.</first>
<full>
Extracts the alpha value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="red" kind="METHOD">
<body>
<first>( begin auto-generated from red.xml ) Extracts the red value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the red value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The red() function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use the&gt;&gt;(right shift) operator with a bit mask. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = red(myColor);
float r2 = myColor&gt;&gt;16&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="green" kind="METHOD">
<body>
<first>( begin auto-generated from green.xml ) Extracts the green value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the green value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The `green()` function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use the&gt;&gt;(right shift) operator with a bit mask. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = green(myColor);
float r2 = myColor&gt;&gt;8&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="blue" kind="METHOD">
<body>
<first>( begin auto-generated from blue.xml ) Extracts the blue value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the blue value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The `blue()` function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use a bit mask to remove the other color components. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = blue(myColor);
float r2 = myColor&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="hue" kind="METHOD">
<body>
<first>( begin auto-generated from hue.xml ) Extracts the hue value from a color.</first>
<full>
Extracts the hue value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="saturation" kind="METHOD">
<body>
<first>( begin auto-generated from saturation.xml ) Extracts the saturation value from a color.</first>
<full>
Extracts the saturation value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="brightness" kind="METHOD">
<body>
<first>( begin auto-generated from brightness.xml ) Extracts the brightness value from a color.</first>
<full>
Extracts the brightness value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="lerpColor" kind="METHOD">
<body>
<first>( begin auto-generated from lerpColor.xml ) Calculates a color or colors between two color at a specific increment.</first>
<full>
Calculates a color or colors between two color at a specific increment. The `amt` parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param c1 interpolate from this color</blocktag>
<blocktag>@param c2 interpolate to this color</blocktag>
<blocktag>@param amt between 0.0 and 1.0</blocktag>
<blocktag>@see PImage#blendColor(int, int, int)</blocktag>
<blocktag>@see PGraphics#color(float, float, float, float)</blocktag>
<blocktag>@see PApplet#lerp(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="lerpColor" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Interpolate between two colors. Like lerp(), but for the individual color components of a color supplied as an int value.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="beginRaw" kind="METHOD">
<body>
<first>Record individual lines and triangles by echoing them to another renderer.</first>
<full>
Record individual lines and triangles by echoing them to another renderer.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showWarning" kind="METHOD">
<body>
<first>Show a renderer error, and keep track of it so that it's only shown once.</first>
<full>
Show a renderer error, and keep track of it so that it's only shown once.
</full>
</body>
<blocktags>
<blocktag>@param msg the error message (which will be stored for later comparison)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showWarning" kind="METHOD">
<body>
<first>Version of showWarning() that takes a parsed String.</first>
<full>
Version of showWarning() that takes a parsed String.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showDepthWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is only available with 3D.</first>
<full>
Display a warning that the specified method is only available with 3D.
</full>
</body>
<blocktags>
<blocktag>@param method The method name (no parentheses)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showDepthWarningXYZ" kind="METHOD">
<body>
<first>Display a warning that the specified method that takes x, y, z parameters can only be used with x and y parameters in this renderer.</first>
<full>
Display a warning that the specified method that takes x, y, z parameters can only be used with x and y parameters in this renderer.
</full>
</body>
<blocktags>
<blocktag>@param method The method name (no parentheses)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showMethodWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is simply unavailable.</first>
<full>
Display a warning that the specified method is simply unavailable.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showVariationWarning" kind="METHOD">
<body>
<first>Error that a particular variation of a method is unavailable (even though other variations are).</first>
<full>
Error that a particular variation of a method is unavailable (even though other variations are). For instance, if vertex(x, y, u, v) is not available, but vertex(x, y) is just fine.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showMissingWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is not implemented, meaning that it could be either a completely missing function, although other variations of it may still work properly.</first>
<full>
Display a warning that the specified method is not implemented, meaning that it could be either a completely missing function, although other variations of it may still work properly.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="showException" kind="METHOD">
<body>
<first>Show an renderer-related exception that halts the program.</first>
<full>
Show an renderer-related exception that halts the program. Currently just wraps the message as a RuntimeException and throws it, but might do something more specific might be used in the future.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="defaultFontOrDeath" kind="METHOD">
<body>
<first>Same as below, but defaults to a 12 point font, just as MacWrite intended.</first>
<full>
Same as below, but defaults to a 12 point font, just as MacWrite intended.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="defaultFontOrDeath" kind="METHOD">
<body>
<first>First try to create a default font, but if that's not possible, throw an exception that halts the program because textFont() has not been used prior to the specified method.</first>
<full>
First try to create a default font, but if that's not possible, throw an exception that halts the program because textFont() has not been used prior to the specified method.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="displayable" kind="METHOD">
<body>
<first>Return true if this renderer should be drawn to the screen.</first>
<full>
Return true if this renderer should be drawn to the screen. Defaults to returning true, since nearly all renderers are on-screen beasts. But can be overridden for subclasses like PDF so that a window doesn't open up.

A better name? showFrame, displayable, isVisible, visible, shouldDisplay, what to call this?
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="is2D" kind="METHOD">
<body>
<first>Return true if this renderer supports 2D drawing.</first>
<full>
Return true if this renderer supports 2D drawing. Defaults to true.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="is3D" kind="METHOD">
<body>
<first>Return true if this renderer supports 3D drawing.</first>
<full>
Return true if this renderer supports 3D drawing. Defaults to false.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="isGL" kind="METHOD">
<body>
<first>Return true if this renderer does rendering through OpenGL.</first>
<full>
Return true if this renderer does rendering through OpenGL. Defaults to false.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics" name="awaitAsyncSaveCompletion" kind="METHOD">
<body>
<first>If there is running async save task for this file, blocks until it completes.</first>
<full>
If there is running async save task for this file, blocks until it completes. Has to be called on main thread because OpenGL overrides this and calls GL.
</full>
</body>
<blocktags>
<blocktag>@param filename</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PGraphics.AsyncImageSaver" name="getAvailableTarget" kind="METHOD">
<body>
<first>After taking a target, you must call saveTargetAsync() or returnUnusedTarget(), otherwise one thread won't be able to run</first>
<full>
After taking a target, you must call saveTargetAsync() or returnUnusedTarget(), otherwise one thread won't be able to run
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="Glyph" kind="CLASS">
<body>
<first>A single character, and its visage.</first>
<full>
A single character, and its visage.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="glyphCount" kind="FIELD">
<body>
<first>Number of character glyphs in this font.</first>
<full>
Number of character glyphs in this font.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="glyphs" kind="FIELD">
<body>
<first>Actual glyph data.</first>
<full>
Actual glyph data. The length of this array won't necessarily be the same size as glyphCount, in cases where lazy font loading is in use.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="name" kind="FIELD">
<body>
<first>Name of the font as seen by Java when it was created.</first>
<full>
Name of the font as seen by Java when it was created. If the font is available, the native version will be used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="psname" kind="FIELD">
<body>
<first>Postscript name of the font that this bitmap was created from.</first>
<full>
Postscript name of the font that this bitmap was created from.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="size" kind="FIELD">
<body>
<first>The original size of the font when it was first created</first>
<full>
The original size of the font when it was first created
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="density" kind="FIELD">
<body>
<first>Default density set to 1 for backwards compatibility with loadFont().</first>
<full>
Default density set to 1 for backwards compatibility with loadFont().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="smooth" kind="FIELD">
<body>
<first>true if smoothing was enabled for this font, used for native impl</first>
<full>
true if smoothing was enabled for this font, used for native impl
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="ascent" kind="FIELD">
<body>
<first>The ascent of the font.</first>
<full>
The ascent of the font. If the 'd' character is present in this PFont, this value is replaced with its pixel height, because the values returned by FontMetrics.getAscent() seem to be terrible.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="descent" kind="FIELD">
<body>
<first>The descent of the font.</first>
<full>
The descent of the font. If the 'p' character is present in this PFont, this value is replaced with its lowest pixel height, because the values returned by FontMetrics.getDescent() are gross.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="ascii" kind="FIELD">
<body>
<first>A more efficient array lookup for straight ASCII characters.</first>
<full>
A more efficient array lookup for straight ASCII characters. For Unicode characters, a QuickSort-style search is used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="lazy" kind="FIELD">
<body>
<first>True if this font is set to load dynamically.</first>
<full>
True if this font is set to load dynamically. This is the default when createFont() method is called without a character set. Bitmap versions of characters are only created when prompted by an index() call.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="font" kind="FIELD">
<body>
<first>Native Java version of the font.</first>
<full>
Native Java version of the font. If possible, this allows the PGraphics subclass to just use Java's font rendering stuff in situations where that's faster.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="stream" kind="FIELD">
<body>
<first>True if this font was loaded from an InputStream, rather than by name from the OS.</first>
<full>
True if this font was loaded from an InputStream, rather than by name from the OS. It's best to use the native version of a font loaded from a TTF file, since that will ensure that the font is available when the sketch is exported.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="subsetting" kind="FIELD">
<body>
<first>True if this font should return 'null' for getFont(), so that the native font will be used to create a subset, but the native version of the font will not be used.</first>
<full>
True if this font should return 'null' for getFont(), so that the native font will be used to create a subset, but the native version of the font will not be used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="fontSearched" kind="FIELD">
<body>
<first>True if already tried to find the native AWT version of this font.</first>
<full>
True if already tried to find the native AWT version of this font.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="systemFontName" kind="FIELD">
<body>
<first>The name of the font that Java uses when a font isn't found.</first>
<full>
The name of the font that Java uses when a font isn't found. See{@link #findFont(String)}and{@link #loadFonts()}for more info.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="fonts" kind="FIELD">
<body>
<first>Array of the native system fonts.</first>
<full>
Array of the native system fonts. Used to lookup native fonts by their PostScript name. This is a workaround for a several year old Apple Java bug that they can't be bothered to fix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="init" kind="CONSTRUCTOR">
<body>
<first>( begin auto-generated from PFont.xml ) PFont is the font class for Processing.</first>
<full>
PFont is the font class for Processing. To create a font to use with Processing, select "Create Font..." from the Tools menu. This will create a font in the format Processing requires and also adds it to the current sketch's data directory. Processing displays fonts using the .vlw font format, which uses images for each letter, rather than defining them through vector data. The `loadFont()` function constructs a new font and `textFont()` makes a font active. The `list()` method creates a list of the fonts installed on the computer, which is useful information to use with the `createFont()` function for dynamically converting fonts into a format to use with Processing.
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param font font the font object to create from</blocktag>
<blocktag>@param smooth smooth true to enable smoothing/anti-aliasing</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="init" kind="CONSTRUCTOR">
<body>
<first>Create a new image-based font on the fly.</first>
<full>
Create a new image-based font on the fly. If charset is set to null, the characters will only be created as bitmaps when they're drawn.
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param charset array of all unicode chars that should be included</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="init" kind="CONSTRUCTOR">
<body>
<first>Adds an additional parameter that indicates the font came from a file, not a built-in OS font.</first>
<full>
Adds an additional parameter that indicates the font came from a file, not a built-in OS font.
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param input InputStream</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="save" kind="METHOD">
<body>
<first>Write this PFont to an OutputStream.</first>
<full>
Write this PFont to an OutputStream.

This is used by the Create Font tool, or whatever anyone else dreams up for messing with fonts themselves.

It is assumed that the calling class will handle closing the stream when finished.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="addGlyph" kind="METHOD">
<body>
<first>Create a new glyph, and add the character to the current font.</first>
<full>
Create a new glyph, and add the character to the current font.
</full>
</body>
<blocktags>
<blocktag>@param c character to create an image for.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="setNative" kind="METHOD">
<body>
<first>Set the native complement of this font.</first>
<full>
Set the native complement of this font. Might be set internally via the findFont() function, or externally by a deriveFont() call if the font is resized by PGraphicsJava2D.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="getFont" kind="METHOD">
<body>
<first>Use the getNative() method instead, which allows library interfaces to be written in a cross-platform fashion for desktop, Android, and others.</first>
<full>
Use the getNative() method instead, which allows library interfaces to be written in a cross-platform fashion for desktop, Android, and others.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="getNative" kind="METHOD">
<body>
<first>Return the native java.awt.Font associated with this PFont (if any).</first>
<full>
Return the native java.awt.Font associated with this PFont (if any).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="getSize" kind="METHOD">
<body>
<first>Return size of this font.</first>
<full>
Return size of this font.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="getDefaultSize" kind="METHOD">
<body>
<first>Returns the size that will be used when textFont(font) is called.</first>
<full>
Returns the size that will be used when textFont(font) is called. When drawing with 2x pixel density, bitmap fonts in OpenGL need to be created (behind the scenes) at double the requested size. This ensures that they're shown at half on displays (so folks don't have to change their sketch code).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="findNative" kind="METHOD">
<body>
<first>Attempt to find the native version of this font.</first>
<full>
Attempt to find the native version of this font. (Public so that it can be used by OpenGL or other renderers.)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="index" kind="METHOD">
<body>
<first>Get index for the character.</first>
<full>
Get index for the character.
</full>
</body>
<blocktags>
<blocktag>@return index into arrays or -1 if not found</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="kern" kind="METHOD">
<body>
<first>Currently un-implemented for .vlw fonts, but honored for layout in case subclasses use it.</first>
<full>
Currently un-implemented for .vlw fonts, but honored for layout in case subclasses use it.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="ascent" kind="METHOD">
<body>
<first>Returns the ascent of this font from the baseline.</first>
<full>
Returns the ascent of this font from the baseline. The value is based on a font of size 1.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="descent" kind="METHOD">
<body>
<first>Returns how far this font descends from the baseline.</first>
<full>
Returns how far this font descends from the baseline. The value is based on a font size of 1.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="width" kind="METHOD">
<body>
<first>Width of this character for a font of size 1.</first>
<full>
Width of this character for a font of size 1.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="CHARSET" kind="FIELD">
<body>
<first>The default Processing character set.</first>
<full>
The default Processing character set.

This is the union of the Mac Roman and Windows ANSI (CP1250) character sets. ISO 8859-1 Latin 1 is Unicode characters 0x80 -&gt;0xFF, and would seem a good standard, but in practice, most P5 users would rather have characters that they expect from their platform's fonts.

This is more of an interim solution until a much better font solution can be determined. (i.e. create fonts on the fly from some sort of vector format).

Not that I expect that to happen.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="list" kind="METHOD">
<body>
<first>( begin auto-generated from PFont_list.xml ) Gets a list of the fonts installed on the system.</first>
<full>
Gets a list of the fonts installed on the system. The data is returned as a String array. This list provides the names of each font for input into `createFont()` , which allows Processing to dynamically format fonts. This function is meant as a tool for programming local applications and is not recommended for use in applets.
</full>
</body>
<blocktags>
<blocktag>@webref pfont</blocktag>
<blocktag>@usage application</blocktag>
<blocktag>@brief Gets a list of the fonts installed on the system</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="loadFonts" kind="METHOD">
<body>
<first>Make an internal list of all installed fonts.</first>
<full>
Make an internal list of all installed fonts. This can take a while with a lot of fonts installed, but running it on a separate thread may not help much. As of the commit that's adding this note, loadFonts() will only be called by PFont.list() and when loading a font by name, both of which are occasions when we'd need to block until this was finished anyway. It's also possible that running getAllFonts() on a non-EDT thread could cause graphics system issues. Further, the first fonts are usually loaded at the beginning of a sketch, meaning that sketch startup time will still be affected, even with threading in place. Where we're getting killed on font performance is due to this bug: https://bugs.openjdk.java.net/browse/JDK-8179209
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PFont" name="findFont" kind="METHOD">
<body>
<first>Starting with Java 1.5, Apple broke the ability to specify most fonts.</first>
<full>
Starting with Java 1.5, Apple broke the ability to specify most fonts. This bug was filed years ago as #4769141 at bugreporter.apple.com. More:&lt;a href="http://dev.processing.org/bugs/show_bug.cgi?id=407"&gt;Bug 407&lt;/a&gt;.&lt;br&gt;This function displays a warning when the font is not found and Java's system font is used. See:&lt;a href="https://github.com/processing/processing/issues/5481"&gt;issue #5481&lt;/a&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MACOSX" kind="FIELD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@deprecated Marketers gonna market, use {@link #MACOS}</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MAX_FLOAT" kind="FIELD">
<body>
<first>Same as Float.MAX_VALUE, but included for parity with MIN_VALUE, and to avoid teaching static methods on the first day.</first>
<full>
Same as Float.MAX_VALUE, but included for parity with MIN_VALUE, and to avoid teaching static methods on the first day.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MIN_FLOAT" kind="FIELD">
<body>
<first>Note that Float.MIN_VALUE is the smallest ,&lt;EM&gt;,positive,&lt;/EM&gt;, value for a floating point number, not actually the minimum (negative) value for a float.</first>
<full>
Note that Float.MIN_VALUE is the smallest&lt;EM&gt;positive&lt;/EM&gt;value for a floating point number, not actually the minimum (negative) value for a float. This constant equals 0xFF7FFFFF, the smallest (farthest negative) value a float can have before it hits NaN.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MAX_INT" kind="FIELD">
<body>
<first>Largest possible (positive) integer value</first>
<full>
Largest possible (positive) integer value
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MIN_INT" kind="FIELD">
<body>
<first>Smallest possible (negative) integer value</first>
<full>
Smallest possible (negative) integer value
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="PI" kind="FIELD">
<body>
<first>( begin auto-generated from PI.xml ) PI is a mathematical constant with the value 3.14159265358979323846.</first>
<full>
PI is a mathematical constant with the value 3.14159265358979323846. It is the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions `sin()` and `cos()` .
</full>
</body>
<blocktags>
<blocktag>@webref constants</blocktag>
<blocktag>@see PConstants#TWO_PI</blocktag>
<blocktag>@see PConstants#TAU</blocktag>
<blocktag>@see PConstants#HALF_PI</blocktag>
<blocktag>@see PConstants#QUARTER_PI</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="HALF_PI" kind="FIELD">
<body>
<first>( begin auto-generated from HALF_PI.xml ) HALF_PI is a mathematical constant with the value 1.57079632679489661923.</first>
<full>
HALF_PI is a mathematical constant with the value 1.57079632679489661923. It is half the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions `sin()` and `cos()` .
</full>
</body>
<blocktags>
<blocktag>@webref constants</blocktag>
<blocktag>@see PConstants#PI</blocktag>
<blocktag>@see PConstants#TWO_PI</blocktag>
<blocktag>@see PConstants#TAU</blocktag>
<blocktag>@see PConstants#QUARTER_PI</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="QUARTER_PI" kind="FIELD">
<body>
<first>( begin auto-generated from QUARTER_PI.xml ) QUARTER_PI is a mathematical constant with the value 0.7853982.</first>
<full>
QUARTER_PI is a mathematical constant with the value 0.7853982. It is one quarter the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions `sin()` and `cos()` .
</full>
</body>
<blocktags>
<blocktag>@webref constants</blocktag>
<blocktag>@see PConstants#PI</blocktag>
<blocktag>@see PConstants#TWO_PI</blocktag>
<blocktag>@see PConstants#TAU</blocktag>
<blocktag>@see PConstants#HALF_PI</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="TWO_PI" kind="FIELD">
<body>
<first>( begin auto-generated from TWO_PI.xml ) TWO_PI is a mathematical constant with the value 6.28318530717958647693.</first>
<full>
TWO_PI is a mathematical constant with the value 6.28318530717958647693. It is twice the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions `sin()` and `cos()` .
</full>
</body>
<blocktags>
<blocktag>@webref constants</blocktag>
<blocktag>@see PConstants#PI</blocktag>
<blocktag>@see PConstants#TAU</blocktag>
<blocktag>@see PConstants#HALF_PI</blocktag>
<blocktag>@see PConstants#QUARTER_PI</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="TAU" kind="FIELD">
<body>
<first>( begin auto-generated from TAU.xml ) TAU is an alias for TWO_PI, a mathematical constant with the value 6.28318530717958647693.</first>
<full>
TAU is an alias for TWO_PI, a mathematical constant with the value 6.28318530717958647693. It is twice the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions `sin()` and `cos()` .
</full>
</body>
<blocktags>
<blocktag>@webref constants</blocktag>
<blocktag>@see PConstants#PI</blocktag>
<blocktag>@see PConstants#TWO_PI</blocktag>
<blocktag>@see PConstants#HALF_PI</blocktag>
<blocktag>@see PConstants#QUARTER_PI</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="CORNER" kind="FIELD">
<body>
<first>Draw mode convention to use (x, y) to (width, height)</first>
<full>
Draw mode convention to use (x, y) to (width, height)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="CORNERS" kind="FIELD">
<body>
<first>Draw mode convention to use (x1, y1) to (x2, y2) coordinates</first>
<full>
Draw mode convention to use (x1, y1) to (x2, y2) coordinates
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="RADIUS" kind="FIELD">
<body>
<first>Draw mode from the center, and using the radius</first>
<full>
Draw mode from the center, and using the radius
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="CENTER" kind="FIELD">
<body>
<first>Draw from the center, using second pair of values as the diameter.</first>
<full>
Draw from the center, using second pair of values as the diameter. Formerly called CENTER_DIAMETER in alpha releases.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="DIAMETER" kind="FIELD">
<body>
<first>Synonym for the CENTER constant.</first>
<full>
Synonym for the CENTER constant. Draw from the center, using second pair of values as the diameter.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="BASELINE" kind="FIELD">
<body>
<first>Default vertical alignment for text placement</first>
<full>
Default vertical alignment for text placement
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="TOP" kind="FIELD">
<body>
<first>Align text to the top</first>
<full>
Align text to the top
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="BOTTOM" kind="FIELD">
<body>
<first>Align text from the bottom, using the baseline.</first>
<full>
Align text from the bottom, using the baseline.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="NORMAL" kind="FIELD">
<body>
<first>texture coordinates in 0..1 range</first>
<full>
texture coordinates in 0..1 range
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="IMAGE" kind="FIELD">
<body>
<first>texture coordinates based on image width/height</first>
<full>
texture coordinates based on image width/height
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="CLAMP" kind="FIELD">
<body>
<first>textures are clamped to their edges</first>
<full>
textures are clamped to their edges
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="REPEAT" kind="FIELD">
<body>
<first>textures wrap around when uv values go outside 0..1 range</first>
<full>
textures wrap around when uv values go outside 0..1 range
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="MODEL" kind="FIELD">
<body>
<first>textMode(MODEL) is the default, meaning that characters will be affected by transformations like any other shapes.</first>
<full>
textMode(MODEL) is the default, meaning that characters will be affected by transformations like any other shapes.

Changed value in 0093 to not interfere with LEFT, CENTER, and RIGHT.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="SHAPE" kind="FIELD">
<body>
<first>textMode(SHAPE) draws text using the the glyph outlines of individual characters rather than as textures.</first>
<full>
textMode(SHAPE) draws text using the the glyph outlines of individual characters rather than as textures. If the outlines are not available, then textMode(SHAPE) will be ignored and textMode(MODEL) will be used instead. For this reason, be sure to call textMode()&lt;EM&gt;after&lt;/EM&gt;calling textFont().

Currently, textMode(SHAPE) is only supported by OPENGL mode. It also requires Java 1.2 or higher (OPENGL requires 1.4 anyway)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="PORTRAIT" kind="FIELD">
<body>
<first>Screen orientation constant for portrait (the hamburger way).</first>
<full>
Screen orientation constant for portrait (the hamburger way).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="LANDSCAPE" kind="FIELD">
<body>
<first>Screen orientation constant for landscape (the hot dog way).</first>
<full>
Screen orientation constant for landscape (the hot dog way).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PConstants" name="SPAN" kind="FIELD">
<body>
<first>Use with fullScreen() to indicate all available displays.</first>
<full>
Use with fullScreen() to indicate all available displays.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="javaVersionName" kind="FIELD">
<body>
<first>Full name of the Java version (i.e.</first>
<full>
Full name of the Java version (i.e. 1.5.0_11).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="javaVersion" kind="FIELD">
<body>
<first>Do not use; javaPlatform or javaVersionName are better options.</first>
<full>
Do not use; javaPlatform or javaVersionName are better options. For instance, javaPlatform is useful when you need a number for comparison, i.e. "if (javaPlatform&gt;= 9)".
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="platform" kind="FIELD">
<body>
<first>Current platform in use, one of the PConstants WINDOWS, MACOS, LINUX or OTHER.</first>
<full>
Current platform in use, one of the PConstants WINDOWS, MACOS, LINUX or OTHER.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="useNativeSelect" kind="FIELD">
<body>
<first>Whether to use native (AWT) dialogs for selectInput and selectOutput.</first>
<full>
Whether to use native (AWT) dialogs for selectInput and selectOutput. The native dialogs on some platforms can be ugly, buggy, or missing features. For 3.3.5, this defaults to true on all platforms.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="g" kind="FIELD">
<body>
<first>The PGraphics renderer associated with this PApplet</first>
<full>
The PGraphics renderer associated with this PApplet
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="displayWidth" kind="FIELD">
<body>
<first>( begin auto-generated from displayWidth.xml ) System variable which stores the width of the computer screen.</first>
<full>
System variable which stores the width of the computer screen. For example, if the current screen resolution is 1024x768, `displayWidth` is 1024 and `displayHeight` is 768. These dimensions are useful when exporting full-screen applications.

To ensure that the sketch takes over the entire screen, use "Present" instead of "Run". Otherwise the window will still have a frame border around it and not be placed in the upper corner of the screen. On Mac OS X, the menu bar will remain present unless "Present" mode is used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="displayHeight" kind="FIELD">
<body>
<first>( begin auto-generated from displayHeight.xml ) System variable that stores the height of the computer screen.</first>
<full>
System variable that stores the height of the computer screen. For example, if the current screen resolution is 1024x768, `displayWidth` is 1024 and `displayHeight` is 768. These dimensions are useful when exporting full-screen applications.

To ensure that the sketch takes over the entire screen, use "Present" instead of "Run". Otherwise the window will still have a frame border around it and not be placed in the upper corner of the screen. On Mac OS X, the menu bar will remain present unless "Present" mode is used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="recorder" kind="FIELD">
<body>
<first>A leech graphics object that is echoing all events.</first>
<full>
A leech graphics object that is echoing all events.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="args" kind="FIELD">
<body>
<first>Command line options passed in from main().</first>
<full>
Command line options passed in from main(). This does not include the arguments passed in to PApplet itself.
</full>
</body>
<blocktags>
<blocktag>@see PApplet#main</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sketchPath" kind="FIELD">
<body>
<first>Path to sketch folder.</first>
<full>
Path to sketch folder. Previously undocumented, made private in 3.0a5 so that people use the sketchPath() method and it's inited properly. Call sketchPath() once to set the default.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="DEFAULT_WIDTH" kind="FIELD">
<body>
<first>Default width and height for sketch when not specified</first>
<full>
Default width and height for sketch when not specified
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pixels" kind="FIELD">
<body>
<first>( begin auto-generated from pixels.xml ) Array containing the values for all the pixels in the display window.</first>
<full>
Array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. The `index` value defines the position of a value within the array. For example, the statement `color b = pixels[230]` will set the variable `b` to be equal to the value at that location in the array.

Before accessing this array, the data must loaded with the `loadPixels()` function. After the array data has been modified, the `updatePixels()` function must be run to update the changes. Without `loadPixels()` , running the code may (or will in future releases) result in a NullPointerException.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@see PApplet#loadPixels()</blocktag>
<blocktag>@see PApplet#updatePixels()</blocktag>
<blocktag>@see PApplet#get(int, int, int, int)</blocktag>
<blocktag>@see PApplet#set(int, int, int)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PApplet#pixelDensity(int)</blocktag>
<blocktag>@see PApplet#pixelWidth</blocktag>
<blocktag>@see PApplet#pixelHeight</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="width" kind="FIELD">
<body>
<first>( begin auto-generated from width.xml ) System variable which stores the width of the display window.</first>
<full>
System variable which stores the width of the display window. This value is set by the first parameter of the `size()` function. For example, the function call `size(320, 240)` sets the `width` variable to the value 320. The value of `width` is zero until `size()` is called.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#height</blocktag>
<blocktag>@see PApplet#size(int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="height" kind="FIELD">
<body>
<first>( begin auto-generated from height.xml ) System variable which stores the height of the display window.</first>
<full>
System variable which stores the height of the display window. This value is set by the second parameter of the `size()` function. For example, the function call `size(320, 240)` sets the `height` variable to the value 240. The value of `height` is zero until `size()` is called.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#width</blocktag>
<blocktag>@see PApplet#size(int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pixelWidth" kind="FIELD">
<body>
<first>( begin auto-generated from pixelWidth.xml ) When , `,pixelDensity(2),&lt;/d&gt;, is used to make use of a high resolution display (called a Retina display on OS X or high-dpi on Windows and Linux), the width and height of the sketch do not change, but the number of pixels is doubled.</first>
<full>
When `pixelDensity(2)&lt;/d&gt;is used to make use of a high resolution display (called a Retina display on OS X or high-dpi on Windows and Linux), the width and height of the sketch do not change, but the number of pixels is doubled. As a result, all operations that use pixels (like `loadPixels()` , `get()` , `set()` , etc.) happen in this doubled space. As a convenience, the variables `pixelWidth` and `pixelHeight `hold the actual width and height of the sketch in pixels. This is useful for any sketch that uses the `pixels[]` array, for instance, because the number of elements in the array will be `pixelWidth*pixelHeight` , not `width*height` .
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#pixelHeight</blocktag>
<blocktag>@see #pixelDensity(int)</blocktag>
<blocktag>@see #displayDensity()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pixelHeight" kind="FIELD">
<body>
<first>( begin auto-generated from pixelHeight.xml ) When , `,pixelDensity(2),&lt;/d&gt;, is used to make use of a high resolution display (called a Retina display on OS X or high-dpi on Windows and Linux), the width and height of the sketch do not change, but the number of pixels is doubled.</first>
<full>
When `pixelDensity(2)&lt;/d&gt;is used to make use of a high resolution display (called a Retina display on OS X or high-dpi on Windows and Linux), the width and height of the sketch do not change, but the number of pixels is doubled. As a result, all operations that use pixels (like `loadPixels()` , `get()` , `set()` , etc.) happen in this doubled space. As a convenience, the variables `pixelWidth` and `pixelHeight `hold the actual width and height of the sketch in pixels. This is useful for any sketch that uses the `pixels[]` array, for instance, because the number of elements in the array will be `pixelWidth*pixelHeight` , not `width*height` .
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#pixelWidth</blocktag>
<blocktag>@see #pixelDensity(int)</blocktag>
<blocktag>@see #displayDensity()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyRepeatEnabled" kind="FIELD">
<body>
<first>Keeps track of ENABLE_KEY_REPEAT hint</first>
<full>
Keeps track of ENABLE_KEY_REPEAT hint
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseX" kind="FIELD">
<body>
<first>( begin auto-generated from mouseX.xml ) The system variable , `,mouseX,` , always contains the current horizontal coordinate of the mouse.</first>
<full>
The system variable `mouseX` always contains the current horizontal coordinate of the mouse.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseY" kind="FIELD">
<body>
<first>( begin auto-generated from mouseY.xml ) The system variable , `,mouseY,` , always contains the current vertical coordinate of the mouse.</first>
<full>
The system variable `mouseY` always contains the current vertical coordinate of the mouse.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pmouseX" kind="FIELD">
<body>
<first>( begin auto-generated from pmouseX.xml ) The system variable , `,pmouseX,` , always contains the horizontal position of the mouse in the frame previous to the current frame.,
, ,
, You may find that , `,pmouseX,` , and , `,pmouseY,` , have different values inside , `,draw(),` , and inside events like , `,mousePressed(),` , and , `,mouseMoved(),` ,.</first>
<full>
The system variable `pmouseX` always contains the horizontal position of the mouse in the frame previous to the current frame.

You may find that `pmouseX` and `pmouseY` have different values inside `draw()` and inside events like `mousePressed()` and `mouseMoved()` . This is because they're used for different roles, so don't mix them. Inside `draw()` , `pmouseX` and `pmouseY` update only once per frame (once per trip through your `draw()` ). But, inside mouse events, they update each time the event is called. If they weren't separated, then the mouse would be read only once per frame, making response choppy. If the mouse variables were always updated multiple times per frame, using `line(pmouseX, pmouseY, mouseX, mouseY)` inside `draw()` would have lots of gaps, because `pmouseX` may have changed several times in between the calls to `line()` . Use `pmouseX` and `pmouseY` inside `draw()` if you want values relative to the previous frame. Use `pmouseX` and `pmouseY` inside the mouse functions if you want continuous response.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pmouseY" kind="FIELD">
<body>
<first>( begin auto-generated from pmouseY.xml ) The system variable , `,pmouseY,` , always contains the vertical position of the mouse in the frame previous to the current frame.</first>
<full>
The system variable `pmouseY` always contains the vertical position of the mouse in the frame previous to the current frame. More detailed information about how `pmouseY` is updated inside of `draw()` and mouse events is explained in the reference for `pmouseX` .
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dmouseX" kind="FIELD">
<body>
<first>Previous mouseX/Y for the draw loop, separated out because this is separate from the pmouseX/Y when inside the mouse event handlers.</first>
<full>
Previous mouseX/Y for the draw loop, separated out because this is separate from the pmouseX/Y when inside the mouse event handlers. See emouseX/Y for an explanation.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dmouseY" kind="FIELD">
<body>
<first>Previous mouseX/Y for the draw loop, separated out because this is separate from the pmouseX/Y when inside the mouse event handlers.</first>
<full>
Previous mouseX/Y for the draw loop, separated out because this is separate from the pmouseX/Y when inside the mouse event handlers. See emouseX/Y for an explanation.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="emouseX" kind="FIELD">
<body>
<first>The pmouseX/Y for the event handlers (mousePressed(), mouseDragged() etc) these are different because mouse events are queued to the end of draw, so the previous position has to be updated on each event, as opposed to the pmouseX/Y that's used inside draw, which is expected to be updated once per trip through draw().</first>
<full>
The pmouseX/Y for the event handlers (mousePressed(), mouseDragged() etc) these are different because mouse events are queued to the end of draw, so the previous position has to be updated on each event, as opposed to the pmouseX/Y that's used inside draw, which is expected to be updated once per trip through draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="emouseY" kind="FIELD">
<body>
<first>The pmouseX/Y for the event handlers (mousePressed(), mouseDragged() etc) these are different because mouse events are queued to the end of draw, so the previous position has to be updated on each event, as opposed to the pmouseX/Y that's used inside draw, which is expected to be updated once per trip through draw().</first>
<full>
The pmouseX/Y for the event handlers (mousePressed(), mouseDragged() etc) these are different because mouse events are queued to the end of draw, so the previous position has to be updated on each event, as opposed to the pmouseX/Y that's used inside draw, which is expected to be updated once per trip through draw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="firstMouse" kind="FIELD">
<body>
<first>Used to set pmouseX/Y to mouseX/Y the first time mouseX/Y are used, otherwise pmouseX/Y are always zero, causing a nasty jump.</first>
<full>
Used to set pmouseX/Y to mouseX/Y the first time mouseX/Y are used, otherwise pmouseX/Y are always zero, causing a nasty jump.

Just using (frameCount == 0) won't work since mouseXxxxx() may not be called until a couple frames into things.


</full>
</body>
<blocktags>
<blocktag>@deprecated Please refrain from using this variable, it will be removed from future releases of Processing because it cannot be used consistently across platforms and input methods.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseButton" kind="FIELD">
<body>
<first>( begin auto-generated from mouseButton.xml ) Processing automatically tracks if the mouse button is pressed and which button is pressed.</first>
<full>
Processing automatically tracks if the mouse button is pressed and which button is pressed. The value of the system variable `mouseButton` is either `LEFT` , `RIGHT` , or `CENTER` depending on which button is pressed.

Advanced:
--------

If running on Mac OS, a ctrl-click will be interpreted as the right-hand mouse button (unlike Java, which reports it as the left mouse).
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mousePressed" kind="FIELD">
<body>
<first>( begin auto-generated from mousePressed_var.xml ) Variable storing if a mouse button is pressed.</first>
<full>
Variable storing if a mouse button is pressed. The value of the system variable `mousePressed` is true if a mouse button is pressed and false if a button is not pressed.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseEvent" kind="FIELD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@deprecated Use a mouse event handler that passes an event instead.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="key" kind="FIELD">
<body>
<first>( begin auto-generated from key.xml ) The system variable , `,key,` , always contains the value of the most recent key on the keyboard that was used (either pressed or released).</first>
<full>
The system variable `key` always contains the value of the most recent key on the keyboard that was used (either pressed or released).

For non-ASCII keys, use the `keyCode` variable. The keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if they key is coded, and you should simply use the `key` variable instead of `keyCode` If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix and the RETURN key is used instead on Macintosh. Check for both ENTER and RETURN to make sure your program will work for all platforms.

Advanced
--------

Last key pressed.

If it's a coded key, i.e. UP/DOWN/CTRL/SHIFT/ALT, this will be set to CODED (0xffff or 65535).
</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#keyCode</blocktag>
<blocktag>@see PApplet#keyPressed</blocktag>
<blocktag>@see PApplet#keyPressed()</blocktag>
<blocktag>@see PApplet#keyReleased()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyCode" kind="FIELD">
<body>
<first>( begin auto-generated from keyCode.xml ) The variable , `,keyCode,` , is used to detect special keys such as the UP, DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT.</first>
<full>
The variable `keyCode` is used to detect special keys such as the UP, DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking for these keys, it's first necessary to check and see if the key is coded. This is done with the conditional "if (key == CODED)" as shown in the example.

The keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if they key is coded, and you should simply use the `key` variable instead of `keyCode` If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix and the RETURN key is used instead on Macintosh. Check for both ENTER and RETURN to make sure your program will work for all platforms.

For users familiar with Java, the values for UP and DOWN are simply shorter versions of Java's KeyEvent.VK_UP and KeyEvent.VK_DOWN. Other keyCode values can be found in the Java&lt;a href="http://download.oracle.com/javase/6/docs/api/java/awt/event/KeyEvent.html"&gt;KeyEvent&lt;/a&gt;reference.

Advanced
--------

When "key" is set to CODED, this will contain a Java key code.

For the arrow keys, keyCode will be one of UP, DOWN, LEFT and RIGHT. Also available are ALT, CONTROL and SHIFT. A full set of constants can be obtained from java.awt.event.KeyEvent, from the VK_XXXX variables.
</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#key</blocktag>
<blocktag>@see PApplet#keyPressed</blocktag>
<blocktag>@see PApplet#keyPressed()</blocktag>
<blocktag>@see PApplet#keyReleased()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyPressed" kind="FIELD">
<body>
<first>( begin auto-generated from keyPressed_var.xml ) The boolean system variable , `,keyPressed,` , is , `,true,` , if any key is pressed and , `,false,` , if no keys are pressed.</first>
<full>
The boolean system variable `keyPressed` is `true` if any key is pressed and `false` if no keys are pressed.
</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#key</blocktag>
<blocktag>@see PApplet#keyCode</blocktag>
<blocktag>@see PApplet#keyPressed()</blocktag>
<blocktag>@see PApplet#keyReleased()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyEvent" kind="FIELD">
<body>
<first>The last KeyEvent object passed into a mouse function.</first>
<full>
The last KeyEvent object passed into a mouse function.
</full>
</body>
<blocktags>
<blocktag>@deprecated Use a key event handler that passes an event instead.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="focused" kind="FIELD">
<body>
<first>( begin auto-generated from focused.xml ) Confirms if a Processing program is "focused", meaning that it is active and will accept input from mouse or keyboard.</first>
<full>
Confirms if a Processing program is "focused", meaning that it is active and will accept input from mouse or keyboard. This variable is "true" if it is focused and "false" if not. This variable is often used when you want to warn people they need to click on or roll over an applet before it will work.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="millisOffset" kind="FIELD">
<body>
<first>Time in milliseconds when the applet was started.</first>
<full>
Time in milliseconds when the applet was started.

Used by the millis() function.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="frameRate" kind="FIELD">
<body>
<first>( begin auto-generated from frameRate_var.xml ) The system variable , `,frameRate,` , contains the approximate frame rate of the software as it executes.</first>
<full>
The system variable `frameRate` contains the approximate frame rate of the software as it executes. The initial value is 10 fps and is updated with each frame. The value is averaged (integrated) over several frames. As such, this value won't be valid until after 5-10 frames.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#frameRate(float)</blocktag>
<blocktag>@see PApplet#frameCount</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="redraw" kind="FIELD">
<body>
<first>flag set to true when a redraw is asked for by the user</first>
<full>
flag set to true when a redraw is asked for by the user
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="frameCount" kind="FIELD">
<body>
<first>( begin auto-generated from frameCount.xml ) The system variable , `,frameCount,` , contains the number of frames displayed since the program started.</first>
<full>
The system variable `frameCount` contains the number of frames displayed since the program started. Inside `setup()` the value is 0 and and after the first iteration of draw it is 1, etc.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#frameRate(float)</blocktag>
<blocktag>@see PApplet#frameRate</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="finished" kind="FIELD">
<body>
<first>true if the sketch has stopped permanently.</first>
<full>
true if the sketch has stopped permanently.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="uncaughtThrowable" kind="FIELD">
<body>
<first>used by the UncaughtExceptionHandler, so has to be static</first>
<full>
used by the UncaughtExceptionHandler, so has to be static
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exitCalled" kind="FIELD">
<body>
<first>true if exit() has been called so that things shut down once the main thread kicks off.</first>
<full>
true if exit() has been called so that things shut down once the main thread kicks off.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ARGS_EDITOR_LOCATION" kind="FIELD">
<body>
<first>Position of the upper-lefthand corner of the editor window that launched this applet.</first>
<full>
Position of the upper-lefthand corner of the editor window that launched this applet.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ARGS_LOCATION" kind="FIELD">
<body>
<first>Location for where to position the applet window on screen.</first>
<full>
Location for where to position the applet window on screen.

This is used by the editor to when saving the previous applet location, or could be used by other classes to launch at a specific position on-screen.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ARGS_DISPLAY" kind="FIELD">
<body>
<first>Used by the PDE to suggest a display (set in prefs, passed on Run)</first>
<full>
Used by the PDE to suggest a display (set in prefs, passed on Run)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ARGS_DISABLE_AWT" kind="FIELD">
<body>
<first>Disable AWT so that LWJGL and others can run</first>
<full>
Disable AWT so that LWJGL and others can run
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ARGS_SKETCH_FOLDER" kind="FIELD">
<body>
<first>Allows the user or PdeEditor to set a specific sketch folder path.</first>
<full>
Allows the user or PdeEditor to set a specific sketch folder path.

Used by PdeEditor to pass in the location where saveFrame() and all that stuff should write things.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="EXTERNAL_STOP" kind="FIELD">
<body>
<first>When run externally to a PdeEditor, this is sent by the sketch when it quits.</first>
<full>
When run externally to a PdeEditor, this is sent by the sketch when it quits.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="EXTERNAL_MOVE" kind="FIELD">
<body>
<first>When run externally to a PDE Editor, this is sent by the applet whenever the window is moved.</first>
<full>
When run externally to a PDE Editor, this is sent by the applet whenever the window is moved.

This is used so that the editor can re-open the sketch window in the same position as the user last left it.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="external" kind="FIELD">
<body>
<first>true if this sketch is being run by the PDE</first>
<full>
true if this sketch is being run by the PDE
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="insideSettings" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param method "size" or "fullScreen"</blocktag>
<blocktag>@param args parameters passed to the function so we can show the user</blocktag>
<blocktag>@return true if safely inside the settings() method</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="settings" kind="METHOD">
<body>
<first>( begin auto-generated from settings.xml ) Description to come...</first>
<full>
Description to come...  Override this method to call size() when not using the PDE.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#fullScreen()</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#size(int,int)</blocktag>
<blocktag>@see PApplet#smooth()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="displayDensity" kind="METHOD">
<body>
<first>( begin auto-generated from displayDensity.xml ) This function returns the number "2" if the screen is a high-density screen (called a Retina display on OS X or high-dpi on Windows and Linux) and a "1" if not.</first>
<full>
This function returns the number "2" if the screen is a high-density screen (called a Retina display on OS X or high-dpi on Windows and Linux) and a "1" if not. This information is useful for a program to adapt to run at double the pixel density on a screen that supports it.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#pixelDensity(int)</blocktag>
<blocktag>@see PApplet#size(int,int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="displayDensity" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param display the display number to check (1-indexed to match the Preferences dialog box)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pixelDensity" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param density 1 or 2</blocktag>
<blocktag>@see PApplet#pixelWidth</blocktag>
<blocktag>@see PApplet#pixelHeight</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="setSize" kind="METHOD">
<body>
<first>Called by PSurface objects to set the width and height variables, and update the pixelWidth and pixelHeight variables.</first>
<full>
Called by PSurface objects to set the width and height variables, and update the pixelWidth and pixelHeight variables.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="smooth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="smooth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param level either 2, 3, 4, or 8 depending on the renderer</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noSmooth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="start" kind="METHOD">
<body>
<first>Called by the browser or applet viewer to inform this applet that it should start its execution.</first>
<full>
Called by the browser or applet viewer to inform this applet that it should start its execution. It is called after the init method and each time the applet is revisited in a Web page.

Called explicitly via the first call to PApplet.paint(), because PAppletGL needs to have a usable screen before getting things rolling.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="stop" kind="METHOD">
<body>
<first>Called by the browser or applet viewer to inform this applet that it should stop its execution.</first>
<full>
Called by the browser or applet viewer to inform this applet that it should stop its execution.

Unfortunately, there are no guarantees from the Java spec when or if stop() will be called (i.e. on browser quit, or when moving between web pages), and it's not always called.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pause" kind="METHOD">
<body>
<first>Sketch has been paused.</first>
<full>
Sketch has been paused. Called when switching tabs in a browser or swapping to a different application on Android. Also called just before quitting. Use to safely disable things like serial, sound, or sensors.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="resume" kind="METHOD">
<body>
<first>Sketch has resumed.</first>
<full>
Sketch has resumed. Called when switching tabs in a browser or swapping to this application on Android. Also called on startup. Use this to safely disable things like serial, sound, or sensors.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="registerMap" kind="FIELD">
<body>
<first>Map of registered methods, stored by name.</first>
<full>
Map of registered methods, stored by name.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="registerLock" kind="FIELD">
<body>
<first>Lock when un/registering from multiple threads</first>
<full>
Lock when un/registering from multiple threads
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="registerMethod" kind="METHOD">
<body>
<first>Register a built-in event so that it can be fired for libraries, etc.</first>
<full>
Register a built-in event so that it can be fired for libraries, etc. Supported events include:&lt;ul&gt;&lt;li&gt;pre \u2013 at the very top of the draw() method (safe to draw)&lt;li&gt;draw \u2013 at the end of the draw() method (safe to draw)&lt;li&gt;post \u2013 after draw() has exited (not safe to draw)&lt;li&gt;pause \u2013 called when the sketch is paused&lt;li&gt;resume \u2013 called when the sketch is resumed&lt;li&gt;dispose \u2013 when the sketch is shutting down (definitely not safe to draw)&lt;ul&gt;In addition, the new (for 2.0) processing.event classes are passed to the following event types:&lt;ul&gt;&lt;li&gt;mouseEvent&lt;li&gt;keyEvent&lt;li&gt;touchEvent&lt;/ul&gt;The older java.awt events are no longer supported. See the Library Wiki page for more details.
</full>
</body>
<blocktags>
<blocktag>@param methodName name of the method to be called</blocktag>
<blocktag>@param target the target object that should receive the event</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="setup" kind="METHOD">
<body>
<first>( begin auto-generated from setup.xml ) The , `,setup(),` , function is called once when the program starts.</first>
<full>
The `setup()` function is called once when the program starts. It's used to define initial enviroment properties such as screen size and background color and to load media such as images and fonts as the program starts. There can only be one `setup()` function for each program and it shouldn't be called again after its initial execution. Note: Variables declared within `setup()` are not accessible within other functions, including `draw()` .
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#size(int, int)</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="draw" kind="METHOD">
<body>
<first>( begin auto-generated from draw.xml ) Called directly after , `,setup(),` , and continuously executes the lines of code contained inside its block until the program is stopped or , `,noLoop(),` , is called.</first>
<full>
Called directly after `setup()` and continuously executes the lines of code contained inside its block until the program is stopped or `noLoop()` is called. The `draw()` function is called automatically and should never be called explicitly. It should always be controlled with `noLoop()` , `redraw()` and `loop()` . After `noLoop()` stops the code in `draw()` from executing, `redraw()` causes the code inside `draw()` to execute once and `loop()` will causes the code inside `draw()` to execute continuously again. The number of times `draw()` executes in each second may be controlled with `frameRate()` function. There can only be one `draw()` function for each sketch and `draw()` must exist if you want the code to run continuously or to process events such as `mousePressed()` . Sometimes, you might have an empty call to `draw()` in your program as shown in the above example.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
<blocktag>@see PApplet#redraw()</blocktag>
<blocktag>@see PApplet#frameRate(float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fullScreen" kind="METHOD">
<body>
<first>Create a full-screen sketch using the default renderer.</first>
<full>
Create a full-screen sketch using the default renderer.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fullScreen" kind="METHOD">
<body>
<first>( begin auto-generated from fullScreen.xml ) Description to come...</first>
<full>
Description to come...
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param renderer the renderer to use, e.g. P2D, P3D, JAVA2D (default)</blocktag>
<blocktag>@see PApplet#settings()</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#size(int,int)</blocktag>
<blocktag>@see PApplet#smooth()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fullScreen" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param display the screen to run the sketch on (1, 2, 3, etc. or on multiple screens using SPAN)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="size" kind="METHOD">
<body>
<first>( begin auto-generated from size.xml ) Defines the dimension of the display window in units of pixels.</first>
<full>
Defines the dimension of the display window in units of pixels. The `size()` function must be the first line in `setup()` . If `size()` is not used, the default size of the window is 100x100 pixels. The system variables `width` and `height` are set by the parameters passed to this function.

Do not use variables as the parameters to `size()` function, because it will cause problems when exporting your sketch. When variables are used, the dimensions of your sketch cannot be determined during export. Instead, employ numeric values in the `size()` statement, and then use the built-in `width` and `height` variables inside your program when the dimensions of the display window are needed.

The `size()` function can only be used once inside a sketch, and cannot be used for resizing.

 `renderer` parameter selects which rendering engine to use. For example, if you will be drawing 3D shapes, use `P3D` , if you want to export images from a program as a PDF file use `PDF` . A brief description of the three primary renderers follows:

 `P2D` (Processing 2D) - The default renderer that supports two dimensional drawing.

 `P3D` (Processing 3D) - 3D graphics renderer that makes use of OpenGL-compatible graphics hardware.

 `PDF` - The PDF renderer draws 2D graphics directly to an Acrobat PDF file. This produces excellent results when you need vector shapes for high resolution output or printing. You must first use Import LibraryPDF to make use of the library. More information can be found in the PDF library reference.

The P3D renderer doesn't support `strokeCap()` or `strokeJoin()` , which can lead to ugly results when using `strokeWeight()` . (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;Issue 123&lt;/a&gt;)

The maximum width and height is limited by your operating system, and is usually the width and height of your actual screen. On some machines it may simply be the number of pixels on your current screen, meaning that a screen of 800x600 could support `size(1600, 300)` , since it's the same number of pixels. This varies widely so you'll have to try different rendering modes and sizes until you get what you're looking for. If you need something larger, use `createGraphics` to create a non-visible drawing surface.

Again, the `size()` function must be the first line of the code (or first item inside setup). Any code that appears before the `size()` command may run more than once, which can lead to confusing results.

Advanced
--------

If using Java 1.3 or later, this will default to using PGraphics2, the Java2D-based renderer. If using Java 1.1, or if PGraphics2 is not available, then PGraphics will be used. To set your own renderer, use the other version of the size() method that takes a renderer as its last parameter.

If called once a renderer has already been set, this will use the previous renderer and simply resize it.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param width width of the display window in units of pixels</blocktag>
<blocktag>@param height height of the display window in units of pixels</blocktag>
<blocktag>@see PApplet#width</blocktag>
<blocktag>@see PApplet#height</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#settings()</blocktag>
<blocktag>@see PApplet#fullScreen()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="size" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createGraphics" kind="METHOD">
<body>
<first>( begin auto-generated from createGraphics.xml ) Creates and returns a new , `,PGraphics,` , object of the types P2D or P3D.</first>
<full>
Creates and returns a new `PGraphics` object of the types P2D or P3D. Use this class if you need to draw into an off-screen graphics buffer. The PDF renderer requires the filename parameter. The DXF renderer should not be used with `createGraphics()` , it's only built for use with `beginRaw()` and `endRaw()` .

It's important to call any drawing functions between `beginDraw()` and `endDraw()` statements. This is also true for any functions that affect drawing, such as `smooth()` or `colorMode()` .

the main drawing surface which is completely opaque, surfaces created with `createGraphics()` can have transparency. This makes it possible to draw into a graphics and maintain the alpha channel. By using `save()` to write a PNG or TGA file, the transparency of the graphics object will be honored. Note that transparency levels are binary: pixels are either complete opaque or transparent. For the time being, this means that text characters will be opaque blocks. This will be fixed in a future release (&lt;a href="http://code.google.com/p/processing/issues/detail?id=80"&gt;Issue 80&lt;/a&gt;).

Advanced
--------

Create an offscreen PGraphics object for drawing. This can be used for bitmap or vector images drawing or rendering.

* Do not use "new PGraphicsXxxx()", use this method. This method ensures that internal variables are set up properly that tie the new graphics context back to its parent PApplet.
* The basic way to create bitmap images is to use the&lt;A HREF="http://processing.org/reference/saveFrame_.html"&gt;saveFrame()&lt;/A&gt;function.
* If you want to create a really large scene and write that, first make sure that you've allocated a lot of memory in the Preferences.
* If you want to create images that are larger than the screen, you should create your own PGraphics object, draw to that, and use&lt;A HREF="http://processing.org/reference/save_.html"&gt;save()&lt;/A&gt;.

```
PGraphics big; void setup() {   big = createGraphics(3000, 3000);   big.beginDraw();   big.background(128);   big.line(20, 1800, 1800, 900);   // etc..   big.endDraw();   // make sure the file is written to the sketch folder   big.save("big.tif"); }
```


* It's important to always wrap drawing to createGraphics() with beginDraw() and endDraw() (beginFrame() and endFrame() prior to revision 0115). The reason is that the renderer needs to know when drawing has stopped, so that it can update itself internally. This also handles calling the defaults() method, for people familiar with that.
* With Processing 0115 and later, it's possible to write images in formats other than the default .tga and .tiff. The exact formats and background information can be found in the developer's reference for&lt;A HREF="http://dev.processing.org/reference/core/javadoc/processing/core/PImage.html#save(java.lang.String)"&gt;PImage.save()&lt;/A&gt;.

</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param w width in pixels</blocktag>
<blocktag>@param h height in pixels</blocktag>
<blocktag>@param renderer Either P2D, P3D, or PDF</blocktag>
<blocktag>@see PGraphics#PGraphics</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createGraphics" kind="METHOD">
<body>
<first>Create an offscreen graphics surface for drawing, in this case for a renderer that writes to a file (such as PDF or DXF).</first>
<full>
Create an offscreen graphics surface for drawing, in this case for a renderer that writes to a file (such as PDF or DXF).
</full>
</body>
<blocktags>
<blocktag>@param path the name of the file (can be an absolute or relative path)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="makeGraphics" kind="METHOD">
<body>
<first>Version of createGraphics() used internally.</first>
<full>
Version of createGraphics() used internally.
</full>
</body>
<blocktags>
<blocktag>@param path A path (or null if none), can be absolute or relative ({@link PApplet#savePath} will be called)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createPrimaryGraphics" kind="METHOD">
<body>
<first>Create default renderer, likely to be resized, but needed for surface init.</first>
<full>
Create default renderer, likely to be resized, but needed for surface init.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createImage" kind="METHOD">
<body>
<first>( begin auto-generated from createImage.xml ) Creates a new PImage (the datatype for storing images).</first>
<full>
Creates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play with. Set the size of the buffer with the `width` and `height` parameters. The `format` parameter defines how the pixels are stored. See the PImage reference for more information.

Be sure to include all three parameters, specifying only the width and height (but no format) will produce a strange error.

Advanced users please note that createImage() should be used instead of the syntax&lt;tt&gt;new PImage()&lt;/tt&gt;.

Advanced
--------

Preferred method of creating new PImage objects, ensures that a reference to the parent PApplet is included, which makes save() work without needing an absolute path.
</full>
</body>
<blocktags>
<blocktag>@webref image</blocktag>
<blocktag>@param w width in pixels</blocktag>
<blocktag>@param h height in pixels</blocktag>
<blocktag>@param format Either RGB, ARGB, ALPHA (grayscale alpha channel)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="frameRateLastNanos" kind="FIELD">
<body>
<first>Last time in nanoseconds that frameRate was checked</first>
<full>
Last time in nanoseconds that frameRate was checked
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="redraw" kind="METHOD">
<body>
<first>( begin auto-generated from redraw.xml ) Executes the code within , `,draw(),` , one time.</first>
<full>
Executes the code within `draw()` one time. This functions allows the program to update the display window only when necessary, for example when an event registered by `mousePressed()` or `keyPressed()` occurs.

structuring a program, it only makes sense to call redraw() within events such as `mousePressed()` . This is because `redraw()` does not run `draw()` immediately (it only sets a flag that indicates an update is needed).

 `redraw()` within `draw()` has no effect because `draw()` is continuously called anyway.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
<blocktag>@see PApplet#frameRate(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loop" kind="METHOD">
<body>
<first>( begin auto-generated from loop.xml ) Causes Processing to continuously execute the code within , `,draw(),` ,.</first>
<full>
Causes Processing to continuously execute the code within `draw()` . If `noLoop()` is called, the code in `draw()` stops executing.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
<blocktag>@see PApplet#redraw()</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noLoop" kind="METHOD">
<body>
<first>( begin auto-generated from noLoop.xml ) Stops Processing from continuously executing the code within , `,draw(),` ,.</first>
<full>
Stops Processing from continuously executing the code within `draw()` . If `loop()` is called, the code in `draw()` begin to run continuously again. If using `noLoop()` in `setup()` , it should be the last line inside the block.

When `noLoop()` is used, it's not possible to manipulate or access the screen inside event handling functions such as `mousePressed()` or `keyPressed()` . Instead, use those functions to call `redraw()` or `loop()` , which will run `draw()` , which can update the screen properly. This means that when noLoop() has been called, no drawing can happen, and functions like saveFrame() or loadPixels() may not be used.

Note that if the sketch is resized, `redraw()` will be called to update the sketch, even after `noLoop()` has been specified. Otherwise, the sketch would enter an odd state until `loop()` was called.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#redraw()</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="postEvent" kind="METHOD">
<body>
<first>Add an event to the internal event queue, or process it immediately if the sketch is not currently looping.</first>
<full>
Add an event to the internal event queue, or process it immediately if the sketch is not currently looping.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="handleMouseEvent" kind="METHOD">
<body>
<first>Actually take action based on a mouse event.</first>
<full>
Actually take action based on a mouse event. Internally updates mouseX, mouseY, mousePressed, and mouseEvent. Then it calls the event type with no params, i.e. mousePressed() or mouseReleased() that the user may have overloaded to do something more useful.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mousePressed" kind="METHOD">
<body>
<first>( begin auto-generated from mousePressed.xml ) The , `,mousePressed(),` , function is called once after every time a mouse button is pressed.</first>
<full>
The `mousePressed()` function is called once after every time a mouse button is pressed. The `mouseButton` variable (see the related reference entry) can be used to determine which button has been pressed.

Advanced
--------

If you must, use int button = mouseEvent.getButton(); to figure out which button was clicked. It will be one of: MouseEvent.BUTTON1, MouseEvent.BUTTON2, MouseEvent.BUTTON3 Note, however, that this is completely inconsistent across platforms.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseReleased" kind="METHOD">
<body>
<first>( begin auto-generated from mouseReleased.xml ) The , `,mouseReleased(),` , function is called every time a mouse button is released.</first>
<full>
The `mouseReleased()` function is called every time a mouse button is released.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseClicked" kind="METHOD">
<body>
<first>( begin auto-generated from mouseClicked.xml ) The , `,mouseClicked(),` , function is called once after a mouse button has been pressed and then released.</first>
<full>
The `mouseClicked()` function is called once after a mouse button has been pressed and then released.

Advanced
--------

When the mouse is clicked, mousePressed() will be called, then mouseReleased(), then mouseClicked(). Note that mousePressed is already false inside of mouseClicked().
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseDragged" kind="METHOD">
<body>
<first>( begin auto-generated from mouseDragged.xml ) The , `,mouseDragged(),` , function is called once every time the mouse moves and a mouse button is pressed.</first>
<full>
The `mouseDragged()` function is called once every time the mouse moves and a mouse button is pressed.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseMoved" kind="METHOD">
<body>
<first>( begin auto-generated from mouseMoved.xml ) The , `,mouseMoved(),` , function is called every time the mouse moves and a mouse button is not pressed.</first>
<full>
The `mouseMoved()` function is called every time the mouse moves and a mouse button is not pressed.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
<blocktag>@see PApplet#mouseWheel(MouseEvent)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseWheel" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mouseWheel" kind="METHOD">
<body>
<first>The event.getAmount() method returns negative values if the mouse wheel if rotated up or away from the user and positive in the other direction.</first>
<full>
The event.getAmount() method returns negative values if the mouse wheel if rotated up or away from the user and positive in the other direction. On OS X with "natural" scrolling enabled, the values are opposite.
</full>
</body>
<blocktags>
<blocktag>@webref input:mouse</blocktag>
<blocktag>@param event the MouseEvent</blocktag>
<blocktag>@see PApplet#mouseX</blocktag>
<blocktag>@see PApplet#mouseY</blocktag>
<blocktag>@see PApplet#pmouseX</blocktag>
<blocktag>@see PApplet#pmouseY</blocktag>
<blocktag>@see PApplet#mousePressed</blocktag>
<blocktag>@see PApplet#mousePressed()</blocktag>
<blocktag>@see PApplet#mouseReleased()</blocktag>
<blocktag>@see PApplet#mouseClicked()</blocktag>
<blocktag>@see PApplet#mouseMoved()</blocktag>
<blocktag>@see PApplet#mouseDragged()</blocktag>
<blocktag>@see PApplet#mouseButton</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyPressed" kind="METHOD">
<body>
<first>( begin auto-generated from keyPressed.xml ) The , `,keyPressed(),` , function is called once every time a key is pressed.</first>
<full>
The `keyPressed()` function is called once every time a key is pressed. The key that was pressed is stored in the `key` variable.

For non-ASCII keys, use the `keyCode` variable. The keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if they key is coded, and you should simply use the `key` variable instead of `keyCode` If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix and the RETURN key is used instead on Macintosh. Check for both ENTER and RETURN to make sure your program will work for all platforms.

Because of how operating systems handle key repeats, holding down a key may cause multiple calls to keyPressed() (and keyReleased() as well). The rate of repeat is set by the operating system and how each computer is configured.

Advanced
--------

Called each time a single key on the keyboard is pressed. Because of how operating systems handle key repeats, holding down a key will cause multiple calls to keyPressed(), because the OS repeat takes over.

Examples for key handling: (Tested on Windows XP, please notify if different on other platforms, I have a feeling Mac OS and Linux may do otherwise)

```
1. Pressing 'a' on the keyboard:    keyPressed  with key == 'a' and keyCode == 'A'    keyTyped    with key == 'a' and keyCode ==  0    keyReleased with key == 'a' and keyCode == 'A' 2. Pressing 'A' on the keyboard:    keyPressed  with key == 'A' and keyCode == 'A'    keyTyped    with key == 'A' and keyCode ==  0    keyReleased with key == 'A' and keyCode == 'A' 3. Pressing 'shift', then 'a' on the keyboard (caps lock is off):    keyPressed  with key == CODED and keyCode == SHIFT    keyPressed  with key == 'A'   and keyCode == 'A'    keyTyped    with key == 'A'   and keyCode == 0    keyReleased with key == 'A'   and keyCode == 'A'    keyReleased with key == CODED and keyCode == SHIFT 4. Holding down the 'a' key.    The following will happen several times,    depending on your machine's "key repeat rate" settings:    keyPressed  with key == 'a' and keyCode == 'A'    keyTyped    with key == 'a' and keyCode ==  0    When you finally let go, you'll get:    keyReleased with key == 'a' and keyCode == 'A' 5. Pressing and releasing the 'shift' key    keyPressed  with key == CODED and keyCode == SHIFT    keyReleased with key == CODED and keyCode == SHIFT    (note there is no keyTyped) 6. Pressing the tab key in an applet with Java 1.4 will    normally do nothing, but PApplet dynamically shuts    this behavior off if Java 1.4 is in use (tested 1.4.2_05 Windows).    Java 1.1 (Microsoft VM) passes the TAB key through normally.    Not tested on other platforms or for 1.3.
```


</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#key</blocktag>
<blocktag>@see PApplet#keyCode</blocktag>
<blocktag>@see PApplet#keyPressed</blocktag>
<blocktag>@see PApplet#keyReleased()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyReleased" kind="METHOD">
<body>
<first>( begin auto-generated from keyReleased.xml ) The , `,keyReleased(),` , function is called once every time a key is released.</first>
<full>
The `keyReleased()` function is called once every time a key is released. The key that was released will be stored in the `key` variable. See `key` and `keyReleased` for more information.
</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#key</blocktag>
<blocktag>@see PApplet#keyCode</blocktag>
<blocktag>@see PApplet#keyPressed</blocktag>
<blocktag>@see PApplet#keyPressed()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="keyTyped" kind="METHOD">
<body>
<first>( begin auto-generated from keyTyped.xml ) The , `,keyTyped(),` , function is called once every time a key is pressed, but action keys such as Ctrl, Shift, and Alt are ignored.</first>
<full>
The `keyTyped()` function is called once every time a key is pressed, but action keys such as Ctrl, Shift, and Alt are ignored. Because of how operating systems handle key repeats, holding down a key will cause multiple calls to `keyTyped()` , the rate is set by the operating system and how each computer is configured.
</full>
</body>
<blocktags>
<blocktag>@webref input:keyboard</blocktag>
<blocktag>@see PApplet#keyPressed</blocktag>
<blocktag>@see PApplet#key</blocktag>
<blocktag>@see PApplet#keyCode</blocktag>
<blocktag>@see PApplet#keyReleased()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="millis" kind="METHOD">
<body>
<first>( begin auto-generated from millis.xml ) Returns the number of milliseconds (thousandths of a second) since starting an applet.</first>
<full>
Returns the number of milliseconds (thousandths of a second) since starting an applet. This information is often used for timing animation sequences.

Advanced
--------



This is a function, rather than a variable, because it may change multiple times per frame.
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="second" kind="METHOD">
<body>
<first>( begin auto-generated from second.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `second()` function returns the current second as a value from 0 - 59.
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="minute" kind="METHOD">
<body>
<first>( begin auto-generated from minute.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `minute()` function returns the current minute as a value from 0 - 59.
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="hour" kind="METHOD">
<body>
<first>( begin auto-generated from hour.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `hour()` function returns the current hour as a value from 0 - 23.
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="day" kind="METHOD">
<body>
<first>( begin auto-generated from day.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `day()` function returns the current day as a value from 1 - 31.

Advanced
--------

Get the current day of the month (1 through 31).

If you're looking for the day of the week (M-F or whatever) or day of the year (1..365) then use java's Calendar.get()
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="month" kind="METHOD">
<body>
<first>( begin auto-generated from month.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `month()` function returns the current month as a value from 1 - 12.
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#year()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="year" kind="METHOD">
<body>
<first>( begin auto-generated from year.xml ) Processing communicates with the clock on your computer.</first>
<full>
Processing communicates with the clock on your computer. The `year()` function returns the current year as an integer (2003, 2004, 2005, etc).  The `year()` function returns the current year as an integer (2003, 2004, 2005, etc).
</full>
</body>
<blocktags>
<blocktag>@webref input:time_date</blocktag>
<blocktag>@see PApplet#millis()</blocktag>
<blocktag>@see PApplet#second()</blocktag>
<blocktag>@see PApplet#minute()</blocktag>
<blocktag>@see PApplet#hour()</blocktag>
<blocktag>@see PApplet#day()</blocktag>
<blocktag>@see PApplet#month()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="delay" kind="METHOD">
<body>
<first>( begin auto-generated from delay.xml ) The delay() function causes the program to halt for a specified time.</first>
<full>
The delay() function causes the program to halt for a specified time. Delay times are specified in thousandths of a second. For example, running delay(3000) will stop the program for three seconds and delay(500) will stop the program for a half-second. The screen only updates when the end of draw() is reached, so delay() cannot be used to slow down drawing. For instance, you cannot use delay() to control the timing of an animation. The delay() function should only be used for pausing scripts (i.e. a script that needs to pause a few seconds before attempting a download, or a sketch that needs to wait a few milliseconds before reading from the serial port).
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param napTime milliseconds to pause before running draw() again</blocktag>
<blocktag>@see PApplet#frameRate</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="frameRate" kind="METHOD">
<body>
<first>( begin auto-generated from frameRate.xml ) Specifies the number of frames to be displayed every second.</first>
<full>
Specifies the number of frames to be displayed every second. If the processor is not fast enough to maintain the specified rate, it will not be achieved. For example, the function call `frameRate(30)` will attempt to refresh 30 times a second. It is recommended to set the frame rate within `setup()` . The default rate is 60 frames per second.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@param fps number of desired frames per second</blocktag>
<blocktag>@see PApplet#frameRate</blocktag>
<blocktag>@see PApplet#frameCount</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
<blocktag>@see PApplet#redraw()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="link" kind="METHOD">
<body>
<first>Links to a webpage either in the same window or in a new window.</first>
<full>
Links to a webpage either in the same window or in a new window. The complete URL must be specified.

Advanced
--------

Link to an external page without all the muss.

When run with an applet, uses the browser to open the url, for applications, attempts to launch a browser with the url.
</full>
</body>
<blocktags>
<blocktag>@param url the complete URL, as a String in quotes</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="launch" kind="METHOD">
<body>
<first>( begin auto-generated from launch.xml ) Attempts to open an application or file using your platform's launcher.</first>
<full>
Attempts to open an application or file using your platform's launcher. The `file` parameter is a String specifying the file name and location. The location parameter must be a full path name, or the name of an executable in the system's PATH. In most cases, using a full path is the best option, rather than relying on the system PATH. Be sure to make the file executable before attempting to open it (chmod +x).

The `args` parameter is a String or String array which is passed to the command line. If you have multiple parameters, e.g. an application and a document, or a command with multiple switches, use the version that takes a String array, and place each individual item in a separate element.

If args is a String (not an array), then it can only be a single file or application with no parameters. It's not the same as executing that String using a shell. For instance, launch("javac -help") will not work properly.

This function behaves differently on each platform. On Windows, the parameters are sent to the Windows shell via "cmd /c". On Mac OS X, the "open" command is used (type "man open" in Terminal.app for documentation). On Linux, it first tries gnome-open, then kde-open, but if neither are available, it sends the command to the shell without any alterations.

For users familiar with Java, this is not quite the same as Runtime.exec(), because the launcher command is prepended. Instead, the `exec(String[])` function is a shortcut for Runtime.getRuntime.exec(String[]).
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param args arguments to the launcher, eg. a filename.</blocktag>
<blocktag>@usage Application</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exec" kind="METHOD">
<body>
<first>Pass a set of arguments directly to the command line.</first>
<full>
Pass a set of arguments directly to the command line. Uses Java's&lt;A HREF="https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#exec-java.lang.String:A-"&gt;Runtime.exec()&lt;/A&gt;method. This is different from the&lt;A HREF="https://processing.org/reference/launch_.html"&gt;launch()&lt;/A&gt;method, which uses the operating system's launcher to open the files. It's always a good idea to use a full path to the executable here.&lt;pre&gt;exec("/usr/bin/say", "welcome to the command line");&lt;/pre&gt;Or if you want to wait until it's completed, something like this:&lt;pre&gt;Process p = exec("/usr/bin/say", "waiting until done"); try {   int result = p.waitFor();   println("the process returned " + result); } catch (InterruptedException e) { }&lt;/pre&gt;You can also get the system output and error streams from the Process object, but that's more that we'd like to cover here.
</full>
</body>
<blocktags>
<blocktag>@return a &lt;A HREF="https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html"&gt;Process&lt;/A&gt; object</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exec" kind="METHOD">
<body>
<first>Alternative version of exec() that retrieves stdout and stderr into the StringList objects provided.</first>
<full>
Alternative version of exec() that retrieves stdout and stderr into the StringList objects provided. This is a convenience function that handles simple exec() calls. If the results will be more than a couple lines, you shouldn't use this function, you should use a more elaborate method that makes use of proper threading (to drain the shell output) and error handling to address the many things that can go wrong within this method.
</full>
</body>
<blocktags>
<blocktag>@param stdout a non-null StringList object to be filled with any output</blocktag>
<blocktag>@param stderr a non-null StringList object to be filled with error lines</blocktag>
<blocktag>@param args each argument to be passed as a series of String objects</blocktag>
<blocktag>@return the result returned from the application, or -1 if an Exception         occurs before the application is able to return a result.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shell" kind="METHOD">
<body>
<first>Same as exec() above, but prefixes the call with a shell.</first>
<full>
Same as exec() above, but prefixes the call with a shell.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="printStackTrace" kind="METHOD">
<body>
<first>Better way of handling e.printStackTrace() calls so that they can be handled by subclasses as necessary.</first>
<full>
Better way of handling e.printStackTrace() calls so that they can be handled by subclasses as necessary.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="die" kind="METHOD">
<body>
<first>Function for an applet/application to kill itself and display an error.</first>
<full>
Function for an applet/application to kill itself and display an error. Mostly this is here to be improved later.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="die" kind="METHOD">
<body>
<first>Same as above but with an exception.</first>
<full>
Same as above but with an exception. Also needs work.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exit" kind="METHOD">
<body>
<first>( begin auto-generated from exit.xml ) Quits/stops/exits the program.</first>
<full>
Quits/stops/exits the program. Programs without a `draw()` function exit automatically after the last line has run, but programs with `draw()` run continuously until the program is manually stopped or `exit()` is run.

Rather than terminating immediately, `exit()` will cause the sketch to exit after `draw()` has completed (or after `setup()` completes if called during the `setup()` function).

For Java programmers, this is&lt;em&gt;not&lt;/em&gt;the same as System.exit(). Further, System.exit() should not be used because closing out an application while `draw()` is running may cause a crash (particularly with P3D).
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exitActual" kind="METHOD">
<body>
<first>Some subclasses (I'm looking at you, processing.py) might wish to do something other than actually terminate the JVM.</first>
<full>
Some subclasses (I'm looking at you, processing.py) might wish to do something other than actually terminate the JVM. This gives them a chance to do whatever they have in mind when cleaning up.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dispose" kind="METHOD">
<body>
<first>Called to dispose of resources and shut down the sketch.</first>
<full>
Called to dispose of resources and shut down the sketch. Destroys the thread, dispose the renderer,and notify listeners.

Not to be called or overriden by users. If called multiple times, will only notify listeners once. Register a dispose listener instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="method" kind="METHOD">
<body>
<first>Call a method in the current class based on its name.</first>
<full>
Call a method in the current class based on its name.

Note that the function being called must be public. Inside the PDE, 'public' is automatically added, but when used without the preprocessor, (like from Eclipse) you'll have to do it yourself.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="thread" kind="METHOD">
<body>
<first>Launch a new thread and call the specified function from that new thread.</first>
<full>
Launch a new thread and call the specified function from that new thread. This is a very simple way to do a thread without needing to get into classes, runnables, etc.

Note that the function being called must be public. Inside the PDE, 'public' is automatically added, but when used without the preprocessor, (like from Eclipse) you'll have to do it yourself.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@usage Application</blocktag>
<blocktag>@param name name of the function to be executed in a separate thread</blocktag>
<blocktag>@see PApplet#setup()</blocktag>
<blocktag>@see PApplet#draw()</blocktag>
<blocktag>@see PApplet#loop()</blocktag>
<blocktag>@see PApplet#noLoop()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="save" kind="METHOD">
<body>
<first>( begin auto-generated from save.xml ) Saves an image from the display window.</first>
<full>
Saves an image from the display window. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on the extension within the `filename` parameter. For example, "image.tif" will have a TIFF image and "image.png" will save a PNG image. If no extension is included in the filename, the image will save in TIFF format and `.tif` will be added to the name. These files are saved to the sketch's folder, which may be opened by selecting "Show sketch folder" from the "Sketch" menu. It is not possible to use `save()` while running the program in a web browser.
images saved from the main drawing window will be opaque. To save images without a background, use `createGraphics()` .
</full>
</body>
<blocktags>
<blocktag>@webref output:image</blocktag>
<blocktag>@param filename any sequence of letters and numbers</blocktag>
<blocktag>@see PApplet#saveFrame()</blocktag>
<blocktag>@see PApplet#createGraphics(int, int, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveFrame" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveFrame" kind="METHOD">
<body>
<first>( begin auto-generated from saveFrame.xml ) Saves a numbered sequence of images, one image each time the function is run.</first>
<full>
Saves a numbered sequence of images, one image each time the function is run. To save an image that is identical to the display window, run the function at the end of `draw()` or within mouse and key events such as `mousePressed()` and `keyPressed()` . If `saveFrame()` is called without parameters, it will save the files as screen-0000.tif, screen-0001.tif, etc. It is possible to specify the name of the sequence with the `filename` parameter and make the choice of saving TIFF, TARGA, PNG, or JPEG files with the `ext` parameter. These image sequences can be loaded into programs such as Apple's QuickTime software and made into movies. These files are saved to the sketch's folder, which may be opened by selecting "Show sketch folder" from the "Sketch" menu.

It is not possible to use saveXxxxx() functions inside a web browser unless the sketch is&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/A&gt;. To save a file back to a server, see the&lt;a href="http://wiki.processing.org/w/Saving_files_to_a_web-server"&gt;save to web&lt;/A&gt;code snippet on the Processing Wiki.
&lt;br/&gt;All images saved from the main drawing window will be opaque. To save images without a background, use `createGraphics()` .
</full>
</body>
<blocktags>
<blocktag>@webref output:image</blocktag>
<blocktag>@see PApplet#save(String)</blocktag>
<blocktag>@see PApplet#createGraphics(int, int, String, String)</blocktag>
<blocktag>@see PApplet#frameCount</blocktag>
<blocktag>@param filename any sequence of letters or numbers that ends with either ".tif", ".tga", ".jpg", or ".png"</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="insertFrame" kind="METHOD">
<body>
<first>Check a string for #### signs to see if the frame number should be inserted.</first>
<full>
Check a string for #### signs to see if the frame number should be inserted. Used for functions like saveFrame() and beginRecord() to replace the # marks with the frame number. If only one # is used, it will be ignored, under the assumption that it's probably not intended to be the frame number.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="cursor" kind="METHOD">
<body>
<first>Set the cursor type</first>
<full>
Set the cursor type
</full>
</body>
<blocktags>
<blocktag>@param kind either ARROW, CROSS, HAND, MOVE, TEXT, or WAIT</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="cursor" kind="METHOD">
<body>
<first>Replace the cursor with the specified PImage.</first>
<full>
Replace the cursor with the specified PImage. The x- and y- coordinate of the center will be the center of the image.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="cursor" kind="METHOD">
<body>
<first>( begin auto-generated from cursor.xml ) Sets the cursor to a predefined symbol, an image, or makes it visible if already hidden.</first>
<full>
Sets the cursor to a predefined symbol, an image, or makes it visible if already hidden. If you are trying to set an image as the cursor, it is recommended to make the size 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are exporting your program for the Web and not all MODES work with all Web browsers. The values for parameters `x` and `y` must be less than the dimensions of the image.

Setting or hiding the cursor generally does not work with "Present" mode (when running full-screen).

Advanced
--------

Set a custom cursor to an image with a specific hotspot. Only works with JDK 1.2 and later. Currently seems to be broken on Java 1.4 for Mac OS X

Based on code contributed by Amit Pitaru, plus additional code to handle Java versions via reflection by Jonathan Feinberg. Reflection removed for release 0128 and later.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#noCursor()</blocktag>
<blocktag>@param img any variable of type PImage</blocktag>
<blocktag>@param x the horizontal active spot of the cursor</blocktag>
<blocktag>@param y the vertical active spot of the cursor</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="cursor" kind="METHOD">
<body>
<first>Show the cursor after noCursor() was called.</first>
<full>
Show the cursor after noCursor() was called. Notice that the program remembers the last set cursor type
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noCursor" kind="METHOD">
<body>
<first>( begin auto-generated from noCursor.xml ) Hides the cursor from view.</first>
<full>
Hides the cursor from view. Will not work when running the program in a web browser or when running in full screen (Present) mode.

Advanced
--------

Hide the cursor by creating a transparent image and using it as a custom cursor.
</full>
</body>
<blocktags>
<blocktag>@webref environment</blocktag>
<blocktag>@see PApplet#cursor()</blocktag>
<blocktag>@usage Application</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="print" kind="METHOD">
<body>
<first>( begin auto-generated from print.xml ) Writes to the console area of the Processing environment.</first>
<full>
Writes to the console area of the Processing environment. This is often helpful for looking at the data a program is producing. The companion function `println()` works like `print()` , but creates a new line of text for each call to the function. Individual elements can be separated with quotes ("") and joined with the addition operator (+).

Beginning with release 0125, to print the contents of an array, use println(). There's no sensible way to do a `print()` of an array, because there are too many possibilities for how to separate the data (spaces, commas, etc). If you want to print an array as a single line, use `join()` . With `join()` , you can choose any delimiter you like and `print()` the result.

Using `print()` on an object will output `null` , a memory location that may look like "@10be08," or the result of the `toString()` method from the object that's being printed. Advanced users who want more useful output when calling `print()` on their own classes can add a `toString()` method to the class that returns a String.
</full>
</body>
<blocktags>
<blocktag>@webref output:text_area</blocktag>
<blocktag>@usage IDE</blocktag>
<blocktag>@param what data to print to console</blocktag>
<blocktag>@see PApplet#println()</blocktag>
<blocktag>@see PApplet#printArray(Object)</blocktag>
<blocktag>@see PApplet#join(String[], char)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="print" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param variables list of data, separated by commas</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="println" kind="METHOD">
<body>
<first>( begin auto-generated from println.xml ) Writes to the text area of the Processing environment's console.</first>
<full>
Writes to the text area of the Processing environment's console. This is often helpful for looking at the data a program is producing. Each call to this function creates a new line of output. Individual elements can be separated with quotes ("") and joined with the string concatenation operator (+). See `print()` for more about what to expect in the output.

 `println()` on an array (by itself) will write the contents of the array to the console. This is often helpful for looking at the data a program is producing. A new line is put between each element of the array. This function can only print one dimensional arrays. For arrays with higher dimensions, the result will be closer to that of `print()` .
</full>
</body>
<blocktags>
<blocktag>@webref output:text_area</blocktag>
<blocktag>@usage IDE</blocktag>
<blocktag>@see PApplet#print(byte)</blocktag>
<blocktag>@see PApplet#printArray(Object)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="println" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param what data to print to console</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="println" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param variables list of data, separated by commas</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="println" kind="METHOD">
<body>
<first>For arrays, use printArray() instead.</first>
<full>
For arrays, use printArray() instead. This function causes a warning because the new print(Object...) and println(Object...) functions can't be reliably bound by the compiler.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="printArray" kind="METHOD">
<body>
<first>( begin auto-generated from printArray.xml ) To come...</first>
<full>
To come...
</full>
</body>
<blocktags>
<blocktag>@webref output:text_area</blocktag>
<blocktag>@param what one-dimensional array</blocktag>
<blocktag>@usage IDE</blocktag>
<blocktag>@see PApplet#print(byte)</blocktag>
<blocktag>@see PApplet#println()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="abs" kind="METHOD">
<body>
<first>( begin auto-generated from abs.xml ) Calculates the absolute value (magnitude) of a number.</first>
<full>
Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number to compute</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sq" kind="METHOD">
<body>
<first>( begin auto-generated from sq.xml ) Squares a number (multiplies a number by itself).</first>
<full>
Squares a number (multiplies a number by itself). The result is always a positive number, as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number to square</blocktag>
<blocktag>@see PApplet#sqrt(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sqrt" kind="METHOD">
<body>
<first>( begin auto-generated from sqrt.xml ) Calculates the square root of a number.</first>
<full>
Calculates the square root of a number. The square root of a number is always positive, even though there may be a valid negative root. The square root `s` of number `a` is such that `s*s = a` . It is the opposite of squaring.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n non-negative number</blocktag>
<blocktag>@see PApplet#pow(float, float)</blocktag>
<blocktag>@see PApplet#sq(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="log" kind="METHOD">
<body>
<first>( begin auto-generated from log.xml ) Calculates the natural logarithm (the base-,&lt;i&gt;,e,&lt;/i&gt;, logarithm) of a number.</first>
<full>
Calculates the natural logarithm (the base-&lt;i&gt;e&lt;/i&gt;logarithm) of a number. This function expects the values greater than 0.0.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number greater than 0.0</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="exp" kind="METHOD">
<body>
<first>( begin auto-generated from exp.xml ) Returns Euler's number ,&lt;i&gt;,e,&lt;/i&gt;, (2.71828...) raised to the power of the , `,value,` , parameter.</first>
<full>
Returns Euler's number&lt;i&gt;e&lt;/i&gt;(2.71828...) raised to the power of the `value` parameter.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n exponent to raise</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pow" kind="METHOD">
<body>
<first>( begin auto-generated from pow.xml ) Facilitates exponential expressions.</first>
<full>
Facilitates exponential expressions. The `pow()` function is an efficient way of multiplying numbers by themselves (or their reciprocal) in large quantities. For example, `pow(3, 5)` is equivalent to the expression 3*3*3*3*3 and `pow(3, -5)` is equivalent to 1 / 3*3*3*3*3.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n base of the exponential expression</blocktag>
<blocktag>@param e power by which to raise the base</blocktag>
<blocktag>@see PApplet#sqrt(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="max" kind="METHOD">
<body>
<first>( begin auto-generated from max.xml ) Determines the largest value in a sequence of numbers.</first>
<full>
Determines the largest value in a sequence of numbers.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param a first number to compare</blocktag>
<blocktag>@param b second number to compare</blocktag>
<blocktag>@see PApplet#min(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="max" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c third number to compare</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="max" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param list array of numbers to compare</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="min" kind="METHOD">
<body>
<first>( begin auto-generated from min.xml ) Determines the smallest value in a sequence of numbers.</first>
<full>
Determines the smallest value in a sequence of numbers.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param a first number</blocktag>
<blocktag>@param b second number</blocktag>
<blocktag>@param c third number</blocktag>
<blocktag>@see PApplet#max(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="min" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param list array of numbers to compare</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="constrain" kind="METHOD">
<body>
<first>( begin auto-generated from constrain.xml ) Constrains a value to not exceed a maximum and minimum value.</first>
<full>
Constrains a value to not exceed a maximum and minimum value.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param amt the value to constrain</blocktag>
<blocktag>@param low minimum limit</blocktag>
<blocktag>@param high maximum limit</blocktag>
<blocktag>@see PApplet#max(float, float, float)</blocktag>
<blocktag>@see PApplet#min(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sin" kind="METHOD">
<body>
<first>( begin auto-generated from sin.xml ) Calculates the sine of an angle.</first>
<full>
Calculates the sine of an angle. This function expects the values of the `angle` parameter to be provided in radians (values from 0 to 6.28). Values are returned in the range -1 to 1.
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param angle an angle in radians</blocktag>
<blocktag>@see PApplet#cos(float)</blocktag>
<blocktag>@see PApplet#tan(float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="cos" kind="METHOD">
<body>
<first>( begin auto-generated from cos.xml ) Calculates the cosine of an angle.</first>
<full>
Calculates the cosine of an angle. This function expects the values of the `angle` parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param angle an angle in radians</blocktag>
<blocktag>@see PApplet#sin(float)</blocktag>
<blocktag>@see PApplet#tan(float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="tan" kind="METHOD">
<body>
<first>( begin auto-generated from tan.xml ) Calculates the ratio of the sine and cosine of an angle.</first>
<full>
Calculates the ratio of the sine and cosine of an angle. This function expects the values of the `angle` parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range `infinity` to `-infinity` .
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param angle an angle in radians</blocktag>
<blocktag>@see PApplet#cos(float)</blocktag>
<blocktag>@see PApplet#sin(float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="asin" kind="METHOD">
<body>
<first>( begin auto-generated from asin.xml ) The inverse of , `,sin(),` ,, returns the arc sine of a value.</first>
<full>
The inverse of `sin()` , returns the arc sine of a value. This function expects the values in the range of -1 to 1 and values are returned in the range `-PI/2` to `PI/2` .
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param value the value whose arc sine is to be returned</blocktag>
<blocktag>@see PApplet#sin(float)</blocktag>
<blocktag>@see PApplet#acos(float)</blocktag>
<blocktag>@see PApplet#atan(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="acos" kind="METHOD">
<body>
<first>( begin auto-generated from acos.xml ) The inverse of , `,cos(),` ,, returns the arc cosine of a value.</first>
<full>
The inverse of `cos()` , returns the arc cosine of a value. This function expects the values in the range of -1 to 1 and values are returned in the range `0` to `PI (3.1415927)` .
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param value the value whose arc cosine is to be returned</blocktag>
<blocktag>@see PApplet#cos(float)</blocktag>
<blocktag>@see PApplet#asin(float)</blocktag>
<blocktag>@see PApplet#atan(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="atan" kind="METHOD">
<body>
<first>( begin auto-generated from atan.xml ) The inverse of , `,tan(),` ,, returns the arc tangent of a value.</first>
<full>
The inverse of `tan()` , returns the arc tangent of a value. This function expects the values in the range of -Infinity to Infinity (exclusive) and values are returned in the range `-PI/2` to `PI/2` .
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param value -Infinity to Infinity (exclusive)</blocktag>
<blocktag>@see PApplet#tan(float)</blocktag>
<blocktag>@see PApplet#asin(float)</blocktag>
<blocktag>@see PApplet#acos(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="atan2" kind="METHOD">
<body>
<first>( begin auto-generated from atan2.xml ) Calculates the angle (in radians) from a specified point to the coordinate origin as measured from the positive x-axis.</first>
<full>
Calculates the angle (in radians) from a specified point to the coordinate origin as measured from the positive x-axis. Values are returned as a `float` in the range from `PI` to `-PI` . The `atan2()` function is most often used for orienting geometry to the position of the cursor.  Note: The y-coordinate of the point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param y y-coordinate of the point</blocktag>
<blocktag>@param x x-coordinate of the point</blocktag>
<blocktag>@see PApplet#tan(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="degrees" kind="METHOD">
<body>
<first>( begin auto-generated from degrees.xml ) Converts a radian measurement to its corresponding value in degrees.</first>
<full>
Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example, 90°= PI/2 = 1.5707964. All trigonometric functions in Processing require their parameters to be specified in radians.
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param radians radian value to convert to degrees</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="radians" kind="METHOD">
<body>
<first>( begin auto-generated from radians.xml ) Converts a degree measurement to its corresponding value in radians.</first>
<full>
Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example, 90°= PI/2 = 1.5707964. All trigonometric functions in Processing require their parameters to be specified in radians.
</full>
</body>
<blocktags>
<blocktag>@webref math:trigonometry</blocktag>
<blocktag>@param degrees degree value to convert to radians</blocktag>
<blocktag>@see PApplet#degrees(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ceil" kind="METHOD">
<body>
<first>( begin auto-generated from ceil.xml ) Calculates the closest int value that is greater than or equal to the value of the parameter.</first>
<full>
Calculates the closest int value that is greater than or equal to the value of the parameter. For example, `ceil(9.03)` returns the value 10.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number to round up</blocktag>
<blocktag>@see PApplet#floor(float)</blocktag>
<blocktag>@see PApplet#round(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="floor" kind="METHOD">
<body>
<first>( begin auto-generated from floor.xml ) Calculates the closest int value that is less than or equal to the value of the parameter.</first>
<full>
Calculates the closest int value that is less than or equal to the value of the parameter.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number to round down</blocktag>
<blocktag>@see PApplet#ceil(float)</blocktag>
<blocktag>@see PApplet#round(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="round" kind="METHOD">
<body>
<first>( begin auto-generated from round.xml ) Calculates the integer closest to the , `,value,` , parameter.</first>
<full>
Calculates the integer closest to the `value` parameter. For example, `round(9.2)` returns the value 9.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param n number to round</blocktag>
<blocktag>@see PApplet#floor(float)</blocktag>
<blocktag>@see PApplet#ceil(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mag" kind="METHOD">
<body>
<first>( begin auto-generated from mag.xml ) Calculates the magnitude (or length) of a vector.</first>
<full>
Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no "start" position, the magnitude of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value. Therefore, mag() is a shortcut for writing "dist(0, 0, x, y)".
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param a first value</blocktag>
<blocktag>@param b second value</blocktag>
<blocktag>@param c third value</blocktag>
<blocktag>@see PApplet#dist(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dist" kind="METHOD">
<body>
<first>( begin auto-generated from dist.xml ) Calculates the distance between two points.</first>
<full>
Calculates the distance between two points.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param x1 x-coordinate of the first point</blocktag>
<blocktag>@param y1 y-coordinate of the first point</blocktag>
<blocktag>@param z1 z-coordinate of the first point</blocktag>
<blocktag>@param x2 x-coordinate of the second point</blocktag>
<blocktag>@param y2 y-coordinate of the second point</blocktag>
<blocktag>@param z2 z-coordinate of the second point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lerp" kind="METHOD">
<body>
<first>( begin auto-generated from lerp.xml ) Calculates a number between two numbers at a specific increment.</first>
<full>
Calculates a number between two numbers at a specific increment. The `amt` parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param start first value</blocktag>
<blocktag>@param stop second value</blocktag>
<blocktag>@param amt float between 0.0 and 1.0</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierPoint(float, float, float, float, float)</blocktag>
<blocktag>@see PVector#lerp(PVector, float)</blocktag>
<blocktag>@see PGraphics#lerpColor(int, int, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="norm" kind="METHOD">
<body>
<first>( begin auto-generated from norm.xml ) Normalizes a number from another range into a value between 0 and 1.</first>
<full>
Normalizes a number from another range into a value between 0 and 1.

Identical to map(value, low, high, 0, 1);

Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param value the incoming value to be converted</blocktag>
<blocktag>@param start lower bound of the value's current range</blocktag>
<blocktag>@param stop upper bound of the value's current range</blocktag>
<blocktag>@see PApplet#map(float, float, float, float, float)</blocktag>
<blocktag>@see PApplet#lerp(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="map" kind="METHOD">
<body>
<first>( begin auto-generated from map.xml ) Re-maps a number from one range to another.</first>
<full>
Re-maps a number from one range to another. In the example above, the number '25' is converted from a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.

Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.
</full>
</body>
<blocktags>
<blocktag>@webref math:calculation</blocktag>
<blocktag>@param value the incoming value to be converted</blocktag>
<blocktag>@param start1 lower bound of the value's current range</blocktag>
<blocktag>@param stop1 upper bound of the value's current range</blocktag>
<blocktag>@param start2 lower bound of the value's target range</blocktag>
<blocktag>@param stop2 upper bound of the value's target range</blocktag>
<blocktag>@see PApplet#norm(float, float, float)</blocktag>
<blocktag>@see PApplet#lerp(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="random" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="randomGaussian" kind="METHOD">
<body>
<first>( begin auto-generated from randomGaussian.xml ) Returns a float from a random series of numbers having a mean of 0 and standard deviation of 1.</first>
<full>
Returns a float from a random series of numbers having a mean of 0 and standard deviation of 1. Each time the `randomGaussian()` function is called, it returns a number fitting a Gaussian, or normal, distribution. There is theoretically no minimum or maximum value that `randomGaussian()` might return. Rather, there is just a very low probability that values far from the mean will be returned; and a higher probability that numbers near the mean will be returned.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@see PApplet#random(float,float)</blocktag>
<blocktag>@see PApplet#noise(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="random" kind="METHOD">
<body>
<first>( begin auto-generated from random.xml ) Generates random numbers.</first>
<full>
Generates random numbers. Each time the `random()` function is called, it returns an unexpected value within the specified range. If one parameter is passed to the function it will return a `float` between zero and the value of the `high` parameter. The function call `random(5)` returns values between 0 and 5 (starting at zero, up to but not including 5). If two parameters are passed, it will return a `float` with a value between the the parameters. The function call `random(-5, 10.2)` returns values starting at -5 up to (but not including) 10.2. To convert a floating-point random number to an integer, use the `int()` function.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@param low lower limit</blocktag>
<blocktag>@param high upper limit</blocktag>
<blocktag>@see PApplet#randomSeed(long)</blocktag>
<blocktag>@see PApplet#noise(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="randomSeed" kind="METHOD">
<body>
<first>( begin auto-generated from randomSeed.xml ) Sets the seed value for , `,random(),` ,.</first>
<full>
Sets the seed value for `random()` . By default, `random()` produces different results each time the program is run. Set the `value` parameter to a constant to return the same pseudo-random numbers each time the software is run.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@param seed seed value</blocktag>
<blocktag>@see PApplet#random(float,float)</blocktag>
<blocktag>@see PApplet#noise(float, float, float)</blocktag>
<blocktag>@see PApplet#noiseSeed(long)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noise" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noise" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noise" kind="METHOD">
<body>
<first>( begin auto-generated from noise.xml ) Returns the Perlin noise value at specified coordinates.</first>
<full>
Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence generator producing a more natural ordered, harmonic succession of numbers compared to the standard `random()` function. It was invented by Ken Perlin in the 1980s and been used since in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.

The main difference to the `random()` function is that Perlin noise is defined in an infinite n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value (fixed only for the lifespan of the program). The resulting value will always be between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates given. The noise value can be animated by moving through the noise space as demonstrated in the example above. The 2nd and 3rd dimension can also be interpreted as time.

The actual noise is structured similar to an audio signal, in respect to the function's use of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over several octaves which are added together for the final result.

Another way to adjust the character of the resulting sequence is the scale of the input coordinates. As the function works within an infinite space the value of the coordinates doesn't matter as such, only the distance between successive coordinates does (eg. when using `noise()` within a loop). As a general rule the smaller the difference between coordinates, the smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications, but this will differ depending on use.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@param x x-coordinate in noise space</blocktag>
<blocktag>@param y y-coordinate in noise space</blocktag>
<blocktag>@param z z-coordinate in noise space</blocktag>
<blocktag>@see PApplet#noiseSeed(long)</blocktag>
<blocktag>@see PApplet#noiseDetail(int, float)</blocktag>
<blocktag>@see PApplet#random(float,float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noiseDetail" kind="METHOD">
<body>
<first>( begin auto-generated from noiseDetail.xml ) Adjusts the character and level of detail produced by the Perlin noise function.</first>
<full>
Adjusts the character and level of detail produced by the Perlin noise function. Similar to harmonics in physics, noise is computed over several octaves. Lower octaves contribute more to the output signal and as such define the overal intensity of the noise, whereas higher octaves create finer grained details in the noise sequence. By default, noise is computed over 4 octaves with each octave contributing exactly half than its predecessor, starting at 50% strength for the 1st octave. This falloff amount can be changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means each octave will now have 75% impact (25% less) of the previous lower octave. Any value between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in greater than 1.0 values returned by `noise()` .

By changing these parameters, the signal created by the `noise()` function can be adapted to fit very specific needs and characteristics.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@param lod number of octaves to be used by the noise</blocktag>
<blocktag>@see PApplet#noise(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noiseDetail" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@see #noiseDetail(int)</blocktag>
<blocktag>@param falloff falloff factor for each octave</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noiseSeed" kind="METHOD">
<body>
<first>( begin auto-generated from noiseSeed.xml ) Sets the seed value for , `,noise(),` ,.</first>
<full>
Sets the seed value for `noise()` . By default, `noise()` produces different results each time the program is run. Set the `value` parameter to a constant to return the same pseudo-random numbers each time the software is run.
</full>
</body>
<blocktags>
<blocktag>@webref math:random</blocktag>
<blocktag>@param seed seed value</blocktag>
<blocktag>@see PApplet#noise(float, float, float)</blocktag>
<blocktag>@see PApplet#noiseDetail(int, float)</blocktag>
<blocktag>@see PApplet#random(float,float)</blocktag>
<blocktag>@see PApplet#randomSeed(long)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadImage" kind="METHOD">
<body>
<first>( begin auto-generated from loadImage.xml ) Loads an image into a variable of type , `,PImage,` ,.</first>
<full>
Loads an image into a variable of type `PImage` . Four types of images ( `.gif` , `.jpg` , `.tga` , `.png` ) images may be loaded. To load correctly, images must be located in the data directory of the current sketch. In most cases, load all images in `setup()` to preload them at the start of the program. Loading images inside `draw()` will reduce the speed of a program.

 `filename` parameter can also be a URL to a file found online. For security reasons, a Processing sketch found online can only download files from the same server from which it came. Getting around this restriction requires a&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/a&gt;.

 `extension` parameter is used to determine the image type in cases where the image filename does not end with a proper extension. Specify the extension as the second parameter to `loadImage()` , as shown in the third example on this page.

an image is not loaded successfully, the `null` value is returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned from `loadImage()` is null.

on the type of error, a `PImage` object may still be returned, but the width and height of the image will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens with image URLs that produce a 403 error or that redirect to a password prompt, because `loadImage()` will attempt to interpret the HTML as image data.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param filename name of file to load, can be .gif, .jpg, .tga, or a handful of other image types depending on your platform</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#imageMode(int)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadImage" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param extension type of image to load, for example "png", "gif", "jpg"</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="requestImage" kind="METHOD">
<body>
<first>( begin auto-generated from requestImage.xml ) This function load images on a separate thread so that your sketch does not freeze while images load during , `,setup(),` ,.</first>
<full>
This function load images on a separate thread so that your sketch does not freeze while images load during `setup()` . While the image is loading, its width and height will be 0. If an error occurs while loading the image, its width and height will be set to -1. You'll know when the image has loaded properly because its width and height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can dramatically improve performance.

 `extension` parameter is used to determine the image type in cases where the image filename does not end with a proper extension. Specify the extension as the second parameter to `requestImage()` .
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param filename name of the file to load, can be .gif, .jpg, .tga, or a handful of other image types depending on your platform</blocktag>
<blocktag>@param extension the type of image to load, for example "png", "gif", "jpg"</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadXML" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of a file in the data folder or a URL.</blocktag>
<blocktag>@see XML</blocktag>
<blocktag>@see PApplet#parseXML(String)</blocktag>
<blocktag>@see PApplet#saveXML(XML, String)</blocktag>
<blocktag>@see PApplet#loadBytes(String)</blocktag>
<blocktag>@see PApplet#loadStrings(String)</blocktag>
<blocktag>@see PApplet#loadTable(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadXML" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseXML" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@brief Converts String content to an XML object</blocktag>
<blocktag>@param xmlString the content to be parsed as XML</blocktag>
<blocktag>@return an XML object, or null</blocktag>
<blocktag>@see XML</blocktag>
<blocktag>@see PApplet#loadXML(String)</blocktag>
<blocktag>@see PApplet#saveXML(XML, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveXML" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param xml the XML object to save to disk</blocktag>
<blocktag>@param filename name of the file to write to</blocktag>
<blocktag>@see XML</blocktag>
<blocktag>@see PApplet#loadXML(String)</blocktag>
<blocktag>@see PApplet#parseXML(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveXML" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseJSONObject" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param input String to parse as a JSONObject</blocktag>
<blocktag>@see PApplet#loadJSONObject(String)</blocktag>
<blocktag>@see PApplet#saveJSONObject(JSONObject, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadJSONObject" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of a file in the data folder or a URL</blocktag>
<blocktag>@see JSONObject</blocktag>
<blocktag>@see JSONArray</blocktag>
<blocktag>@see PApplet#loadJSONArray(String)</blocktag>
<blocktag>@see PApplet#saveJSONObject(JSONObject, String)</blocktag>
<blocktag>@see PApplet#saveJSONArray(JSONArray, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadJSONObject" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveJSONObject" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param json the JSONObject to save</blocktag>
<blocktag>@param filename the name of the file to save to</blocktag>
<blocktag>@see JSONObject</blocktag>
<blocktag>@see JSONArray</blocktag>
<blocktag>@see PApplet#loadJSONObject(String)</blocktag>
<blocktag>@see PApplet#loadJSONArray(String)</blocktag>
<blocktag>@see PApplet#saveJSONArray(JSONArray, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveJSONObject" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param options "compact" and "indent=N", replace N with the number of spaces</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseJSONArray" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param input String to parse as a JSONArray</blocktag>
<blocktag>@see JSONObject</blocktag>
<blocktag>@see PApplet#loadJSONObject(String)</blocktag>
<blocktag>@see PApplet#saveJSONObject(JSONObject, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadJSONArray" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of a file in the data folder or a URL</blocktag>
<blocktag>@see JSONArray</blocktag>
<blocktag>@see PApplet#loadJSONObject(String)</blocktag>
<blocktag>@see PApplet#saveJSONObject(JSONObject, String)</blocktag>
<blocktag>@see PApplet#saveJSONArray(JSONArray, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveJSONArray" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param json the JSONArray to save</blocktag>
<blocktag>@param filename the name of the file to save to</blocktag>
<blocktag>@see JSONObject</blocktag>
<blocktag>@see JSONArray</blocktag>
<blocktag>@see PApplet#loadJSONObject(String)</blocktag>
<blocktag>@see PApplet#loadJSONArray(String)</blocktag>
<blocktag>@see PApplet#saveJSONObject(JSONObject, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveJSONArray" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param options "compact" and "indent=N", replace N with the number of spaces</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadTable" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of a file in the data folder or a URL.</blocktag>
<blocktag>@see Table</blocktag>
<blocktag>@see PApplet#saveTable(Table, String)</blocktag>
<blocktag>@see PApplet#loadBytes(String)</blocktag>
<blocktag>@see PApplet#loadStrings(String)</blocktag>
<blocktag>@see PApplet#loadXML(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadTable" kind="METHOD">
<body>
<first>Options may contain "header", "tsv", "csv", or "bin" separated by commas.</first>
<full>
Options may contain "header", "tsv", "csv", or "bin" separated by commas. Another option is "dictionary=filename.tsv", which allows users to specify a "dictionary" file that contains a mapping of the column titles and the data types used in the table file. This can be far more efficient (in terms of speed and memory usage) for loading and parsing tables. The dictionary file can only be tab separated values (.tsv) and its extension will be ignored. This option was added in Processing 2.0.2.
</full>
</body>
<blocktags>
<blocktag>@param options may contain "header", "tsv", "csv", or "bin" separated by commas</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveTable" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param table the Table object to save to a file</blocktag>
<blocktag>@param filename the filename to which the Table should be saved</blocktag>
<blocktag>@see Table</blocktag>
<blocktag>@see PApplet#loadTable(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveTable" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param options can be one of "tsv", "csv", "bin", or "html"</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadFont" kind="METHOD">
<body>
<first>( begin auto-generated from loadFont.xml ) Loads a font into a variable of type , `,PFont,` ,.</first>
<full>
Loads a font into a variable of type `PFont` . To load correctly, fonts must be located in the data directory of the current sketch. To create a font to use with Processing, select "Create Font..." from the Tools menu. This will create a font in the format Processing requires and also adds it to the current sketch's data directory.

Like `loadImage()` and other functions that load data, the `loadFont()` function should not be used inside `draw()` , because it will slow down the sketch considerably, as the font will be re-loaded from the disk (or network) on each frame.

For most renderers, Processing displays fonts using the .vlw font format, which uses images for each letter, rather than defining them through vector data. When `hint(ENABLE_NATIVE_FONTS)` is used with the JAVA2D renderer, the native version of a font will be used if it is installed on the user's machine.

Using `createFont()` (instead of loadFont) enables vector data to be used with the JAVA2D (default) renderer setting. This can be helpful when many font sizes are needed, or when using any renderer based on JAVA2D, such as the PDF library.
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param filename name of the font to load</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#textFont(PFont, float)</blocktag>
<blocktag>@see PApplet#createFont(String, float, boolean, char[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createFont" kind="METHOD">
<body>
<first>( begin auto-generated from createFont.xml ) Dynamically converts a font to the format used by Processing from either a font name that's installed on the computer, or from a .ttf or .otf file inside the sketches "data" folder.</first>
<full>
Dynamically converts a font to the format used by Processing from either a font name that's installed on the computer, or from a .ttf or .otf file inside the sketches "data" folder. This function is an advanced feature for precise control. On most occasions you should create fonts through selecting "Create Font..." from the Tools menu.

Use the `PFont.list()` method to first determine the names for the fonts recognized by the computer and are compatible with this function. Because of limitations in Java, not all fonts can be used and some might work with one operating system and not others. When sharing a sketch with other people or posting it on the web, you may need to include a .ttf or .otf version of your font in the data directory of the sketch because other people might not have the font installed on their computer. Only fonts that can legally be distributed should be included with a sketch.

The `size` parameter states the font size you want to generate. The `smooth` parameter specifies if the font should be antialiased or not, and the `charset` parameter is an array of chars that specifies the characters to generate.

This function creates a bitmapped version of a font in the same manner as the Create Font tool. It loads a font by name, and converts it to a series of images based on the size of the font. When possible, the `text()` function will use a native font rather than the bitmapped version created behind the scenes with `createFont()` . For instance, when using P2D, the actual native version of the font will be employed by the sketch, improving drawing quality and performance. With the P3D renderer, the bitmapped version will be used. While this can drastically improve speed and appearance, results are poor when exporting if the sketch does not include the .otf or .ttf file, and the requested font is not available on the machine running the sketch.
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param name name of the font to load</blocktag>
<blocktag>@param size point size of the font</blocktag>
<blocktag>@param smooth true for an antialiased font, false for aliased</blocktag>
<blocktag>@param charset array containing characters to be generated</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#textFont(PFont, float)</blocktag>
<blocktag>@see PGraphics#text(String, float, float, float, float)</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="selectInput" kind="METHOD">
<body>
<first>Open a platform-specific file chooser dialog to select a file for input.</first>
<full>
Open a platform-specific file chooser dialog to select a file for input. After the selection is made, the selected File will be passed to the 'callback' function. If the dialog is closed or canceled, null will be sent to the function, so that the program is not waiting for additional input. The callback is necessary because of how threading works.&lt;pre&gt;void setup() {   selectInput("Select a file to process:", "fileSelected"); } void fileSelected(File selection) {   if (selection == null) {     println("Window was closed or the user hit cancel.");   } else {     println("User selected " + fileSeleted.getAbsolutePath());   } }&lt;/pre&gt;For advanced users, the method must be 'public', which is true for all methods inside a sketch when run from the PDE, but must explicitly be set when using Eclipse or other development environments.
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param prompt message to the user</blocktag>
<blocktag>@param callback name of the method to be called when the selection is made</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="selectOutput" kind="METHOD">
<body>
<first>See selectInput() for details.</first>
<full>
See selectInput() for details.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param prompt message to the user</blocktag>
<blocktag>@param callback name of the method to be called when the selection is made</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="selectFolder" kind="METHOD">
<body>
<first>See selectInput() for details.</first>
<full>
See selectInput() for details.
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param prompt message to the user</blocktag>
<blocktag>@param callback name of the method to be called when the selection is made</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="checkExtension" kind="METHOD">
<body>
<first>Get the compression-free extension for this filename.</first>
<full>
Get the compression-free extension for this filename.
</full>
</body>
<blocktags>
<blocktag>@param filename The filename to check</blocktag>
<blocktag>@return an extension, skipping past .gz if it's present</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createReader" kind="METHOD">
<body>
<first>( begin auto-generated from createReader.xml ) Creates a , `,BufferedReader,` , object that can be used to read files line-by-line as individual , `,String,` , objects.</first>
<full>
Creates a `BufferedReader` object that can be used to read files line-by-line as individual `String` objects. This is the complement to the `createWriter()` function.

Starting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of the file to be opened</blocktag>
<blocktag>@see BufferedReader</blocktag>
<blocktag>@see PApplet#createWriter(String)</blocktag>
<blocktag>@see PrintWriter</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createReader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createReader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref I want to read lines from a stream. If I have to type the following lines any more I'm gonna send Sun my medical bills.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createWriter" kind="METHOD">
<body>
<first>( begin auto-generated from createWriter.xml ) Creates a new file in the sketch folder, and a , `,PrintWriter,` , object to write to it.</first>
<full>
Creates a new file in the sketch folder, and a `PrintWriter` object to write to it. For the file to be made correctly, it should be flushed and must be closed with its `flush()` and `close()` methods (see above example).

Starting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param filename name of the file to be created</blocktag>
<blocktag>@see PrintWriter</blocktag>
<blocktag>@see PApplet#createReader</blocktag>
<blocktag>@see BufferedReader</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createWriter" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref I want to print lines to a file. I have RSI from typing these eight lines of code so many times.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createWriter" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref I want to print lines to a file. Why am I always explaining myself? It's the JavaSoft API engineers who need to explain themselves.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createInput" kind="METHOD">
<body>
<first>( begin auto-generated from createInput.xml ) This is a function for advanced programmers to open a Java InputStream.</first>
<full>
This is a function for advanced programmers to open a Java InputStream. It's useful if you want to use the facilities provided by PApplet to easily open files from the data folder or from a URL, but want an InputStream object so that you can use other parts of Java to take more control of how the stream is read.

The filename passed in can be:
- A URL, for instance `openStream("http://processing.org/")` 
- A file in the sketch's `data` folder
- The full path to a file to be opened locally (when running as an application)

If the requested item doesn't exist, null is returned. If not online, this will also check to see if the user is asking for a file whose name isn't properly capitalized. If capitalization is different, an error will be printed to the console. This helps prevent issues that appear when a sketch is exported to the web, where case sensitivity matters, as opposed to running from inside the Processing Development Environment on Windows or Mac OS, where case sensitivity is preserved but ignored.

If the file ends with `.gz` , the stream will automatically be gzip decompressed. If you don't want the automatic decompression, use the related function `createInputRaw()` .
In earlier releases, this function was called `openStream()` .



Advanced
--------

Simplified method to open a Java InputStream.

This method is useful if you want to use the facilities provided by PApplet to easily open things from the data folder or from a URL, but want an InputStream object so that you can use other Java methods to take more control of how the stream is read.

If the requested item doesn't exist, null is returned. (Prior to 0096, die() would be called, killing the applet)

For 0096+, the "data" folder is exported intact with subfolders, and openStream() properly handles subdirectories from the data folder

If not online, this will also check to see if the user is asking for a file whose name isn't properly capitalized. This helps prevent issues when a sketch is exported to the web, where case sensitivity matters, as opposed to Windows and the Mac OS default where case sensitivity is preserved but ignored.

It is strongly recommended that libraries use this method to open data files, so that the loading sequence is handled in the same way as functions like loadBytes(), loadImage(), etc.

The filename passed in can be:

* A URL, for instance openStream("http://processing.org/");
* A file in the sketch's data folder
* Another file to be opened locally (when running as an application)

</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename the name of the file to use as input</blocktag>
<blocktag>@see PApplet#createOutput(String)</blocktag>
<blocktag>@see PApplet#selectOutput(String,String)</blocktag>
<blocktag>@see PApplet#selectInput(String,String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createInputRaw" kind="METHOD">
<body>
<first>Call openStream() without automatic gzip decompression.</first>
<full>
Call openStream() without automatic gzip decompression.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createInput" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadBytes" kind="METHOD">
<body>
<first>( begin auto-generated from loadBytes.xml ) Reads the contents of a file or url and places it in a byte array.</first>
<full>
Reads the contents of a file or url and places it in a byte array. If a file is specified, it must be located in the sketch's "data" directory/folder.

The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch found online can only download files from the same server from which it came. Getting around this restriction requires a&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/a&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of a file in the data folder or a URL.</blocktag>
<blocktag>@see PApplet#loadStrings(String)</blocktag>
<blocktag>@see PApplet#saveStrings(String, String[])</blocktag>
<blocktag>@see PApplet#saveBytes(String, byte[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadBytes" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadBytes" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadStrings" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadStrings" kind="METHOD">
<body>
<first>( begin auto-generated from loadStrings.xml ) Reads the contents of a file or url and creates a String array of its individual lines.</first>
<full>
Reads the contents of a file or url and creates a String array of its individual lines. If a file is specified, it must be located in the sketch's "data" directory/folder.

The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch found online can only download files from the same server from which it came. Getting around this restriction requires a&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/a&gt;.
If the file is not available or an error occurs, `null` will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.

Starting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.

Advanced
--------

Load data from a file and shove it into a String array.

Exceptions are handled internally, when an error, occurs, an exception is printed to the console and 'null' is returned, but the program continues running. This is a tradeoff between 1) showing the user that there was a problem but 2) not requiring that all i/o code is contained in try/catch blocks, for the sake of new users (or people who are just trying to get things done in a "scripting" fashion. If you want to handle exceptions, use Java methods for I/O.
</full>
</body>
<blocktags>
<blocktag>@webref input:files</blocktag>
<blocktag>@param filename name of the file or url to load</blocktag>
<blocktag>@see PApplet#loadBytes(String)</blocktag>
<blocktag>@see PApplet#saveStrings(String, String[])</blocktag>
<blocktag>@see PApplet#saveBytes(String, byte[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadStrings" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createOutput" kind="METHOD">
<body>
<first>( begin auto-generated from createOutput.xml ) Similar to , `,createInput(),` ,, this creates a Java , `,OutputStream,` , for a given filename or path.</first>
<full>
Similar to `createInput()` , this creates a Java `OutputStream` for a given filename or path. The file will be created in the sketch folder, or in the same folder as an exported application.

If the path does not exist, intermediate folders will be created. If an exception occurs, it will be printed to the console, and `null` will be returned.

This function is a convenience over the Java approach that requires you to 1) create a FileOutputStream object, 2) determine the exact file location, and 3) handle exceptions. Exceptions are handled internally by the function, which is more appropriate for "sketch" projects.

If the output filename ends with `.gz` , the output will be automatically GZIP compressed as it is written.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param filename name of the file to open</blocktag>
<blocktag>@see PApplet#createInput(String)</blocktag>
<blocktag>@see PApplet#selectOutput(String,String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createOutput" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStream" kind="METHOD">
<body>
<first>( begin auto-generated from saveStream.xml ) Save the contents of a stream to a file in the sketch folder.</first>
<full>
Save the contents of a stream to a file in the sketch folder. This is basically `saveBytes(blah, loadBytes())` , but done more efficiently (and with less confusing syntax).

When using the `targetFile` parameter, it writes to a `File` object for greater control over the file location. (Note that unlike some other functions, this will not automatically compress or uncompress gzip files.)
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param target name of the file to write to</blocktag>
<blocktag>@param source location to read from (a filename, path, or URL)</blocktag>
<blocktag>@see PApplet#createOutput(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStream" kind="METHOD">
<body>
<first>Identical to the other saveStream(), but writes to a File object, for greater control over the file location.</first>
<full>
Identical to the other saveStream(), but writes to a File object, for greater control over the file location.

Note that unlike other api methods, this will not automatically compress or uncompress gzip files.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStream" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStream" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStream" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveBytes" kind="METHOD">
<body>
<first>( begin auto-generated from saveBytes.xml ) Opposite of , `,loadBytes(),` ,, will write an entire array of bytes to a file.</first>
<full>
Opposite of `loadBytes()` , will write an entire array of bytes to a file. The data is saved in binary format. This file is saved to the sketch's folder, which is opened by selecting "Show sketch folder" from the "Sketch" menu.

It is not possible to use saveXxxxx() functions inside a web browser unless the sketch is&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/A&gt;. To save a file back to a server, see the&lt;a href="http://wiki.processing.org/w/Saving_files_to_a_web-server"&gt;save to web&lt;/A&gt;code snippet on the Processing Wiki.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param filename name of the file to write to</blocktag>
<blocktag>@param data array of bytes to be written</blocktag>
<blocktag>@see PApplet#loadStrings(String)</blocktag>
<blocktag>@see PApplet#loadBytes(String)</blocktag>
<blocktag>@see PApplet#saveStrings(String, String[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createTempFile" kind="METHOD">
<body>
<first>Creates a temporary file based on the name/extension of another file and in the same parent directory.</first>
<full>
Creates a temporary file based on the name/extension of another file and in the same parent directory. Ensures that the same extension is used (i.e. so that .gz files are gzip compressed on output) and that it's done from the same directory so that renaming the file later won't cross file system boundaries.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveBytes" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Saves bytes to a specific File location specified by the user.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveBytes" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Spews a buffer of bytes to an OutputStream.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStrings" kind="METHOD">
<body>
<first>( begin auto-generated from saveStrings.xml ) Writes an array of strings to a file, one line per string.</first>
<full>
Writes an array of strings to a file, one line per string. This file is saved to the sketch's folder, which is opened by selecting "Show sketch folder" from the "Sketch" menu.

It is not possible to use saveXxxxx() functions inside a web browser unless the sketch is&lt;a href="http://wiki.processing.org/w/Sign_an_Applet"&gt;signed applet&lt;/A&gt;. To save a file back to a server, see the&lt;a href="http://wiki.processing.org/w/Saving_files_to_a_web-server"&gt;save to web&lt;/A&gt;code snippet on the Processing Wiki.
&lt;br/&gt;Starting with Processing 1.0, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param filename filename for output</blocktag>
<blocktag>@param data string array to be written</blocktag>
<blocktag>@see PApplet#loadStrings(String)</blocktag>
<blocktag>@see PApplet#loadBytes(String)</blocktag>
<blocktag>@see PApplet#saveBytes(String, byte[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStrings" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveStrings" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sketchPath" kind="METHOD">
<body>
<first>Prepend the sketch folder path to the filename (or path) that is passed in.</first>
<full>
Prepend the sketch folder path to the filename (or path) that is passed in. External libraries should use this function to save to the sketch folder.

Note that when running as an applet inside a web browser, the sketchPath will be set to null, because security restrictions prevent applets from accessing that information.

This will also cause an error if the sketch is not inited properly, meaning that init() was never called on the PApplet when hosted my some other main() or by other code. For proper use of init(), see the examples in the main description text for PApplet.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="savePath" kind="METHOD">
<body>
<first>Returns a path inside the applet folder to save to.</first>
<full>
Returns a path inside the applet folder to save to. Like sketchPath(), but creates any in-between folders so that things save properly.

All saveXxxx() functions use the path to the sketch folder, rather than its data folder. Once exported, the data folder will be found inside the jar file of the exported application or applet. In this case, it's not possible to save data into the jar file, because it will often be running from a server, or marked in-use if running from a local file system. With this in mind, saving to the data path doesn't make sense anyway. If you know you're running locally, and want to save to the data folder, use

```
saveXxxx("data/blah.dat")
```

.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saveFile" kind="METHOD">
<body>
<first>Identical to savePath(), but returns a File object.</first>
<full>
Identical to savePath(), but returns a File object.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dataPath" kind="METHOD">
<body>
<first> `,This function almost certainly does not do the thing you want it to.,` , The data path is handled differently on each platform, and should not be considered a location to write files.</first>
<full>
 `This function almost certainly does not do the thing you want it to.` The data path is handled differently on each platform, and should not be considered a location to write files. It should also not be assumed that this location can be read from or listed. This function is used internally as a possible location for reading files. It's still "public" as a holdover from earlier code.

Libraries should use createInput() to get an InputStream or createOutput() to get an OutputStream. sketchPath() can be used to get a location relative to the sketch. Again, `do not` use this to get relative locations of files. You'll be disappointed when your app runs on different platforms.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="dataFile" kind="METHOD">
<body>
<first>Return a full path to an item in the data folder as a File object.</first>
<full>
Return a full path to an item in the data folder as a File object. See the dataPath() method for more information.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createPath" kind="METHOD">
<body>
<first>Takes a path and creates any in-between folders if they don't already exist.</first>
<full>
Takes a path and creates any in-between folders if they don't already exist. Useful when trying to save to a subfolder that may not actually exist.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sort" kind="METHOD">
<body>
<first>( begin auto-generated from sort.xml ) Sorts an array of numbers from smallest to largest and puts an array of words in alphabetical order.</first>
<full>
Sorts an array of numbers from smallest to largest and puts an array of words in alphabetical order. The original array is not modified, a re-ordered array is returned. The `count` parameter states the number of elements to sort. For example if there are 12 elements in an array and if count is the value 5, only the first five elements on the array will be sorted.&lt;!--As of release 0126, the alphabetical ordering is case insensitive.--&gt;
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list array to sort</blocktag>
<blocktag>@see PApplet#reverse(boolean[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sort" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param count number of elements to sort, starting from 0</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arrayCopy" kind="METHOD">
<body>
<first>( begin auto-generated from arrayCopy.xml ) Copies an array (or part of an array) to another array.</first>
<full>
Copies an array (or part of an array) to another array. The `src` array is copied to the `dst` array, beginning at the position specified by `srcPos` and into the position specified by `dstPos` . The number of elements to copy is determined by `length` . The simplified version with two arguments copies an entire array to another of the same size. It is equivalent to "arrayCopy(src, 0, dst, 0, src.length)". This function is far more efficient for copying array data than iterating through a `for` and copying each element.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param src the source array</blocktag>
<blocktag>@param srcPosition starting position in the source array</blocktag>
<blocktag>@param dst the destination array of the same data type as the source array</blocktag>
<blocktag>@param dstPosition starting position in the destination array</blocktag>
<blocktag>@param length number of array elements to be copied</blocktag>
<blocktag>@see PApplet#concat(boolean[], boolean[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arrayCopy" kind="METHOD">
<body>
<first>Convenience method for arraycopy().</first>
<full>
Convenience method for arraycopy(). Identical to&lt;CODE&gt;arraycopy(src, 0, dst, 0, length);&lt;/CODE&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arrayCopy" kind="METHOD">
<body>
<first>Shortcut to copy the entire contents of the source into the destination array.</first>
<full>
Shortcut to copy the entire contents of the source into the destination array. Identical to&lt;CODE&gt;arraycopy(src, 0, dst, 0, src.length);&lt;/CODE&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arraycopy" kind="METHOD">
<body>
<first>Use arrayCopy() instead.</first>
<full>
Use arrayCopy() instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arraycopy" kind="METHOD">
<body>
<first>Use arrayCopy() instead.</first>
<full>
Use arrayCopy() instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arraycopy" kind="METHOD">
<body>
<first>Use arrayCopy() instead.</first>
<full>
Use arrayCopy() instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="expand" kind="METHOD">
<body>
<first>( begin auto-generated from expand.xml ) Increases the size of an array.</first>
<full>
Increases the size of an array. By default, this function doubles the size of the array, but the optional `newSize` parameter provides precise control over the increase in size.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) expand(originalArray)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list the array to expand</blocktag>
<blocktag>@see PApplet#shorten(boolean[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="expand" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param newSize new size for the array</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="expand" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="append" kind="METHOD">
<body>
<first>( begin auto-generated from append.xml ) Expands an array by one element and adds data to the new position.</first>
<full>
Expands an array by one element and adds data to the new position. The datatype of the `element` parameter must be the same as the datatype of the array.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) append(originalArray, element)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param array array to append</blocktag>
<blocktag>@param value new data for the array</blocktag>
<blocktag>@see PApplet#shorten(boolean[])</blocktag>
<blocktag>@see PApplet#expand(boolean[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shorten" kind="METHOD">
<body>
<first>( begin auto-generated from shorten.xml ) Decreases an array by one element and returns the shortened array.</first>
<full>
Decreases an array by one element and returns the shortened array.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) shorten(originalArray)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list array to shorten</blocktag>
<blocktag>@see PApplet#append(byte[], byte)</blocktag>
<blocktag>@see PApplet#expand(boolean[])</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="splice" kind="METHOD">
<body>
<first>( begin auto-generated from splice.xml ) Inserts a value or array of values into an existing array.</first>
<full>
Inserts a value or array of values into an existing array. The first two parameters must be of the same datatype. The `array` parameter defines the array which will be modified and the second parameter defines the data which will be inserted.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) splice(array1, array2, index)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list array to splice into</blocktag>
<blocktag>@param value value to be spliced in</blocktag>
<blocktag>@param index position in the array from which to insert data</blocktag>
<blocktag>@see PApplet#concat(boolean[], boolean[])</blocktag>
<blocktag>@see PApplet#subset(boolean[], int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="subset" kind="METHOD">
<body>
<first>( begin auto-generated from subset.xml ) Extracts an array of elements from an existing array.</first>
<full>
Extracts an array of elements from an existing array. The `array` parameter defines the array from which the elements will be copied and the `offset` and `length` parameters determine which elements to extract. If no `length` is given, elements will be extracted from the `offset` to the end of the array. When specifying the `offset` remember the first array element is 0. This function does not change the source array.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) subset(originalArray, 0, 4)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list array to extract from</blocktag>
<blocktag>@param start position to begin</blocktag>
<blocktag>@param count number of values to extract</blocktag>
<blocktag>@see PApplet#splice(boolean[], boolean, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="concat" kind="METHOD">
<body>
<first>( begin auto-generated from concat.xml ) Concatenates two arrays.</first>
<full>
Concatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the same datatype.

When using an array of objects, the data returned from the function must be cast to the object array's data type. For example:&lt;em&gt;SomeClass[] items = (SomeClass[]) concat(array1, array2)&lt;/em&gt;.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param a first array to concatenate</blocktag>
<blocktag>@param b second array to concatenate</blocktag>
<blocktag>@see PApplet#splice(boolean[], boolean, int)</blocktag>
<blocktag>@see PApplet#arrayCopy(Object, int, Object, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="reverse" kind="METHOD">
<body>
<first>( begin auto-generated from reverse.xml ) Reverses the order of an array.</first>
<full>
Reverses the order of an array.
</full>
</body>
<blocktags>
<blocktag>@webref data:array_functions</blocktag>
<blocktag>@param list booleans[], bytes[], chars[], ints[], floats[], or Strings[]</blocktag>
<blocktag>@see PApplet#sort(String[], int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="trim" kind="METHOD">
<body>
<first>( begin auto-generated from trim.xml ) Removes whitespace characters from the beginning and end of a String.</first>
<full>
Removes whitespace characters from the beginning and end of a String. In addition to standard whitespace characters such as space, carriage return, and tab, this function also removes the Unicode "nbsp" character.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param str any string</blocktag>
<blocktag>@see PApplet#split(String, String)</blocktag>
<blocktag>@see PApplet#join(String[], char)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="trim" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param array a String array</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="join" kind="METHOD">
<body>
<first>( begin auto-generated from join.xml ) Combines an array of Strings into one String, each separated by the character(s) used for the , `,separator,` , parameter.</first>
<full>
Combines an array of Strings into one String, each separated by the character(s) used for the `separator` parameter. To join arrays of ints or floats, it's necessary to first convert them to strings using `nf()` or `nfs()` .
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param list array of Strings</blocktag>
<blocktag>@param separator char or String to be placed between each item</blocktag>
<blocktag>@see PApplet#split(String, String)</blocktag>
<blocktag>@see PApplet#trim(String)</blocktag>
<blocktag>@see PApplet#nf(float, int, int)</blocktag>
<blocktag>@see PApplet#nfs(float, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="splitTokens" kind="METHOD">
<body>
<first>( begin auto-generated from splitTokens.xml ) The splitTokens() function splits a String at one or many character "tokens." The , `,tokens,` , parameter specifies the character or characters to be used as a boundary.</first>
<full>
The splitTokens() function splits a String at one or many character "tokens." The `tokens` parameter specifies the character or characters to be used as a boundary.

If no `tokens` character is specified, any whitespace character is used to split. Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form feed (\\f), and space. To convert a String to an array of integers or floats, use the datatype conversion functions `int()` and `float()` to convert the array of Strings.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param value the String to be split</blocktag>
<blocktag>@param delim list of individual characters that will be used as separators</blocktag>
<blocktag>@see PApplet#split(String, String)</blocktag>
<blocktag>@see PApplet#join(String[], String)</blocktag>
<blocktag>@see PApplet#trim(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="split" kind="METHOD">
<body>
<first>( begin auto-generated from split.xml ) The split() function breaks a string into pieces using a character or string as the divider.</first>
<full>
The split() function breaks a string into pieces using a character or string as the divider. The `delim` parameter specifies the character or characters that mark the boundaries between each piece. A String[] array is returned that contains each of the pieces.

If the result is a set of numbers, you can convert the String[] array to to a float[] or int[] array using the datatype conversion functions `int()` and `float()` (see example above).

The `splitTokens()` function works in a similar fashion, except that it splits using a range of characters instead of a specific character or sequence.&lt;!-- /&gt;&lt;br /&gt; This function uses regular expressions to determine how the  `delim`  parameter divides the  `str`  parameter. Therefore, if you use characters such parentheses and brackets that are used with regular expressions as a part of the  `delim`  parameter, you'll need to put two blackslashes (\\\\) in front of the character (see example above). You can read more about &lt;a href="http://en.wikipedia.org/wiki/Regular_expression"&gt;regular expressions&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/Escape_character"&gt;escape characters&lt;/a&gt; on Wikipedia. --&gt;
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param value the String to be split</blocktag>
<blocktag>@param delim the character or String used to separate the data</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="match" kind="METHOD">
<body>
<first>( begin auto-generated from match.xml ) The match() function is used to apply a regular expression to a piece of text, and return matching groups (elements found inside parentheses) as a String array.</first>
<full>
The match() function is used to apply a regular expression to a piece of text, and return matching groups (elements found inside parentheses) as a String array. No match will return null. If no groups are specified in the regexp, but the sequence matches, an array of length one (with the matched text as the first element of the array) will be returned.

To use the function, first check to see if the result is null. If the result is null, then the sequence did not match. If the sequence did match, an array is returned. If there are groups (specified by sets of parentheses) in the regexp, then the contents of each will be returned in the array. Element [0] of a regexp match returns the entire matching string, and the match groups start at element [1] (the first group is [1], the second [2], and so on).

The syntax can be found in the reference for Java's&lt;a href="http://download.oracle.com/javase/6/docs/api/"&gt;Pattern&lt;/a&gt;class. For regular expression syntax, read the&lt;a href="http://download.oracle.com/javase/tutorial/essential/regex/"&gt;Java Tutorial&lt;/a&gt;on the topic.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param str the String to be searched</blocktag>
<blocktag>@param regexp the regexp to be used for matching</blocktag>
<blocktag>@see PApplet#matchAll(String, String)</blocktag>
<blocktag>@see PApplet#split(String, String)</blocktag>
<blocktag>@see PApplet#splitTokens(String, String)</blocktag>
<blocktag>@see PApplet#join(String[], String)</blocktag>
<blocktag>@see PApplet#trim(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="matchAll" kind="METHOD">
<body>
<first>( begin auto-generated from matchAll.xml ) This function is used to apply a regular expression to a piece of text, and return a list of matching groups (elements found inside parentheses) as a two-dimensional String array.</first>
<full>
This function is used to apply a regular expression to a piece of text, and return a list of matching groups (elements found inside parentheses) as a two-dimensional String array. No matches will return null. If no groups are specified in the regexp, but the sequence matches, a two dimensional array is still returned, but the second dimension is only of length one.

To use the function, first check to see if the result is null. If the result is null, then the sequence did not match at all. If the sequence did match, a 2D array is returned. If there are groups (specified by sets of parentheses) in the regexp, then the contents of each will be returned in the array. Assuming, a loop with counter variable i, element [i][0] of a regexp match returns the entire matching string, and the match groups start at element [i][1] (the first group is [i][1], the second [i][2], and so on).

The syntax can be found in the reference for Java's&lt;a href="http://download.oracle.com/javase/6/docs/api/"&gt;Pattern&lt;/a&gt;class. For regular expression syntax, read the&lt;a href="http://download.oracle.com/javase/tutorial/essential/regex/"&gt;Java Tutorial&lt;/a&gt;on the topic.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param str the String to be searched</blocktag>
<blocktag>@param regexp the regexp to be used for matching</blocktag>
<blocktag>@see PApplet#match(String, String)</blocktag>
<blocktag>@see PApplet#split(String, String)</blocktag>
<blocktag>@see PApplet#splitTokens(String, String)</blocktag>
<blocktag>@see PApplet#join(String[], String)</blocktag>
<blocktag>@see PApplet#trim(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseBoolean" kind="METHOD">
<body>
<first>

,Convert an integer to a boolean.</first>
<full>


Convert an integer to a boolean. Because of how Java handles upgrading numbers, this will also cover byte and char (as they will upgrade to an int without any sort of explicit cast).&lt;/p&gt;

The preprocessor will convert boolean(what) to parseBoolean(what).&lt;/p&gt;
</full>
</body>
<blocktags>
<blocktag>@return false if 0, true if any other number</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseBoolean" kind="METHOD">
<body>
<first>Convert the string "true" or "false" to a boolean.</first>
<full>
Convert the string "true" or "false" to a boolean.
</full>
</body>
<blocktags>
<blocktag>@return true if 'what' is "true" or "TRUE", false otherwise</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseBoolean" kind="METHOD">
<body>
<first>Convert an int array to a boolean array.</first>
<full>
Convert an int array to a boolean array. An int equal to zero will return false, and any other value will return true.
</full>
</body>
<blocktags>
<blocktag>@return array of boolean elements</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Note that parseInt() will un-sign a signed byte value.</first>
<full>
Note that parseInt() will un-sign a signed byte value.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Note that parseInt('5') is unlike String in the sense that it won't return 5, but the ascii value.</first>
<full>
Note that parseInt('5') is unlike String in the sense that it won't return 5, but the ascii value. This is because ((int) someChar) returns the ascii value, and parseInt() is just longhand for the cast.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Same as floor(), or an (int) cast.</first>
<full>
Same as floor(), or an (int) cast.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Parse a String into an int value.</first>
<full>
Parse a String into an int value. Returns 0 if the value is bad.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Parse a String to an int, and provide an alternate value that should be used when the number is invalid.</first>
<full>
Parse a String to an int, and provide an alternate value that should be used when the number is invalid.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Make an array of int elements from an array of String objects.</first>
<full>
Make an array of int elements from an array of String objects. If the String can't be parsed as a number, it will be set to zero. String s[] = { "1", "300", "44" }; int numbers[] = parseInt(s); numbers will contain { 1, 300, 44 }
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseInt" kind="METHOD">
<body>
<first>Make an array of int elements from an array of String objects.</first>
<full>
Make an array of int elements from an array of String objects. If the String can't be parsed as a number, its entry in the array will be set to the value of the "missing" parameter. String s[] = { "1", "300", "apple", "44" }; int numbers[] = parseInt(s, 9999); numbers will contain { 1, 300, 9999, 44 }
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="parseFloat" kind="METHOD">
<body>
<first>Convert an int to a float value.</first>
<full>
Convert an int to a float value. Also handles bytes because of Java's rules for upgrading values.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="int_nf" kind="FIELD">
<body>
<first>Integer number formatter.</first>
<full>
Integer number formatter.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nf" kind="METHOD">
<body>
<first>( begin auto-generated from nf.xml ) Utility function for formatting numbers into strings.</first>
<full>
Utility function for formatting numbers into strings. There are two versions, one for formatting floats and one for formatting ints. The values for the `digits` , `left` , and `right` parameters should always be positive integers.

As shown in the above example, `nf()` is used to add zeros to the left and/or right of a number. This is typically for aligning a list of numbers. To&lt;em&gt;remove&lt;/em&gt;digits from a floating-point number, use the `int()` , `ceil()` , `floor()` , or `round()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param nums the numbers to format</blocktag>
<blocktag>@param digits number of digits to pad with zero</blocktag>
<blocktag>@see PApplet#nfs(float, int, int)</blocktag>
<blocktag>@see PApplet#nfp(float, int, int)</blocktag>
<blocktag>@see PApplet#nfc(float, int)</blocktag>
<blocktag>@see &lt;a href="https://processing.org/reference/intconvert_.html"&gt;int(float)&lt;/a&gt;</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nf" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param num the number to format</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfc" kind="METHOD">
<body>
<first>( begin auto-generated from nfc.xml ) Utility function for formatting numbers into strings and placing appropriate commas to mark units of 1000.</first>
<full>
Utility function for formatting numbers into strings and placing appropriate commas to mark units of 1000. There are two versions, one for formatting ints and one for formatting an array of ints. The value for the `digits` parameter should always be a positive integer.

For a non-US locale, this will insert periods instead of commas, or whatever is apprioriate for that region.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param nums the numbers to format</blocktag>
<blocktag>@see PApplet#nf(float, int, int)</blocktag>
<blocktag>@see PApplet#nfp(float, int, int)</blocktag>
<blocktag>@see PApplet#nfs(float, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfc" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param num the number to format</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfs" kind="METHOD">
<body>
<first>( begin auto-generated from nfs.xml ) Utility function for formatting numbers into strings.</first>
<full>
Utility function for formatting numbers into strings. Similar to `nf()` but leaves a blank space in front of positive numbers so they align with negative numbers in spite of the minus symbol. There are two versions, one for formatting floats and one for formatting ints. The values for the `digits` , `left` , and `right` parameters should always be positive integers.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param num the number to format</blocktag>
<blocktag>@param digits number of digits to pad with zeroes</blocktag>
<blocktag>@see PApplet#nf(float, int, int)</blocktag>
<blocktag>@see PApplet#nfp(float, int, int)</blocktag>
<blocktag>@see PApplet#nfc(float, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfs" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param nums the numbers to format</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfp" kind="METHOD">
<body>
<first>( begin auto-generated from nfp.xml ) Utility function for formatting numbers into strings.</first>
<full>
Utility function for formatting numbers into strings. Similar to `nf()` but puts a "+" in front of positive numbers and a "-" in front of negative numbers. There are two versions, one for formatting floats and one for formatting ints. The values for the `digits` , `left` , and `right` parameters should always be positive integers.
</full>
</body>
<blocktags>
<blocktag>@webref data:string_functions</blocktag>
<blocktag>@param num the number to format</blocktag>
<blocktag>@param digits number of digits to pad with zeroes</blocktag>
<blocktag>@see PApplet#nf(float, int, int)</blocktag>
<blocktag>@see PApplet#nfs(float, int, int)</blocktag>
<blocktag>@see PApplet#nfc(float, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfp" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param nums the numbers to format</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nf" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param left number of digits to the left of the decimal point</blocktag>
<blocktag>@param right number of digits to the right of the decimal point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfc" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param right number of digits to the right of the decimal point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfs" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param left the number of digits to the left of the decimal point</blocktag>
<blocktag>@param right the number of digits to the right of the decimal point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="nfp" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param left the number of digits to the left of the decimal point</blocktag>
<blocktag>@param right the number of digits to the right of the decimal point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="hex" kind="METHOD">
<body>
<first>( begin auto-generated from hex.xml ) Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation.</first>
<full>
Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation. For example color(0, 102, 153) will convert to the String "FF006699". This function can help make your geeky debugging sessions much happier.

Note that the maximum number of digits is 8, because an int value can only represent up to 32 bits. Specifying more than eight digits will simply shorten the string to eight anyway.
</full>
</body>
<blocktags>
<blocktag>@webref data:conversion</blocktag>
<blocktag>@param value the value to convert</blocktag>
<blocktag>@see PApplet#unhex(String)</blocktag>
<blocktag>@see PApplet#binary(byte)</blocktag>
<blocktag>@see PApplet#unbinary(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="hex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param digits the number of digits (maximum 8)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="unhex" kind="METHOD">
<body>
<first>( begin auto-generated from unhex.xml ) Converts a String representation of a hexadecimal number to its equivalent integer value.</first>
<full>
Converts a String representation of a hexadecimal number to its equivalent integer value.
</full>
</body>
<blocktags>
<blocktag>@webref data:conversion</blocktag>
<blocktag>@param value String to convert to an integer</blocktag>
<blocktag>@see PApplet#hex(int, int)</blocktag>
<blocktag>@see PApplet#binary(byte)</blocktag>
<blocktag>@see PApplet#unbinary(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="binary" kind="METHOD">
<body>
<first>Returns a String that contains the binary value of a byte.</first>
<full>
Returns a String that contains the binary value of a byte. The returned value will always have 8 digits.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="binary" kind="METHOD">
<body>
<first>Returns a String that contains the binary value of a char.</first>
<full>
Returns a String that contains the binary value of a char. The returned value will always have 16 digits because chars are two bytes long.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="binary" kind="METHOD">
<body>
<first>Returns a String that contains the binary value of an int.</first>
<full>
Returns a String that contains the binary value of an int. The length depends on the size of the number itself. If you want a specific number of digits use binary(int what, int digits) to specify how many.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="binary" kind="METHOD">
<body>
<first>( begin auto-generated from binary.xml ) Converts a byte, char, int, or color to a String containing the equivalent binary notation.</first>
<full>
Converts a byte, char, int, or color to a String containing the equivalent binary notation. For example color(0, 102, 153, 255) will convert to the String "11111111000000000110011010011001". This function can help make your geeky debugging sessions much happier.

Note that the maximum number of digits is 32, because an int value can only represent up to 32 bits. Specifying more than 32 digits will simply shorten the string to 32 anyway.
</full>
</body>
<blocktags>
<blocktag>@webref data:conversion</blocktag>
<blocktag>@param value value to convert</blocktag>
<blocktag>@param digits number of digits to return</blocktag>
<blocktag>@see PApplet#unbinary(String)</blocktag>
<blocktag>@see PApplet#hex(int,int)</blocktag>
<blocktag>@see PApplet#unhex(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="unbinary" kind="METHOD">
<body>
<first>( begin auto-generated from unbinary.xml ) Converts a String representation of a binary number to its equivalent integer value.</first>
<full>
Converts a String representation of a binary number to its equivalent integer value. For example, unbinary("00001000") will return 8.
</full>
</body>
<blocktags>
<blocktag>@webref data:conversion</blocktag>
<blocktag>@param value String to convert to an integer</blocktag>
<blocktag>@see PApplet#binary(byte)</blocktag>
<blocktag>@see PApplet#hex(int,int)</blocktag>
<blocktag>@see PApplet#unhex(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="color" kind="METHOD">
<body>
<first>( begin auto-generated from color.xml ) Creates colors for storing in variables of the , `,color,` , datatype.</first>
<full>
Creates colors for storing in variables of the `color` datatype. The parameters are interpreted as RGB or HSB values depending on the current `colorMode()` . The default mode is RGB values from 0 to 255 and therefore, the function call `color(255, 204, 0)` will return a bright yellow color. More about how colors are stored can be found in the reference for the&lt;a href="color_datatype.html"&gt;color&lt;/a&gt;datatype.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@param gray number specifying value between white and black</blocktag>
<blocktag>@see PApplet#colorMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="color" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param fgray number specifying value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="color" kind="METHOD">
<body>
<first>As of 0116 this also takes color(#FF8800, alpha)</first>
<full>
As of 0116 this also takes color(#FF8800, alpha)
</full>
</body>
<blocktags>
<blocktag>@param alpha relative to current color range</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="color" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="color" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue values relative to the current color range</blocktag>
<blocktag>@param v2 green or saturation values relative to the current color range</blocktag>
<blocktag>@param v3 blue or brightness values relative to the current color range</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lerpColor" kind="METHOD">
<body>
<first>( begin auto-generated from lerpColor.xml ) Calculates a color or colors between two color at a specific increment.</first>
<full>
Calculates a color or colors between two color at a specific increment. The `amt` parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param c1 interpolate from this color</blocktag>
<blocktag>@param c2 interpolate to this color</blocktag>
<blocktag>@param amt between 0.0 and 1.0</blocktag>
<blocktag>@see PImage#blendColor(int, int, int)</blocktag>
<blocktag>@see PGraphics#color(float, float, float, float)</blocktag>
<blocktag>@see PApplet#lerp(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="main" kind="METHOD">
<body>
<first>main() method for running this class from the command line.</first>
<full>
main() method for running this class from the command line.

Usage: PApplet [options]&lt;class name&gt;[sketch args]&lt;ul&gt;&lt;li&gt;The [options] are one or several of the parameters seen below.&lt;li&gt;The class name is required. If you're running outside the PDE and your class is in a package, this should include the full name. That means that if the class is called Sketchy and the package is com.sketchycompany then com.sketchycompany.Sketchy should be used as the class name.&lt;li&gt;The [sketch args] are any command line parameters you want to send to the sketch itself. These will be passed into the args[] array in PApplet.

The simplest way to turn and sketch into an application is to add the following code to your program:

```
static public void main(String args[]) {   PApplet.main("YourSketchName"); }
```

That will properly launch your code from a double-clickable .jar or from the command line.

```
Parameters useful for launching or also used by the PDE: --location=x,y         Upper-lefthand corner of where the applet                        should appear on screen. If not used,                        the default is to center on the main screen. --present              Presentation mode: blanks the entire screen and                        shows the sketch by itself. If the sketch is                        smaller than the screen, the background around it                        will use the --window-color setting. --hide-stop            Use to hide the stop button in situations where                        you don't want to allow users to exit. also                        see the FAQ on information for capturing the ESC                        key when running in presentation mode. --stop-color=#xxxxxx   Color of the 'stop' text used to quit an                        sketch when it's in present mode. --window-color=#xxxxxx Background color of the window. The color used                        around the sketch when it's smaller than the                        minimum window size for the OS, and the matte                        color when using 'present' mode. --sketch-path          Location of where to save files from functions                        like saveStrings() or saveFrame(). defaults to                        the folder that the java application was                        launched from, which means if this isn't set by                        the pde, everything goes into the same folder                        as processing.exe. --display=n            Set what display should be used by this sketch.                        Displays are numbered starting from 1. This will                        be overridden by fullScreen() calls that specify                        a display. Omitting this option will cause the                        default display to be used. Parameters used by Processing when running via the PDE --external             set when the applet is being used by the PDE --editor-location=x,y  position of the upper-lefthand corner of the                        editor window, for placement of applet window All parameters *after* the sketch class name are passed to the sketch itself and available from its 'args' array while the sketch is running.
</full>
</body>
<blocktags>
<blocktag>@see PApplet#args 
```

</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="main" kind="METHOD">
<body>
<first>Convenience method so that PApplet.main(YourSketch.class) launches a sketch, rather than having to call getName() on it.</first>
<full>
Convenience method so that PApplet.main(YourSketch.class) launches a sketch, rather than having to call getName() on it.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="main" kind="METHOD">
<body>
<first>Convenience method so that PApplet.main("YourSketch") launches a sketch, rather than having to wrap it into a single element String array.</first>
<full>
Convenience method so that PApplet.main("YourSketch") launches a sketch, rather than having to wrap it into a single element String array.
</full>
</body>
<blocktags>
<blocktag>@param mainClass name of the class to load (with package if any)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="main" kind="METHOD">
<body>
<first>Convenience method so that PApplet.main("YourSketch", args) launches a sketch, rather than having to wrap it into a String array, and appending the 'args' array when not null.</first>
<full>
Convenience method so that PApplet.main("YourSketch", args) launches a sketch, rather than having to wrap it into a String array, and appending the 'args' array when not null.
</full>
</body>
<blocktags>
<blocktag>@param mainClass name of the class to load (with package if any)</blocktag>
<blocktag>@param sketchArgs command line arguments to pass to the sketch's 'args'             array. Note that this is &lt;i&gt;not&lt;/i&gt; the same as the args passed             to (and understood by) PApplet such as --display.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showSurface" kind="METHOD">
<body>
<first>Danger: available for advanced subclassing, but here be dragons.</first>
<full>
Danger: available for advanced subclassing, but here be dragons.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="startSurface" kind="METHOD">
<body>
<first>See warning in showSurface()</first>
<full>
See warning in showSurface()
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="hideMenuBar" kind="METHOD">
<body>
<first>Convenience method, should only be called by PSurface subclasses.</first>
<full>
Convenience method, should only be called by PSurface subclasses.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="runSketch" kind="METHOD">
<body>
<first>Convenience method for Python Mode to run an already-constructed sketch.</first>
<full>
Convenience method for Python Mode to run an already-constructed sketch. This makes it makes it easy to launch a sketch in Jython:&lt;pre&gt;class MySketch(PApplet):     passMySketch().runSketch();&lt;/pre&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="runSketch" kind="METHOD">
<body>
<first>Convenience method for Python Mode</first>
<full>
Convenience method for Python Mode
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginRecord" kind="METHOD">
<body>
<first>( begin auto-generated from beginRecord.xml ) Opens a new file and all subsequent drawing functions are echoed to this file as well as the display window.</first>
<full>
Opens a new file and all subsequent drawing functions are echoed to this file as well as the display window. The `beginRecord()` function requires two parameters, the first is the renderer and the second is the file name. This function is always used with `endRecord()` to stop the recording process and close the file.

Note that beginRecord() will only pick up any settings that happen after it has been called. For instance, if you call textFont() before beginRecord(), then that font will not be set for the file that you're recording to.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param renderer PDF or SVG</blocktag>
<blocktag>@param filename filename for output</blocktag>
<blocktag>@see PApplet#endRecord()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginRecord" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Begin recording (echoing) commands to the specified PGraphics object.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="endRecord" kind="METHOD">
<body>
<first>( begin auto-generated from endRecord.xml ) Stops the recording process started by , `,beginRecord(),` , and closes the file.</first>
<full>
Stops the recording process started by `beginRecord()` and closes the file.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@see PApplet#beginRecord(String, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginRaw" kind="METHOD">
<body>
<first>( begin auto-generated from beginRaw.xml ) To create vectors from 3D data, use the , `,beginRaw(),` , and , `,endRaw(),` , commands.</first>
<full>
To create vectors from 3D data, use the `beginRaw()` and `endRaw()` commands. These commands will grab the shape data just before it is rendered to the screen. At this stage, your entire scene is nothing but a long list of individual lines and triangles. This means that a shape created with `sphere()` function will be made up of hundreds of triangles, rather than a single object. Or that a multi-segment line shape (such as a curve) will be rendered as individual segments.

When using `beginRaw()` and `endRaw()` , it's possible to write to either a 2D or 3D renderer. For instance, `beginRaw()` with the PDF library will write the geometry as flattened triangles and lines, even if recording from the `P3D` renderer.

If you want a background to show up in your files, use `rect(0, 0, width, height)` after setting the `fill()` to the background color. Otherwise the background will not be rendered to the file because the background is not shape.

Using `hint(ENABLE_DEPTH_SORT)` can improve the appearance of 3D geometry drawn to 2D file formats. See the `hint()` reference for more details.

See examples in the reference for the `PDF` and `DXF` libraries for more information.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@param renderer for example, PDF or DXF</blocktag>
<blocktag>@param filename filename for output</blocktag>
<blocktag>@see PApplet#endRaw()</blocktag>
<blocktag>@see PApplet#hint(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginRaw" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Begin recording raw shape data to the specified renderer. This simply echoes to g.beginRaw(), but since is placed here (rather than generated by preproc.pl) for clarity and so that it doesn't echo the command should beginRecord() be in use.</blocktag>
<blocktag>@param rawGraphics ???</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="endRaw" kind="METHOD">
<body>
<first>( begin auto-generated from endRaw.xml ) Complement to , `,beginRaw(),` ,; they must always be used together.</first>
<full>
Complement to `beginRaw()` ; they must always be used together. See the `beginRaw()` reference for details.
</full>
</body>
<blocktags>
<blocktag>@webref output:files</blocktag>
<blocktag>@see PApplet#beginRaw(String, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadPixels" kind="METHOD">
<body>
<first>( begin auto-generated from loadPixels.xml ) Loads the pixel data for the display window into the , `,pixels[],` , array.</first>
<full>
Loads the pixel data for the display window into the `pixels[]` array. This function must always be called before reading from or writing to `pixels[]` .

renderers may or may not seem to require `loadPixels()` or `updatePixels()` . However, the rule is that any time you want to manipulate the `pixels[]` array, you must first call `loadPixels()` , and after changes have been made, call `updatePixels()` . Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.

Advanced
--------

Override the g.pixels[] function to set the pixels[] array that's part of the PApplet object. Allows the use of pixels[] in the code, rather than g.pixels[].
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@see PApplet#pixels</blocktag>
<blocktag>@see PApplet#updatePixels()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="updatePixels" kind="METHOD">
<body>
<first>( begin auto-generated from updatePixels.xml ) Updates the display window with the data in the , `,pixels[],` , array.</first>
<full>
Updates the display window with the data in the `pixels[]` array. Use in conjunction with `loadPixels()` . If you're only reading pixels from the array, there's no need to call `updatePixels()` unless there are changes.

renderers may or may not seem to require `loadPixels()` or `updatePixels()` . However, the rule is that any time you want to manipulate the `pixels[]` array, you must first call `loadPixels()` , and after changes have been made, call `updatePixels()` . Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.

Currently, none of the renderers use the additional parameters to `updatePixels()` , however this may be implemented in the future.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@see PApplet#loadPixels()</blocktag>
<blocktag>@see PApplet#pixels</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="updatePixels" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param x1 x-coordinate of the upper-left corner</blocktag>
<blocktag>@param y1 y-coordinate of the upper-left corner</blocktag>
<blocktag>@param x2 width of the region</blocktag>
<blocktag>@param y2 height of the region</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginShape" kind="METHOD">
<body>
<first>Start a new shape of type POLYGON</first>
<full>
Start a new shape of type POLYGON
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginShape" kind="METHOD">
<body>
<first>( begin auto-generated from beginShape.xml ) Using the , `,beginShape(),` , and , `,endShape(),` , functions allow creating more complex forms.</first>
<full>
Using the `beginShape()` and `endShape()` functions allow creating more complex forms. `beginShape()` begins recording vertices for a shape and `endShape()` stops recording. The value of the `MODE` parameter tells it which types of shapes to create from the provided vertices. With no mode specified, the shape can be any irregular polygon. The parameters available for beginShape() are POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `beginShape()` function, a series of `vertex()` commands must follow. To stop drawing the shape, call `endShape()` . The `vertex()` function with two parameters specifies a position in 2D and the `vertex()` function with three parameters specifies a position in 3D. Each shape will be outlined with the current stroke color and filled with the fill color.

Transformations such as `translate()` , `rotate()` , and `scale()` do not work within `beginShape()` . It is also not possible to use other shapes, such as `ellipse()` or `rect()` within `beginShape()` .

The P3D renderer settings allow `stroke()` and `fill()` settings to be altered per-vertex, however the default P2D renderer does not. Settings such as `strokeWeight()` , `strokeCap()` , and `strokeJoin()` cannot be changed while inside a `beginShape()` / `endShape()` block with any renderer.
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param kind Either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#endShape()</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="edge" kind="METHOD">
<body>
<first>Sets whether the upcoming vertex is part of an edge.</first>
<full>
Sets whether the upcoming vertex is part of an edge. Equivalent to glEdgeFlag(), for people familiar with OpenGL.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="normal" kind="METHOD">
<body>
<first>( begin auto-generated from normal.xml ) Sets the current normal vector.</first>
<full>
Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and specifies a vector perpendicular to the surface of the shape which determines how lighting affects it. Processing attempts to automatically assign normals to shapes, but since that's imperfect, this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@param nx x direction</blocktag>
<blocktag>@param ny y direction</blocktag>
<blocktag>@param nz z direction</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textureMode" kind="METHOD">
<body>
<first>( begin auto-generated from textureMode.xml ) Sets the coordinate space for texture mapping.</first>
<full>
Sets the coordinate space for texture mapping. There are two options, IMAGE, which refers to the actual coordinates of the image, and NORMAL, which refers to a normalized space of values ranging from 0 to 1. The default mode is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200). The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param mode either IMAGE or NORMAL</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
<blocktag>@see PGraphics#textureWrap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textureWrap" kind="METHOD">
<body>
<first>( begin auto-generated from textureWrap.xml ) Description to come...</first>
<full>
Description to come... ( end auto-generated from textureWrap.xml )
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param wrap Either CLAMP (default) or REPEAT</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
<blocktag>@see PGraphics#textureMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="texture" kind="METHOD">
<body>
<first>( begin auto-generated from texture.xml ) Sets a texture to be applied to vertex points.</first>
<full>
Sets a texture to be applied to vertex points. The `texture()` function must be called between `beginShape()` and `endShape()` and before any calls to `vertex()` .

When textures are in use, the fill color is ignored. Instead, use tint() to specify the color of the texture as it is applied to the shape.
</full>
</body>
<blocktags>
<blocktag>@webref image:textures</blocktag>
<blocktag>@param image reference to a PImage object</blocktag>
<blocktag>@see PGraphics#textureMode(int)</blocktag>
<blocktag>@see PGraphics#textureWrap(int)</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noTexture" kind="METHOD">
<body>
<first>Removes texture image for current shape.</first>
<full>
Removes texture image for current shape. Needs to be called between beginShape and endShape
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="vertex" kind="METHOD">
<body>
<first>Used by renderer subclasses or PShape to efficiently pass in already formatted vertex information.</first>
<full>
Used by renderer subclasses or PShape to efficiently pass in already formatted vertex information.
</full>
</body>
<blocktags>
<blocktag>@param v vertex parameters, as a float array of length VERTEX_FIELD_COUNT</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="vertex" kind="METHOD">
<body>
<first>( begin auto-generated from vertex.xml ) All shapes are constructed by connecting a series of vertices.</first>
<full>
All shapes are constructed by connecting a series of vertices. `vertex()` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the `beginShape()` and `endShape()` function.

Drawing a vertex in 3D using the `z` parameter requires the P3D parameter in combination with size as shown in the above example.

This function is also used to map a texture onto the geometry. The `texture()` function declares the texture to apply to the geometry and the `u` and `v` coordinates set define the mapping of this texture to the form. By default, the coordinates used for `u` and `v` are specified in relation to the image's size in pixels, but this relation can be changed with `textureMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x x-coordinate of the vertex</blocktag>
<blocktag>@param y y-coordinate of the vertex</blocktag>
<blocktag>@param z z-coordinate of the vertex</blocktag>
<blocktag>@param u horizontal coordinate for the texture mapping</blocktag>
<blocktag>@param v vertical coordinate for the texture mapping</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#texture(PImage)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="endContour" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="endShape" kind="METHOD">
<body>
<first>( begin auto-generated from endShape.xml ) The , `,endShape(),` , function is the companion to , `,beginShape(),` , and may only be called after , `,beginShape(),` ,.</first>
<full>
The `endShape()` function is the companion to `beginShape()` and may only be called after `beginShape()` . When `endshape()` is called, all of image data defined since the previous call to `beginShape()` is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param mode use CLOSE to close the shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape</blocktag>
<blocktag>@param filename name of file to load, can be .svg or .obj</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PApplet#createShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PShape#endShape()</blocktag>
<blocktag>@see PApplet#loadShape(String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="createShape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind either POINT, LINE, TRIANGLE, QUAD, RECT, ELLIPSE, ARC, BOX, SPHERE</blocktag>
<blocktag>@param p parameters that match the kind of shape</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadShader" kind="METHOD">
<body>
<first>( begin auto-generated from loadShader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
<blocktag>@param fragFilename name of fragment shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="loadShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vertFilename name of vertex shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shader" kind="METHOD">
<body>
<first>( begin auto-generated from shader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
<blocktag>@param shader name of shader file</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind type of shader, either POINTS, LINES, or TRIANGLES</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="resetShader" kind="METHOD">
<body>
<first>( begin auto-generated from resetShader.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="resetShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param kind type of shader, either POINTS, LINES, or TRIANGLES</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="filter" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param shader the fragment shader to apply</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="clip" kind="METHOD">
<body>
<first>( begin auto-generated from clip.xml ) Limits the rendering to the boundaries of a rectangle defined by the parameters.</first>
<full>
Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the `imageMode()` fuction, either CORNER, CORNERS, or CENTER.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param a x-coordinate of the rectangle, by default</blocktag>
<blocktag>@param b y-coordinate of the rectangle, by default</blocktag>
<blocktag>@param c width of the rectangle, by default</blocktag>
<blocktag>@param d height of the rectangle, by default</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noClip" kind="METHOD">
<body>
<first>( begin auto-generated from noClip.xml ) Disables the clipping previously started by the , `,clip(),` , function.</first>
<full>
Disables the clipping previously started by the `clip()` function.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="blendMode" kind="METHOD">
<body>
<first>( begin auto-generated from blendMode.xml ) This is a new reference entry for Processing 2.0.</first>
<full>
This is a new reference entry for Processing 2.0. It will be updated shortly.
</full>
</body>
<blocktags>
<blocktag>@webref rendering</blocktag>
<blocktag>@param mode the blending mode to use</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="bezierVertex" kind="METHOD">
<body>
<first>( begin auto-generated from bezierVertex.xml ) Specifies vertex coordinates for Bezier curves.</first>
<full>
Specifies vertex coordinates for Bezier curves. Each call to `bezierVertex()` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `bezierVertex()` is used within a `beginShape()` call, it must be prefaced with a call to `vertex()` to set the first anchor point. This function must be used between `beginShape()` and `endShape()` and only when there is no MODE parameter specified to `beginShape()` . Using the 3D version requires rendering with P3D (see the Environment reference for more information).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x2 the x-coordinate of the 1st control point</blocktag>
<blocktag>@param y2 the y-coordinate of the 1st control point</blocktag>
<blocktag>@param z2 the z-coordinate of the 1st control point</blocktag>
<blocktag>@param x3 the x-coordinate of the 2nd control point</blocktag>
<blocktag>@param y3 the y-coordinate of the 2nd control point</blocktag>
<blocktag>@param z3 the z-coordinate of the 2nd control point</blocktag>
<blocktag>@param x4 the x-coordinate of the anchor point</blocktag>
<blocktag>@param y4 the y-coordinate of the anchor point</blocktag>
<blocktag>@param z4 the z-coordinate of the anchor point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="quadraticVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param cx the x-coordinate of the control point</blocktag>
<blocktag>@param cy the y-coordinate of the control point</blocktag>
<blocktag>@param x3 the x-coordinate of the anchor point</blocktag>
<blocktag>@param y3 the y-coordinate of the anchor point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="quadraticVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param cz the z-coordinate of the control point</blocktag>
<blocktag>@param z3 the z-coordinate of the anchor point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curveVertex" kind="METHOD">
<body>
<first>( begin auto-generated from curveVertex.xml ) Specifies vertex coordinates for curves.</first>
<full>
Specifies vertex coordinates for curves. This function may only be used between `beginShape()` and `endShape()` and only when there is no MODE parameter specified to `beginShape()` . The first and last points in a series of `curveVertex()` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `curveVertex()` will draw the curve between the second, third, and fourth points. The `curveVertex()` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).
</full>
</body>
<blocktags>
<blocktag>@webref shape:vertex</blocktag>
<blocktag>@param x the x-coordinate of the vertex</blocktag>
<blocktag>@param y the y-coordinate of the vertex</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#beginShape(int)</blocktag>
<blocktag>@see PGraphics#endShape(int)</blocktag>
<blocktag>@see PGraphics#vertex(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#quadraticVertex(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curveVertex" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z the z-coordinate of the vertex</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="point" kind="METHOD">
<body>
<first>( begin auto-generated from point.xml ) Draws a point, a coordinate in space at the dimension of one pixel.</first>
<full>
Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point, and the optional third value is the depth value. Drawing this shape in 3D with the `z` parameter requires the P3D parameter in combination with `size()` as shown in the above example.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the point</blocktag>
<blocktag>@param y y-coordinate of the point</blocktag>
<blocktag>@see PGraphics#stroke(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="point" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z z-coordinate of the point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="line" kind="METHOD">
<body>
<first>( begin auto-generated from line.xml ) Draws a line (a direct path between two points) to the screen.</first>
<full>
Draws a line (a direct path between two points) to the screen. The version of `line()` with four parameters draws the line in 2D.  To color a line, use the `stroke()` function. A line cannot be filled, therefore the `fill()` function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the `strokeWeight()` function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the `z` parameter requires the P3D parameter in combination with `size()` as shown in the above example.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first point</blocktag>
<blocktag>@param y1 y-coordinate of the first point</blocktag>
<blocktag>@param x2 x-coordinate of the second point</blocktag>
<blocktag>@param y2 y-coordinate of the second point</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
<blocktag>@see PGraphics#beginShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="line" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z1 z-coordinate of the first point</blocktag>
<blocktag>@param z2 z-coordinate of the second point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="triangle" kind="METHOD">
<body>
<first>( begin auto-generated from triangle.xml ) A triangle is a plane created by connecting three points.</first>
<full>
A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first point</blocktag>
<blocktag>@param y1 y-coordinate of the first point</blocktag>
<blocktag>@param x2 x-coordinate of the second point</blocktag>
<blocktag>@param y2 y-coordinate of the second point</blocktag>
<blocktag>@param x3 x-coordinate of the third point</blocktag>
<blocktag>@param y3 y-coordinate of the third point</blocktag>
<blocktag>@see PApplet#beginShape()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="quad" kind="METHOD">
<body>
<first>( begin auto-generated from quad.xml ) A quad is a quadrilateral, a four sided polygon.</first>
<full>
A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x1 x-coordinate of the first corner</blocktag>
<blocktag>@param y1 y-coordinate of the first corner</blocktag>
<blocktag>@param x2 x-coordinate of the second corner</blocktag>
<blocktag>@param y2 y-coordinate of the second corner</blocktag>
<blocktag>@param x3 x-coordinate of the third corner</blocktag>
<blocktag>@param y3 y-coordinate of the third corner</blocktag>
<blocktag>@param x4 x-coordinate of the fourth corner</blocktag>
<blocktag>@param y4 y-coordinate of the fourth corner</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rectMode" kind="METHOD">
<body>
<first>( begin auto-generated from rectMode.xml ) Modifies the location from which rectangles draw.</first>
<full>
Modifies the location from which rectangles draw. The default mode is `rectMode(CORNER)` , which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of `rect()` to specify the width and height. The syntax `rectMode(CORNERS)` uses the first and second parameters of `rect()` to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax `rectMode(CENTER)` draws the image from its center point and uses the third and forth parameters of `rect()` to specify the image's width and height. The syntax `rectMode(RADIUS)` draws the image from its center point and uses the third and forth parameters of `rect()` to specify half of the image's width and height. The parameter must be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the mode named CENTER_RADIUS was shortened to RADIUS.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param mode either CORNER, CORNERS, CENTER, or RADIUS</blocktag>
<blocktag>@see PGraphics#rect(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rect" kind="METHOD">
<body>
<first>( begin auto-generated from rect.xml ) Draws a rectangle to the screen.</first>
<full>
Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. These parameters may be changed with the `rectMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the rectangle by default</blocktag>
<blocktag>@param b y-coordinate of the rectangle by default</blocktag>
<blocktag>@param c width of the rectangle by default</blocktag>
<blocktag>@param d height of the rectangle by default</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
<blocktag>@see PGraphics#quad(float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rect" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param r radii for all four corners</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rect" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param tl radius for top-left corner</blocktag>
<blocktag>@param tr radius for top-right corner</blocktag>
<blocktag>@param br radius for bottom-right corner</blocktag>
<blocktag>@param bl radius for bottom-left corner</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="square" kind="METHOD">
<body>
<first>( begin auto-generated from square.xml ) Draws a square to the screen.</first>
<full>
Draws a square to the screen. A square is a four-sided shape with every angle at ninety degrees and each side is the same length. By default, the first two parameters set the location of the upper-left corner, the third sets the width and height. The way these parameters are interpreted, however, may be changed with the `rectMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the rectangle by default</blocktag>
<blocktag>@param y y-coordinate of the rectangle by default</blocktag>
<blocktag>@param extent width and height of the rectangle by default</blocktag>
<blocktag>@see PGraphics#rect(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ellipseMode" kind="METHOD">
<body>
<first>( begin auto-generated from ellipseMode.xml ) The origin of the ellipse is modified by the , `,ellipseMode(),` , function.</first>
<full>
The origin of the ellipse is modified by the `ellipseMode()` function. The default configuration is `ellipseMode(CENTER)` , which specifies the location of the ellipse as the center of the shape. The `RADIUS` mode is the same, but the width and height parameters to `ellipse()` specify the radius of the ellipse, rather than the diameter. The `CORNER` mode draws the shape from the upper-left corner of its bounding box. The `CORNERS` mode uses the four parameters to `ellipse()` to set two opposing corners of the ellipse's bounding box. The parameter must be written in ALL CAPS because Processing is a case-sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param mode either CENTER, RADIUS, CORNER, or CORNERS</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#arc(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ellipse" kind="METHOD">
<body>
<first>( begin auto-generated from ellipse.xml ) Draws an ellipse (oval) in the display window.</first>
<full>
Draws an ellipse (oval) in the display window. An ellipse with an equal `width` and `height` is a circle. The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be changed with the `ellipseMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the ellipse</blocktag>
<blocktag>@param b y-coordinate of the ellipse</blocktag>
<blocktag>@param c width of the ellipse by default</blocktag>
<blocktag>@param d height of the ellipse by default</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
<blocktag>@see PApplet#arc(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="arc" kind="METHOD">
<body>
<first>( begin auto-generated from arc.xml ) Draws an arc in the display window.</first>
<full>
Draws an arc in the display window. Arcs are drawn along the outer edge of an ellipse defined by the `x` , `y` , `width` and `height` parameters. The origin or the arc's ellipse may be changed with the `ellipseMode()` function. The `start` and `stop` parameters specify the angles at which to draw the arc.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param a x-coordinate of the arc's ellipse</blocktag>
<blocktag>@param b y-coordinate of the arc's ellipse</blocktag>
<blocktag>@param c width of the arc's ellipse by default</blocktag>
<blocktag>@param d height of the arc's ellipse by default</blocktag>
<blocktag>@param start angle to start the arc, specified in radians</blocktag>
<blocktag>@param stop angle to stop the arc, specified in radians</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
<blocktag>@see PApplet#degrees(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="circle" kind="METHOD">
<body>
<first>( begin auto-generated from circle.xml ) Draws a circle to the screen.</first>
<full>
Draws a circle to the screen. By default, the first two parameters set the location of the center, and the third sets the shape's width and height. The origin may be changed with the `ellipseMode()` function.
</full>
</body>
<blocktags>
<blocktag>@webref shape:2d_primitives</blocktag>
<blocktag>@param x x-coordinate of the ellipse</blocktag>
<blocktag>@param y y-coordinate of the ellipse</blocktag>
<blocktag>@param extent width and height of the ellipse by default</blocktag>
<blocktag>@see PApplet#ellipse(float, float, float, float)</blocktag>
<blocktag>@see PApplet#ellipseMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="box" kind="METHOD">
<body>
<first>( begin auto-generated from box.xml ) A box is an extruded rectangle.</first>
<full>
A box is an extruded rectangle. A box with equal dimension on all sides is a cube.
</full>
</body>
<blocktags>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@param size dimension of the box in all dimensions (creates a cube)</blocktag>
<blocktag>@see PGraphics#sphere(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="box" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param w dimension of the box in the x-dimension</blocktag>
<blocktag>@param h dimension of the box in the y-dimension</blocktag>
<blocktag>@param d dimension of the box in the z-dimension</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sphereDetail" kind="METHOD">
<body>
<first>( begin auto-generated from sphereDetail.xml ) Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh.</first>
<full>
Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you're going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `sphereDetail()` is called again with a new parameter and so should&lt;i&gt;not&lt;/i&gt;be called prior to every `sphere()` statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.

Advanced
--------

Code for sphereDetail() submitted by toxi [031031]. Code for enhanced u/v version from davbol [080801].
</full>
</body>
<blocktags>
<blocktag>@param res number of segments (minimum 3) used per full circle revolution</blocktag>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@see PGraphics#sphere(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sphereDetail" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param ures number of segments used longitudinally per full circle revolutoin</blocktag>
<blocktag>@param vres number of segments used latitudinally from top to bottom</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="sphere" kind="METHOD">
<body>
<first>( begin auto-generated from sphere.xml ) A sphere is a hollow ball made from tessellated triangles.</first>
<full>
A sphere is a hollow ball made from tessellated triangles.

Advanced
--------



Implementation notes:

cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point

sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something

```
[toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:3d_primitives</blocktag>
<blocktag>@param r the radius of the sphere</blocktag>
<blocktag>@see PGraphics#sphereDetail(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="bezierPoint" kind="METHOD">
<body>
<first>( begin auto-generated from bezierPoint.xml ) Evaluates the Bezier at point t for points a, b, c, d.</first>
<full>
Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.

Advanced
--------

For instance, to convert the following example:

```
stroke(255, 102, 0); line(85, 20, 10, 10); line(90, 90, 15, 80); stroke(0, 0, 0); bezier(85, 20, 10, 10, 90, 90, 15, 80); // draw it in gray, using 10 steps instead of the default 20 // this is a slower way to do it, but useful if you need // to do things with the coordinates at each step stroke(128); beginShape(LINE_STRIP); for (int i = 0; i&lt;= 10; i++) {   float t = i / 10.0f;   float x = bezierPoint(85, 10, 90, 15, t);   float y = bezierPoint(20, 10, 90, 80, t);   vertex(x, y); } endShape();
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="bezierTangent" kind="METHOD">
<body>
<first>( begin auto-generated from bezierTangent.xml ) Calculates the tangent of a point on a Bezier curve.</first>
<full>
Calculates the tangent of a point on a Bezier curve. There is a good definition of&lt;a href="http://en.wikipedia.org/wiki/Tangent"target="new"&gt;&lt;em&gt;tangent&lt;/em&gt;on Wikipedia&lt;/a&gt;.

Advanced
--------

Code submitted by Dave Bollinger (davol) for release 0136.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="bezierDetail" kind="METHOD">
<body>
<first>( begin auto-generated from bezierDetail.xml ) Sets the resolution at which Beziers display.</first>
<full>
Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param detail resolution of the curves</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="bezier" kind="METHOD">
<body>
<first>( begin auto-generated from bezier.xml ) Draws a Bezier curve on the screen.</first>
<full>
Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).

Advanced
--------

Draw a cubic bezier curve. The first and last points are the on-curve points. The middle two are the 'control' points, or 'handles' in an application like Illustrator.

Identical to typing:

```
beginShape(); vertex(x1, y1); bezierVertex(x2, y2, x3, y3, x4, y4); endShape();
```

In Postscript-speak, this would be:

```
moveto(x1, y1); curveto(x2, y2, x3, y3, x4, y4);
```

If you were to try and continue that curve like so:

```
curveto(x5, y5, x6, y6, x7, y7);
```

This would be done in processing by adding these statements:

```
bezierVertex(x5, y5, x6, y6, x7, y7)
```

To draw a quadratic (instead of cubic) curve, use the control point twice by doubling it:

```
bezier(x1, y1, cx, cy, cx, cy, x2, y2);
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param x1 coordinates for the first anchor point</blocktag>
<blocktag>@param y1 coordinates for the first anchor point</blocktag>
<blocktag>@param z1 coordinates for the first anchor point</blocktag>
<blocktag>@param x2 coordinates for the first control point</blocktag>
<blocktag>@param y2 coordinates for the first control point</blocktag>
<blocktag>@param z2 coordinates for the first control point</blocktag>
<blocktag>@param x3 coordinates for the second control point</blocktag>
<blocktag>@param y3 coordinates for the second control point</blocktag>
<blocktag>@param z3 coordinates for the second control point</blocktag>
<blocktag>@param x4 coordinates for the second anchor point</blocktag>
<blocktag>@param y4 coordinates for the second anchor point</blocktag>
<blocktag>@param z4 coordinates for the second anchor point</blocktag>
<blocktag>@see PGraphics#bezierVertex(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curvePoint" kind="METHOD">
<body>
<first>( begin auto-generated from curvePoint.xml ) Evalutes the curve at point t for points a, b, c, d.</first>
<full>
Evalutes the curve at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are the control points, and b and c are the points on the curve. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a curve at t.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first control point</blocktag>
<blocktag>@param b coordinate of first point on the curve</blocktag>
<blocktag>@param c coordinate of second point on the curve</blocktag>
<blocktag>@param d coordinate of second control point</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#bezierPoint(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curveTangent" kind="METHOD">
<body>
<first>( begin auto-generated from curveTangent.xml ) Calculates the tangent of a point on a curve.</first>
<full>
Calculates the tangent of a point on a curve. There's a good definition of&lt;em&gt;&lt;a href="http://en.wikipedia.org/wiki/Tangent"target="new"&gt;tangent&lt;/em&gt;on Wikipedia&lt;/a&gt;.

Advanced
--------

Code thanks to Dave Bollinger (Bug #715)
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param a coordinate of first point on the curve</blocktag>
<blocktag>@param b coordinate of first control point</blocktag>
<blocktag>@param c coordinate of second control point</blocktag>
<blocktag>@param d coordinate of second point on the curve</blocktag>
<blocktag>@param t value between 0 and 1</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curvePoint(float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#bezierTangent(float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curveDetail" kind="METHOD">
<body>
<first>( begin auto-generated from curveDetail.xml ) Sets the resolution at which curves display.</first>
<full>
Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param detail resolution of the curves</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curveTightness" kind="METHOD">
<body>
<first>( begin auto-generated from curveTightness.xml ) Modifies the quality of forms created with , `,curve(),` , and , `,curveVertex(),` ,.</first>
<full>
Modifies the quality of forms created with `curve()` and `curveVertex()` . The parameter `squishy` determines how the curve fits to the vertex points. The value 0.0 is the default value for `squishy` (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.
</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param tightness amount of deformation from the original vertices</blocktag>
<blocktag>@see PGraphics#curve(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curve" kind="METHOD">
<body>
<first>( begin auto-generated from curve.xml ) Draws a curved line on the screen.</first>
<full>
Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `curve()` functions together or using `curveVertex()` . An additional function called `curveTightness()` provides control for the visual quality of the curve. The `curve()` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).

Advanced
--------

As of revision 0070, this function no longer doubles the first and last points. The curves are a bit more boring, but it's more mathematically correct, and properly mirrored in curvePoint().

Identical to typing out:

```
beginShape(); curveVertex(x1, y1); curveVertex(x2, y2); curveVertex(x3, y3); curveVertex(x4, y4); endShape();
```


</full>
</body>
<blocktags>
<blocktag>@webref shape:curves</blocktag>
<blocktag>@param x1 coordinates for the beginning control point</blocktag>
<blocktag>@param y1 coordinates for the beginning control point</blocktag>
<blocktag>@param x2 coordinates for the first point</blocktag>
<blocktag>@param y2 coordinates for the first point</blocktag>
<blocktag>@param x3 coordinates for the second point</blocktag>
<blocktag>@param y3 coordinates for the second point</blocktag>
<blocktag>@param x4 coordinates for the ending control point</blocktag>
<blocktag>@param y4 coordinates for the ending control point</blocktag>
<blocktag>@see PGraphics#curveVertex(float, float)</blocktag>
<blocktag>@see PGraphics#curveTightness(float)</blocktag>
<blocktag>@see PGraphics#bezier(float, float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="curve" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z1 coordinates for the beginning control point</blocktag>
<blocktag>@param z2 coordinates for the first point</blocktag>
<blocktag>@param z3 coordinates for the second point</blocktag>
<blocktag>@param z4 coordinates for the ending control point</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="imageMode" kind="METHOD">
<body>
<first>( begin auto-generated from imageMode.xml ) Modifies the location from which images draw.</first>
<full>
Modifies the location from which images draw. The default mode is `imageMode(CORNER)` , which specifies the location to be the upper left corner and uses the fourth and fifth parameters of `image()` to set the image's width and height. The syntax `imageMode(CORNERS)` uses the second and third parameters of `image()` to set the location of one corner of the image and uses the fourth and fifth parameters to set the opposite corner. Use `imageMode(CENTER)` to draw images centered at the given x and y position.

The parameter to `imageMode()` must be written in ALL CAPS because Processing is a case-sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param mode either CORNER, CORNERS, or CENTER</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="image" kind="METHOD">
<body>
<first>( begin auto-generated from image.xml ) Displays images to the screen.</first>
<full>
Displays images to the screen. The images must be in the sketch's "data" directory to load correctly. Select "Add file..." from the "Sketch" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The `img` parameter specifies the image to display and the `x` and `y` parameters define the location of the image from its upper-left corner. The image is displayed at its original size unless the `width` and `height` parameters specify a different size.

The `imageMode()` function changes the way the parameters work. For example, a call to `imageMode(CORNERS)` will change the `width` and `height` parameters to define the x and y values of the opposite corner of the image.

The color of an image may be modified with the `tint()` function. This function will maintain transparency for GIF and PNG images.

Advanced
--------

Starting with release 0124, when using the default (JAVA2D) renderer, smooth() will also improve image quality of resized images.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@param img the image to display</blocktag>
<blocktag>@param a x-coordinate of the image by default</blocktag>
<blocktag>@param b y-coordinate of the image by default</blocktag>
<blocktag>@see PApplet#loadImage(String, String)</blocktag>
<blocktag>@see PImage</blocktag>
<blocktag>@see PGraphics#imageMode(int)</blocktag>
<blocktag>@see PGraphics#tint(float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="image" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c width to display the image by default</blocktag>
<blocktag>@param d height to display the image by default</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="image" kind="METHOD">
<body>
<first>Draw an image(), also specifying u/v coordinates.</first>
<full>
Draw an image(), also specifying u/v coordinates. In this method, the  u, v coordinates are always based on image space location, regardless of the current textureMode().
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shapeMode" kind="METHOD">
<body>
<first>( begin auto-generated from shapeMode.xml ) Modifies the location from which shapes draw.</first>
<full>
Modifies the location from which shapes draw. The default mode is `shapeMode(CORNER)` , which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of `shape()` to specify the width and height. The syntax `shapeMode(CORNERS)` uses the first and second parameters of `shape()` to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax `shapeMode(CENTER)` draws the shape from its center point and uses the third and forth parameters of `shape()` to specify the width and height. The parameter must be written in "ALL CAPS" because Processing is a case sensitive language.
</full>
</body>
<blocktags>
<blocktag>@webref shape:loading_displaying</blocktag>
<blocktag>@param mode either CORNER, CORNERS, CENTER</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PGraphics#shape(PShape)</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shape" kind="METHOD">
<body>
<first>( begin auto-generated from shape.xml ) Displays shapes to the screen.</first>
<full>
Displays shapes to the screen. The shapes must be in the sketch's "data" directory to load correctly. Select "Add file..." from the "Sketch" menu to add the shape. Processing currently works with SVG shapes only. The `sh` parameter specifies the shape to display and the `x` and `y` parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the `width` and `height` parameters specify a different size. The `shapeMode()` function changes the way the parameters work. A call to `shapeMode(CORNERS)` , for example, will change the width and height parameters to define the x and y values of the opposite corner of the shape.

Note complex shapes may draw awkwardly with P3D. This renderer does not yet support shapes that have holes or complicated breaks.
</full>
</body>
<blocktags>
<blocktag>@webref shape:loading_displaying</blocktag>
<blocktag>@param shape the shape to display</blocktag>
<blocktag>@param x x-coordinate of the shape</blocktag>
<blocktag>@param y y-coordinate of the shape</blocktag>
<blocktag>@see PShape</blocktag>
<blocktag>@see PApplet#loadShape(String)</blocktag>
<blocktag>@see PGraphics#shapeMode(int) Convenience method to draw at a particular location.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shape" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param a x-coordinate of the shape</blocktag>
<blocktag>@param b y-coordinate of the shape</blocktag>
<blocktag>@param c width to display the shape</blocktag>
<blocktag>@param d height to display the shape</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textAlign" kind="METHOD">
<body>
<first>( begin auto-generated from textAlign.xml ) Sets the current alignment for drawing text.</first>
<full>
Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the `x` and `y` parameters of the `text()` function.

In Processing 0125 and later, an optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current `textDescent()` . For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.

When using `text()` with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)

The vertical alignment is based on the value of `textAscent()` , which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of `textAscent()` or `textDescent()` so that the hack works even if you change the size of the font.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param alignX horizontal alignment, either LEFT, CENTER, or RIGHT</blocktag>
<blocktag>@param alignY vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textAscent" kind="METHOD">
<body>
<first>( begin auto-generated from textAscent.xml ) Returns ascent of the current font at its current size.</first>
<full>
Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `textAscent()` and `textDescent()` values will give you the total height of the line.
</full>
</body>
<blocktags>
<blocktag>@webref typography:metrics</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textDescent" kind="METHOD">
<body>
<first>( begin auto-generated from textDescent.xml ) Returns descent of the current font at its current size.</first>
<full>
Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the `textAscent()` and `textDescent()` values will give you the total height of the line.
</full>
</body>
<blocktags>
<blocktag>@webref typography:metrics</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textFont" kind="METHOD">
<body>
<first>( begin auto-generated from textFont.xml ) Sets the current font that will be drawn with the , `,text(),` , function.</first>
<full>
Sets the current font that will be drawn with the `text()` function. Fonts must be loaded with `loadFont()` before it can be used. This font will be used in all subsequent calls to the `text()` function. If no `size` parameter is input, the font will appear at its original size (the size it was created at with the "Create Font..." tool) until it is changed with `textSize()` .

Because fonts are usually bitmaped, you should create fonts at the sizes that will be used most commonly. Using `textFont()` without the size parameter will result in the cleanest-looking text.

With the default (JAVA2D) and PDF renderers, it's also possible to enable the use of native fonts via the command `hint(ENABLE_NATIVE_FONTS)` . This will produce vector text in JAVA2D sketches and PDF output in cases where the vector data is available: when the font is still installed, or the font is created via the `createFont()` function (rather than the Create Font tool).
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param which any variable of the type PFont</blocktag>
<blocktag>@see PApplet#createFont(String, float, boolean)</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textFont" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param size the size of the letters in units of pixels</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textLeading" kind="METHOD">
<body>
<first>( begin auto-generated from textLeading.xml ) Sets the spacing between lines of text in units of pixels.</first>
<full>
Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the `text()` function.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param leading the size in pixels for spacing between lines</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textMode" kind="METHOD">
<body>
<first>( begin auto-generated from textMode.xml ) Sets the way text draws to the screen.</first>
<full>
Sets the way text draws to the screen. In the default configuration, the `MODEL` mode, it's possible to rotate, scale, and place letters in two and three dimensional space.

The `SHAPE` mode draws text using the the glyph outlines of individual characters rather than as textures. This mode is only supported with the `PDF` and `P3D` renderer settings. With the `PDF` renderer, you must call `textMode(SHAPE)` before any other drawing occurs. If the outlines are not available, then `textMode(SHAPE)` will be ignored and `textMode(MODEL)` will be used instead.

The `textMode(SHAPE)` option in `P3D` can be combined with `beginRaw()` to write vector-accurate text to 2D and 3D output files, for instance `DXF` or `PDF` . The `SHAPE` mode is not currently optimized for `P3D` , so if recording shape data, use `textMode(MODEL)` until you're ready to capture the geometry with `beginRaw()` .
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param mode either MODEL or SHAPE</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#beginRaw(PGraphics)</blocktag>
<blocktag>@see PApplet#createFont(String, float, boolean)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textSize" kind="METHOD">
<body>
<first>( begin auto-generated from textSize.xml ) Sets the current font size.</first>
<full>
Sets the current font size. This size will be used in all subsequent calls to the `text()` function. Font size is measured in units of pixels.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param size the size of the letters in units of pixels</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textWidth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param c the character to measure</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textWidth" kind="METHOD">
<body>
<first>( begin auto-generated from textWidth.xml ) Calculates and returns the width of any character or text string.</first>
<full>
Calculates and returns the width of any character or text string.
</full>
</body>
<blocktags>
<blocktag>@webref typography:attributes</blocktag>
<blocktag>@param str the String of characters to measure</blocktag>
<blocktag>@see PApplet#loadFont(String)</blocktag>
<blocktag>@see PFont#PFont</blocktag>
<blocktag>@see PGraphics#text(String, float, float)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="textWidth" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>( begin auto-generated from text.xml ) Draws text to the screen.</first>
<full>
Draws text to the screen. Displays the information specified in the `data` or `stringdata` parameters on the screen in the position specified by the `x` and `y` parameters and the optional `z` parameter. A default font will be used unless a font is set with the `textFont()` function. Change the color of the text with the `fill()` function. The text displays in relation to the `textAlign()` function, which gives the option to draw to the left, right, and center of the coordinates.

The `x2` and `y2` parameters define a rectangular area to display within and may only be used with string data. For text drawn inside a rectangle, the coordinates are interpreted based on the current `rectMode()` setting.
</full>
</body>
<blocktags>
<blocktag>@webref typography:loading_displaying</blocktag>
<blocktag>@param c the alphanumeric character to be displayed</blocktag>
<blocktag>@param x x-coordinate of text</blocktag>
<blocktag>@param y y-coordinate of text</blocktag>
<blocktag>@see PGraphics#textAlign(int, int)</blocktag>
<blocktag>@see PGraphics#textFont(PFont)</blocktag>
<blocktag>@see PGraphics#textMode(int)</blocktag>
<blocktag>@see PGraphics#textSize(float)</blocktag>
<blocktag>@see PGraphics#textLeading(float)</blocktag>
<blocktag>@see PGraphics#textWidth(String)</blocktag>
<blocktag>@see PGraphics#textAscent()</blocktag>
<blocktag>@see PGraphics#textDescent()</blocktag>
<blocktag>@see PGraphics#rectMode(int)</blocktag>
<blocktag>@see PGraphics#fill(int, float)</blocktag>
<blocktag>@see_external String</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z z-coordinate of text</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Draw a chunk of text. Newlines that are \n (Unix newline or linefeed char, ascii 10) are honored, but \r (carriage return, Windows and Mac OS) are ignored.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Method to draw text from an array of chars. This method will usually be more efficient than drawing from a String object, because the String will not be converted to a char array before drawing.
</full>
</body>
<blocktags>
<blocktag>@param chars the alphanumberic symbols to be displayed</blocktag>
<blocktag>@param start array index at which to start writing characters</blocktag>
<blocktag>@param stop array index at which to stop writing characters</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>Same as above but with a z coordinate.</first>
<full>
Same as above but with a z coordinate.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Draw text in a box that is constrained to a particular size. The current rectMode() determines what the coordinates mean (whether x1/y1/x2/y2 or x/y/w/h).&lt;P/&gt;Note that the x,y coords of the start of the box will align with the *ascent* of the text, not the baseline, as is the case for the other text() functions.&lt;P/&gt;Newlines that are \n (Unix newline or linefeed char, ascii 10) are honored, and \r (carriage return, Windows and Mac OS) are ignored.
</full>
</body>
<blocktags>
<blocktag>@param x1 by default, the x-coordinate of text, see rectMode() for more info</blocktag>
<blocktag>@param y1 by default, the y-coordinate of text, see rectMode() for more info</blocktag>
<blocktag>@param x2 by default, the width of the text box, see rectMode() for more info</blocktag>
<blocktag>@param y2 by default, the height of the text box, see rectMode() for more info</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="text" kind="METHOD">
<body>
<first>This does a basic number formatting, to avoid the generally ugly appearance of printing floats.</first>
<full>
This does a basic number formatting, to avoid the generally ugly appearance of printing floats. Users who want more control should use their own nf() cmmand, or if they want the long, ugly version of float, use String.valueOf() to convert the float to a String first.
</full>
</body>
<blocktags>
<blocktag>@param num the numeric value to be displayed</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="push" kind="METHOD">
<body>
<first>( begin auto-generated from push.xml ) The , `,push(),` , function saves the current drawing style settings and transformations, while , `,pop(),` , restores these settings.</first>
<full>
The `push()` function saves the current drawing style settings and transformations, while `pop()` restores these settings. Note that these functions are always used together. They allow you to change the style and transformation settings and later return to what you had. When a new state is started with push(), it builds on the current style and transform information.

 `push()` stores information related to the current transformation state and style settings controlled by the following functions: `rotate()` , `translate()` , `scale()` , `fill()` , `stroke()` , `tint()` , `strokeWeight()` , `strokeCap()` , `strokeJoin()` , `imageMode()` , `rectMode()` , `ellipseMode()` , `colorMode()` , `textAlign()` , `textFont()` , `textMode()` , `textSize()` , `textLeading()` .

The `push()` and `pop()` functions were added with Processing 3.5. They can be used in place of `pushMatrix()` , `popMatrix()` , `pushStyles()` , and `popStyles()` . The difference is that push() and pop() control both the transformations (rotate, scale, translate) and the drawing styles at the same time.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#pop()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pop" kind="METHOD">
<body>
<first>( begin auto-generated from pop.xml ) The , `,pop(),` , function restores the previous drawing style settings and transformations after , `,push(),` , has changed them.</first>
<full>
The `pop()` function restores the previous drawing style settings and transformations after `push()` has changed them. Note that these functions are always used together. They allow you to change the style and transformation settings and later return to what you had. When a new state is started with push(), it builds on the current style and transform information.


 `push()` stores information related to the current transformation state and style settings controlled by the following functions: `rotate()` , `translate()` , `scale()` , `fill()` , `stroke()` , `tint()` , `strokeWeight()` , `strokeCap()` , `strokeJoin()` , `imageMode()` , `rectMode()` , `ellipseMode()` , `colorMode()` , `textAlign()` , `textFont()` , `textMode()` , `textSize()` , `textLeading()` .

The `push()` and `pop()` functions were added with Processing 3.5. They can be used in place of `pushMatrix()` , `popMatrix()` , `pushStyles()` , and `popStyles()` . The difference is that push() and pop() control both the transformations (rotate, scale, translate) and the drawing styles at the same time.
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#push()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pushMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from pushMatrix.xml ) Pushes the current transformation matrix onto the matrix stack.</first>
<full>
Pushes the current transformation matrix onto the matrix stack. Understanding `pushMatrix()` and `popMatrix()` requires understanding the concept of a matrix stack. The `pushMatrix()` function saves the current coordinate system to the stack and `popMatrix()` restores the prior coordinate system. `pushMatrix()` and `popMatrix()` are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#scale(float)</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="popMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from popMatrix.xml ) Pops the current transformation matrix off the matrix stack.</first>
<full>
Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The `pushMatrix()` function saves the current coordinate system to the stack and `popMatrix()` restores the prior coordinate system. `pushMatrix()` and `popMatrix()` are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="translate" kind="METHOD">
<body>
<first>( begin auto-generated from translate.xml ) Specifies an amount to displace objects within the display window.</first>
<full>
Specifies an amount to displace objects within the display window. The `x` parameter specifies left/right translation, the `y` parameter specifies up/down translation, and the `z` parameter specifies translations toward/away from the screen. Using this function with the `z` parameter requires using P3D as a parameter in combination with size as shown in the above example. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `translate(50, 0)` and then `translate(20, 0)` is the same as `translate(70, 0)` . If `translate()` is called within `draw()` , the transformation is reset when the loop begins again. This function can be further controlled by the `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param x left/right translation</blocktag>
<blocktag>@param y up/down translation</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="translate" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z forward/backward translation</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rotate" kind="METHOD">
<body>
<first>( begin auto-generated from rotate.xml ) Rotates a shape the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the `radians()` function.

Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotate(HALF_PI)` and then `rotate(HALF_PI)` is the same as `rotate(PI)` . All tranformations are reset when `draw()` begins again.

Technically, `rotate()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rotateX" kind="METHOD">
<body>
<first>( begin auto-generated from rotateX.xml ) Rotates a shape around the x-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the x-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateX(PI/2)` and then `rotateX(PI/2)` is the same as `rotateX(PI)` . If `rotateX()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the example above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rotateY" kind="METHOD">
<body>
<first>( begin auto-generated from rotateY.xml ) Rotates a shape around the y-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the y-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateY(PI/2)` and then `rotateY(PI/2)` is the same as `rotateY(PI)` . If `rotateY()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the examples above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rotateZ" kind="METHOD">
<body>
<first>( begin auto-generated from rotateZ.xml ) Rotates a shape around the z-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Rotates a shape around the z-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `rotateZ(PI/2)` and then `rotateZ(PI/2)` is the same as `rotateZ(PI)` . If `rotateZ()` is called within the `draw()` , the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to `size()` as shown in the examples above.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of rotation specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="rotate" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Rotate about a vector in space. Same as the glRotatef() function.
</full>
</body>
<blocktags>
<blocktag>@nowebref</blocktag>
<blocktag>@param x</blocktag>
<blocktag>@param y</blocktag>
<blocktag>@param z</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="scale" kind="METHOD">
<body>
<first>( begin auto-generated from scale.xml ) Increases or decreases the size of a shape by expanding and contracting vertices.</first>
<full>
Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `scale(2.0)` increases the dimension of a shape by 200%. Transformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `scale(2.0)` and then `scale(1.5)` is the same as `scale(3.0)` . If `scale()` is called within `draw()` , the transformation is reset when the loop begins again. Using this fuction with the `z` parameter requires using P3D as a parameter for `size()` as shown in the example above. This function can be further controlled by `pushMatrix()` and `popMatrix()` .
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param s percentage to scale the object</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#rotate(float)</blocktag>
<blocktag>@see PGraphics#rotateX(float)</blocktag>
<blocktag>@see PGraphics#rotateY(float)</blocktag>
<blocktag>@see PGraphics#rotateZ(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="scale" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Scale in X and Y. Equivalent to scale(sx, sy, 1). Not recommended for use in 3D, because the z-dimension is just scaled by 1, since there's no way to know what else to scale it by.
</full>
</body>
<blocktags>
<blocktag>@param x percentage to scale the object in the x-axis</blocktag>
<blocktag>@param y percentage to scale the object in the y-axis</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="scale" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z percentage to scale the object in the z-axis</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shearX" kind="METHOD">
<body>
<first>( begin auto-generated from shearX.xml ) Shears a shape around the x-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Shears a shape around the x-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `shearX(PI/2)` and then `shearX(PI/2)` is the same as `shearX(PI)` . If `shearX()` is called within the `draw()` , the transformation is reset when the loop begins again.

Technically, `shearX()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of shear specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#shearY(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shearY" kind="METHOD">
<body>
<first>( begin auto-generated from shearY.xml ) Shears a shape around the y-axis the amount specified by the , `,angle,` , parameter.</first>
<full>
Shears a shape around the y-axis the amount specified by the `angle` parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the `radians()` function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling `shearY(PI/2)` and then `shearY(PI/2)` is the same as `shearY(PI)` . If `shearY()` is called within the `draw()` , the transformation is reset when the loop begins again.

Technically, `shearY()` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the `pushMatrix()` and `popMatrix()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@param angle angle of shear specified in radians</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#shearX(float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PApplet#radians(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="resetMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from resetMatrix.xml ) Replaces the current matrix with the identity matrix.</first>
<full>
Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
<blocktag>@see PGraphics#printMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="applyMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from applyMatrix.xml ) Multiplies the current matrix by the one specified through the parameters.</first>
<full>
Multiplies the current matrix by the one specified through the parameters. This is very slow because it will try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function in OpenGL is glMultMatrix().
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@source</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#printMatrix()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="applyMatrix" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param n00 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n01 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n02 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n10 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n11 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n12 numbers which define the 4x4 matrix to be multiplied</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="applyMatrix" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param n03 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n13 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n20 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n21 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n22 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n23 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n30 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n31 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n32 numbers which define the 4x4 matrix to be multiplied</blocktag>
<blocktag>@param n33 numbers which define the 4x4 matrix to be multiplied</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="getMatrix" kind="METHOD">
<body>
<first>Copy the current transformation matrix into the specified target.</first>
<full>
Copy the current transformation matrix into the specified target. Pass in null to create a new matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="getMatrix" kind="METHOD">
<body>
<first>Copy the current transformation matrix into the specified target.</first>
<full>
Copy the current transformation matrix into the specified target. Pass in null to create a new matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation matrix to the contents of another.</first>
<full>
Set the current transformation matrix to the contents of another.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation to the contents of the specified source.</first>
<full>
Set the current transformation to the contents of the specified source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation to the contents of the specified source.</first>
<full>
Set the current transformation to the contents of the specified source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="printMatrix" kind="METHOD">
<body>
<first>( begin auto-generated from printMatrix.xml ) Prints the current matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref transform</blocktag>
<blocktag>@see PGraphics#pushMatrix()</blocktag>
<blocktag>@see PGraphics#popMatrix()</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="beginCamera" kind="METHOD">
<body>
<first>( begin auto-generated from beginCamera.xml ) The , `,beginCamera(),` , and , `,endCamera(),` , functions enable advanced customization of the camera space.</first>
<full>
The `beginCamera()` and `endCamera()` functions enable advanced customization of the camera space. The functions are useful if you want to more control over camera movement, however for most users, the `camera()` function will be sufficient.

The camera functions will replace any transformations (such as `rotate()` or `translate()` ) that occur before them in `draw()` , but they will not automatically replace the camera transform itself. For this reason, camera functions should be placed at the beginning of `draw()` (so that transformations happen afterwards), and the `camera()` function can be used after `beginCamera()` if you want to reset the camera before applying transformations.

This function sets the matrix mode to the camera matrix so calls such as `translate()` , `rotate()` , applyMatrix() and resetMatrix() affect the camera. `beginCamera()` should always be used with a following `endCamera()` and pairs of `beginCamera()` and `endCamera()` cannot be nested.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#applyMatrix(PMatrix)</blocktag>
<blocktag>@see PGraphics#resetMatrix()</blocktag>
<blocktag>@see PGraphics#translate(float, float, float)</blocktag>
<blocktag>@see PGraphics#scale(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="endCamera" kind="METHOD">
<body>
<first>( begin auto-generated from endCamera.xml ) The , `,beginCamera(),` , and , `,endCamera(),` , functions enable advanced customization of the camera space.</first>
<full>
The `beginCamera()` and `endCamera()` functions enable advanced customization of the camera space. Please see the reference for `beginCamera()` for a description of how the functions are used.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="camera" kind="METHOD">
<body>
<first>( begin auto-generated from camera.xml ) Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing upward.</first>
<full>
Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be seen from different angles. The version without any parameters sets the camera to the default position, pointing to the center of the display window with the Y axis as up. The default values are `camera(width/2.0, height/2.0, (height/2.0) / tan(PI*30.0 / 180.0), width/2.0, height/2.0, 0, 0, 1, 0)` . This function is similar to `gluLookAt()` in OpenGL, but it first clears the current camera settings.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#frustum(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="camera" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param eyeX x-coordinate for the eye</blocktag>
<blocktag>@param eyeY y-coordinate for the eye</blocktag>
<blocktag>@param eyeZ z-coordinate for the eye</blocktag>
<blocktag>@param centerX x-coordinate for the center of the scene</blocktag>
<blocktag>@param centerY y-coordinate for the center of the scene</blocktag>
<blocktag>@param centerZ z-coordinate for the center of the scene</blocktag>
<blocktag>@param upX usually 0.0, 1.0, or -1.0</blocktag>
<blocktag>@param upY usually 0.0, 1.0, or -1.0</blocktag>
<blocktag>@param upZ usually 0.0, 1.0, or -1.0</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="printCamera" kind="METHOD">
<body>
<first>( begin auto-generated from printCamera.xml ) Prints the current camera matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current camera matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ortho" kind="METHOD">
<body>
<first>( begin auto-generated from ortho.xml ) Sets an orthographic projection and defines a parallel clipping volume.</first>
<full>
Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear the same size, regardless of whether they are near or far from the camera. The parameters to this function specify the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default is used: ortho(0, width, 0, height, -10, 10).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ortho" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param left left plane of the clipping volume</blocktag>
<blocktag>@param right right plane of the clipping volume</blocktag>
<blocktag>@param bottom bottom plane of the clipping volume</blocktag>
<blocktag>@param top top plane of the clipping volume</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ortho" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param near maximum distance from the origin to the viewer</blocktag>
<blocktag>@param far maximum distance from the origin away from the viewer</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="perspective" kind="METHOD">
<body>
<first>( begin auto-generated from perspective.xml ) Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones.</first>
<full>
Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more accurately than orthographic projection. The version of perspective without parameters sets the default perspective and the version with four parameters allows the programmer to set the area precisely. The default values are: perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="perspective" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param fovy field-of-view angle (in radians) for vertical direction</blocktag>
<blocktag>@param aspect ratio of width to height</blocktag>
<blocktag>@param zNear z-position of nearest clipping plane</blocktag>
<blocktag>@param zFar z-position of farthest clipping plane</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="frustum" kind="METHOD">
<body>
<first>( begin auto-generated from frustum.xml ) Sets a perspective matrix defined through the parameters.</first>
<full>
Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current perspective matrix rather than muliplying itself with it.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@param left left coordinate of the clipping plane</blocktag>
<blocktag>@param right right coordinate of the clipping plane</blocktag>
<blocktag>@param bottom bottom coordinate of the clipping plane</blocktag>
<blocktag>@param top top coordinate of the clipping plane</blocktag>
<blocktag>@param near near component of the clipping plane; must be greater than zero</blocktag>
<blocktag>@param far far component of the clipping plane; must be greater than the near value</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#beginCamera()</blocktag>
<blocktag>@see PGraphics#endCamera()</blocktag>
<blocktag>@see PGraphics#perspective(float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="printProjection" kind="METHOD">
<body>
<first>( begin auto-generated from printProjection.xml ) Prints the current projection matrix to the Console (the text window at the bottom of Processing).</first>
<full>
Prints the current projection matrix to the Console (the text window at the bottom of Processing).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:camera</blocktag>
<blocktag>@see PGraphics#camera(float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="screenX" kind="METHOD">
<body>
<first>( begin auto-generated from screenX.xml ) Takes a three-dimensional X, Y, Z position and returns the X value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the X value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenY(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="screenY" kind="METHOD">
<body>
<first>( begin auto-generated from screenY.xml ) Takes a three-dimensional X, Y, Z position and returns the Y value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the Y value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenX(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="screenX" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="screenY" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="screenZ" kind="METHOD">
<body>
<first>( begin auto-generated from screenZ.xml ) Takes a three-dimensional X, Y, Z position and returns the Z value for where it will appear on a (two-dimensional) screen.</first>
<full>
Takes a three-dimensional X, Y, Z position and returns the Z value for where it will appear on a (two-dimensional) screen.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#screenX(float, float, float)</blocktag>
<blocktag>@see PGraphics#screenY(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="modelX" kind="METHOD">
<body>
<first>( begin auto-generated from modelX.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the X value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The X value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelY(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="modelY" kind="METHOD">
<body>
<first>( begin auto-generated from modelY.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the Y value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Y value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelX(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelZ(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="modelZ" kind="METHOD">
<body>
<first>( begin auto-generated from modelZ.xml ) Returns the three-dimensional X, Y, Z position in model space.</first>
<full>
Returns the three-dimensional X, Y, Z position in model space. This returns the Z value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Z value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.

In the example, the `modelX()` , `modelY()` , and `modelZ()` functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:coordinates</blocktag>
<blocktag>@param x 3D x-coordinate to be mapped</blocktag>
<blocktag>@param y 3D y-coordinate to be mapped</blocktag>
<blocktag>@param z 3D z-coordinate to be mapped</blocktag>
<blocktag>@see PGraphics#modelX(float, float, float)</blocktag>
<blocktag>@see PGraphics#modelY(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pushStyle" kind="METHOD">
<body>
<first>( begin auto-generated from pushStyle.xml ) The , `,pushStyle(),` , function saves the current style settings and , `,popStyle(),` , restores the prior settings.</first>
<full>
The `pushStyle()` function saves the current style settings and `popStyle()` restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `pushStyle()` , it builds on the current style information. The `pushStyle()` and `popStyle()` functions can be embedded to provide more control (see the second example above for a demonstration.)

The style information controlled by the following functions are included in the style: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#popStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="popStyle" kind="METHOD">
<body>
<first>( begin auto-generated from popStyle.xml ) The , `,pushStyle(),` , function saves the current style settings and , `,popStyle(),` , restores the prior settings; these functions are always used together.</first>
<full>
The `pushStyle()` function saves the current style settings and `popStyle()` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `pushStyle()` , it builds on the current style information. The `pushStyle()` and `popStyle()` functions can be embedded to provide more control (see the second example above for a demonstration.)
</full>
</body>
<blocktags>
<blocktag>@webref structure</blocktag>
<blocktag>@see PGraphics#pushStyle()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="strokeWeight" kind="METHOD">
<body>
<first>( begin auto-generated from strokeWeight.xml ) Sets the width of the stroke used for lines, points, and the border around shapes.</first>
<full>
Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.

When drawing with P3D, series of connected lines (such as the stroke around a polygon, triangle, or ellipse) produce unattractive results when a thick stroke weight is set (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). With P3D, the minimum and maximum values for `strokeWeight()` are controlled by the graphics card and the operating system's OpenGL implementation. For instance, the thickness may not go higher than 10 pixels.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param weight the weight (in pixels) of the stroke</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="strokeJoin" kind="METHOD">
<body>
<first>( begin auto-generated from strokeJoin.xml ) Sets the style of the joints which connect line segments.</first>
<full>
Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.

This function is not available with the P3D renderer, (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). More information about the renderers can be found in the `size()` reference.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param join either MITER, BEVEL, ROUND</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="strokeCap" kind="METHOD">
<body>
<first>( begin auto-generated from strokeCap.xml ) Sets the style for rendering line endings.</first>
<full>
Sets the style for rendering line endings. These ends are either squared, extended, or rounded and specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.

This function is not available with the P3D renderer (&lt;a href="http://code.google.com/p/processing/issues/detail?id=123"&gt;see Issue 123&lt;/a&gt;). More information about the renderers can be found in the `size()` reference.
</full>
</body>
<blocktags>
<blocktag>@webref shape:attributes</blocktag>
<blocktag>@param cap either SQUARE, PROJECT, or ROUND</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PApplet#size(int, int, String, String)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noStroke" kind="METHOD">
<body>
<first>( begin auto-generated from noStroke.xml ) Disables drawing the stroke (outline).</first>
<full>
Disables drawing the stroke (outline). If both `noStroke()` and `noFill()` are called, nothing will be drawn to the screen.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#fill(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="stroke" kind="METHOD">
<body>
<first>( begin auto-generated from stroke.xml ) Sets the color used to draw lines and borders around shapes.</first>
<full>
Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current `colorMode()` (the default color space is RGB, with each value in the range from 0 to 255).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.
</full>
</body>
<blocktags>
<blocktag>@param rgb color value in hexadecimal notation</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
<blocktag>@see PGraphics#strokeWeight(float)</blocktag>
<blocktag>@see PGraphics#strokeJoin(int)</blocktag>
<blocktag>@see PGraphics#strokeCap(int)</blocktag>
<blocktag>@see PGraphics#fill(int, float)</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
<blocktag>@see PGraphics#tint(int, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#colorMode(int, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the stroke</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="stroke" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@webref color:setting</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noTint" kind="METHOD">
<body>
<first>( begin auto-generated from noTint.xml ) Removes the current fill value for displaying images and reverts to displaying images with their original hues.</first>
<full>
Removes the current fill value for displaying images and reverts to displaying images with their original hues.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#tint(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="tint" kind="METHOD">
<body>
<first>( begin auto-generated from tint.xml ) Sets the fill value for displaying images.</first>
<full>
Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by setting the alpha.

To make an image transparent, but not change it's color, use white as the tint color and specify an alpha value. For instance, tint(255, 128) will make an image 50% transparent (unless `colorMode()` has been used).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.

The `tint()` function is also used to control the coloring of textures in 3D.
</full>
</body>
<blocktags>
<blocktag>@webref image:loading_displaying</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color value in hexadecimal notation</blocktag>
<blocktag>@see PGraphics#noTint()</blocktag>
<blocktag>@see PGraphics#image(PImage, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the image</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="tint" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noFill" kind="METHOD">
<body>
<first>( begin auto-generated from noFill.xml ) Disables filling geometry.</first>
<full>
Disables filling geometry. If both `noStroke()` and `noFill()` are called, nothing will be drawn to the screen.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#fill(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fill" kind="METHOD">
<body>
<first>( begin auto-generated from fill.xml ) Sets the color used to fill shapes.</first>
<full>
Sets the color used to fill shapes. For example, if you run `fill(204, 102, 0)` , all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current `colorMode()` (the default color space is RGB, with each value in the range from 0 to 255).

When using hexadecimal notation to specify a color, use "#" or "0x" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with "0x", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.

The value for the parameter "gray" must be less than or equal to the current maximum value as specified by `colorMode()` . The default maximum value is 255.

To change the color of an image (or a texture), use tint().
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color variable or hex value</blocktag>
<blocktag>@see PGraphics#noFill()</blocktag>
<blocktag>@see PGraphics#stroke(int, float)</blocktag>
<blocktag>@see PGraphics#noStroke()</blocktag>
<blocktag>@see PGraphics#tint(int, float)</blocktag>
<blocktag>@see PGraphics#background(float, float, float, float)</blocktag>
<blocktag>@see PGraphics#colorMode(int, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the fill</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray number specifying value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="fill" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ambient" kind="METHOD">
<body>
<first>( begin auto-generated from ambient.xml ) Sets the ambient reflectance for shapes drawn to the screen.</first>
<full>
Sets the ambient reflectance for shapes drawn to the screen. This is combined with the ambient light component of environment. The color components set through the parameters define the reflectance. For example in the default color mode, setting v1=255, v2=126, v3=0, would cause all the red light to reflect and half of the green light to reflect. Used in combination with `emissive()` , `specular()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ambient" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray number specifying value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ambient" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="specular" kind="METHOD">
<body>
<first>( begin auto-generated from specular.xml ) Sets the specular color of the materials used for shapes drawn to the screen, which sets the color of hightlights.</first>
<full>
Sets the specular color of the materials used for shapes drawn to the screen, which sets the color of hightlights. Specular refers to light which bounces off a surface in a perferred direction (rather than bouncing in all directions like a diffuse light). Used in combination with `emissive()` , `ambient()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color to set</blocktag>
<blocktag>@see PGraphics#lightSpecular(float, float, float)</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="specular" kind="METHOD">
<body>
<first>gray number specifying value between white and black</first>
<full>
gray number specifying value between white and black
</full>
</body>
<blocktags>
<blocktag>@param gray value between black and white, by default 0 to 255</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="specular" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="shininess" kind="METHOD">
<body>
<first>( begin auto-generated from shininess.xml ) Sets the amount of gloss in the surface of shapes.</first>
<full>
Sets the amount of gloss in the surface of shapes. Used in combination with `ambient()` , `specular()` , and `emissive()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param shine degree of shininess</blocktag>
<blocktag>@see PGraphics#emissive(float, float, float)</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="emissive" kind="METHOD">
<body>
<first>( begin auto-generated from emissive.xml ) Sets the emissive color of the material used for drawing shapes drawn to the screen.</first>
<full>
Sets the emissive color of the material used for drawing shapes drawn to the screen. Used in combination with `ambient()` , `specular()` , and `shininess()` in setting the material properties of shapes.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:material_properties</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb color to set</blocktag>
<blocktag>@see PGraphics#ambient(float, float, float)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#shininess(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="emissive" kind="METHOD">
<body>
<first>gray number specifying value between white and black</first>
<full>
gray number specifying value between white and black
</full>
</body>
<blocktags>
<blocktag>@param gray value between black and white, by default 0 to 255</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="emissive" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lights" kind="METHOD">
<body>
<first>( begin auto-generated from lights.xml ) Sets the default ambient light, directional light, falloff, and specular values.</first>
<full>
Sets the default ambient light, directional light, falloff, and specular values. The defaults are ambientLight(128, 128, 128) and directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#noLights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="noLights" kind="METHOD">
<body>
<first>( begin auto-generated from noLights.xml ) Disable all lighting.</first>
<full>
Disable all lighting. Lighting is turned off by default and enabled with the `lights()` function. This function can be used to disable lighting so that 2D geometry (which does not require lighting) can be drawn after a set of lighted 3D geometry.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ambientLight" kind="METHOD">
<body>
<first>( begin auto-generated from ambientLight.xml ) Adds an ambient light.</first>
<full>
Adds an ambient light. Ambient light doesn't come from a specific direction, the rays have light have bounced around so much that objects are evenly lit from all sides. Ambient lights are almost always used in combination with other types of lights. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The effect of the parameters is determined by the current color mode.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="ambientLight" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="directionalLight" kind="METHOD">
<body>
<first>( begin auto-generated from directionalLight.xml ) Adds a directional light.</first>
<full>
Adds a directional light. Directional light comes from one direction and is stronger when hitting a surface squarely and weaker if it hits at a a gentle angle. After hitting a surface, a directional lights scatters in all directions. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `nx` , `ny` , and `nz` parameters specify the direction the light is facing. For example, setting `ny` to -1 will cause the geometry to be lit from below (the light is facing directly upward).
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param nx direction along the x-axis</blocktag>
<blocktag>@param ny direction along the y-axis</blocktag>
<blocktag>@param nz direction along the z-axis</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="pointLight" kind="METHOD">
<body>
<first>( begin auto-generated from pointLight.xml ) Adds a point light.</first>
<full>
Adds a point light. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `x` , `y` , and `z` parameters set the position of the light.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="spotLight" kind="METHOD">
<body>
<first>( begin auto-generated from spotLight.xml ) Adds a spot light.</first>
<full>
Adds a spot light. Lights need to be included in the `draw()` to remain persistent in a looping program. Placing them in the `setup()` of a looping program will cause them to only have an effect the first time through the loop. The affect of the `v1` , `v2` , and `v3` parameters is determined by the current color mode. The `x` , `y` , and `z` parameters specify the position of the light and `nx` , `ny` , `nz` specify the direction or light. The `angle` parameter affects angle of the spotlight cone.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@param x x-coordinate of the light</blocktag>
<blocktag>@param y y-coordinate of the light</blocktag>
<blocktag>@param z z-coordinate of the light</blocktag>
<blocktag>@param nx direction along the x axis</blocktag>
<blocktag>@param ny direction along the y axis</blocktag>
<blocktag>@param nz direction along the z axis</blocktag>
<blocktag>@param angle angle of the spotlight cone</blocktag>
<blocktag>@param concentration exponent determining the center bias of the cone</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#directionalLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lightFalloff" kind="METHOD">
<body>
<first>( begin auto-generated from lightFalloff.xml ) Sets the falloff rates for point lights, spot lights, and ambient lights.</first>
<full>
Sets the falloff rates for point lights, spot lights, and ambient lights. The parameters are used to determine the falloff with the following equation:

d = distance from light position to vertex position
falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)

Like `fill()` , it affects only the elements which are created after it in the code. The default value if `LightFalloff(1.0, 0.0, 0.0)` . Thinking about an ambient light with a falloff can be tricky. It is used, for example, if you wanted a region of your scene to be lit ambiently one color and another region to be lit ambiently by another color, you would use an ambient light with location and falloff. You can think of it as a point light that doesn't care which direction a surface is facing.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param constant constant value or determining falloff</blocktag>
<blocktag>@param linear linear value for determining falloff</blocktag>
<blocktag>@param quadratic quadratic value for determining falloff</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#lightSpecular(float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lightSpecular" kind="METHOD">
<body>
<first>( begin auto-generated from lightSpecular.xml ) Sets the specular color for lights.</first>
<full>
Sets the specular color for lights. Like `fill()` , it affects only the elements which are created after it in the code. Specular refers to light which bounces off a surface in a perferred direction (rather than bouncing in all directions like a diffuse light) and is used for creating highlights. The specular quality of a light interacts with the specular material qualities set through the `specular()` and `shininess()` functions.
</full>
</body>
<blocktags>
<blocktag>@webref lights_camera:lights</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param v1 red or hue value (depending on current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on current color mode)</blocktag>
<blocktag>@see PGraphics#specular(float, float, float)</blocktag>
<blocktag>@see PGraphics#lights()</blocktag>
<blocktag>@see PGraphics#ambientLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#pointLight(float, float, float, float, float, float)</blocktag>
<blocktag>@see PGraphics#spotLight(float, float, float, float, float, float, float, float, float, float, float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="background" kind="METHOD">
<body>
<first>( begin auto-generated from background.xml ) The , `,background(),` , function sets the color used for the background of the Processing window.</first>
<full>
The `background()` function sets the color used for the background of the Processing window. The default background is light gray. In the `draw()` function, the background color is used to clear the display window at the beginning of each frame.

An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window. To resize an image 'b' to the size of the sketch window, use b.resize(width, height).

Images used as background will ignore the current `tint()` setting.

It is not possible to use transparency (alpha) in background colors with the main drawing surface, however they will work properly with `createGraphics()` .

Advanced
--------



Clear the background with a color that includes an alpha value. This can only be used with objects created by createGraphics(), because the main drawing surface cannot be set transparent.&lt;/p&gt;

It might be tempting to use this function to partially clear the screen on each frame, however that's not how this function works. When calling background(), the pixels will be replaced with pixels that have that level of transparency. To do a semi-transparent overlay, use fill() with alpha and draw a rectangle.&lt;/p&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#stroke(float)</blocktag>
<blocktag>@see PGraphics#fill(float)</blocktag>
<blocktag>@see PGraphics#tint(float)</blocktag>
<blocktag>@see PGraphics#colorMode(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param alpha opacity of the background</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param gray specifies a value between white and black</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="background" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param v1 red or hue value (depending on the current color mode)</blocktag>
<blocktag>@param v2 green or saturation value (depending on the current color mode)</blocktag>
<blocktag>@param v3 blue or brightness value (depending on the current color mode)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="clear" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="background" kind="METHOD">
<body>
<first>Takes an RGB or ARGB image and sets it as the background.</first>
<full>
Takes an RGB or ARGB image and sets it as the background. The width and height of the image must be the same size as the sketch. Use image.resize(width, height) to make short work of such a task.

Note that even if the image is set as RGB, the high 8 bits of each pixel should be set opaque (0xFF000000) because the image data will be copied directly to the screen, and non-opaque background images may have strange behavior. Use image.filter(OPAQUE) to handle this easily.

When using 3D, this will also clear the zbuffer (if it exists).
</full>
</body>
<blocktags>
<blocktag>@param image PImage to set as background (must be same size as the sketch window)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="colorMode" kind="METHOD">
<body>
<first>( begin auto-generated from colorMode.xml ) Changes the way Processing interprets color data.</first>
<full>
Changes the way Processing interprets color data. By default, the parameters for `fill()` , `stroke()` , `background()` , and `color()` are defined by values between 0 and 255 using the RGB color model. The `colorMode()` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling `colorMode(RGB, 1.0)` will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters range1, range2, range3, and range 4.
</full>
</body>
<blocktags>
<blocktag>@webref color:setting</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness</blocktag>
<blocktag>@see PGraphics#background(float)</blocktag>
<blocktag>@see PGraphics#fill(float)</blocktag>
<blocktag>@see PGraphics#stroke(float)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param max range for all color elements</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param max1 range for the red or hue depending on the current color mode</blocktag>
<blocktag>@param max2 range for the green or saturation depending on the current color mode</blocktag>
<blocktag>@param max3 range for the blue or brightness depending on the current color mode</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="colorMode" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param maxA range for the alpha</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="alpha" kind="METHOD">
<body>
<first>( begin auto-generated from alpha.xml ) Extracts the alpha value from a color.</first>
<full>
Extracts the alpha value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="red" kind="METHOD">
<body>
<first>( begin auto-generated from red.xml ) Extracts the red value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the red value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The red() function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use the&gt;&gt;(right shift) operator with a bit mask. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = red(myColor);
float r2 = myColor&gt;&gt;16&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="green" kind="METHOD">
<body>
<first>( begin auto-generated from green.xml ) Extracts the green value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the green value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The `green()` function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use the&gt;&gt;(right shift) operator with a bit mask. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = green(myColor);
float r2 = myColor&gt;&gt;8&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="blue" kind="METHOD">
<body>
<first>( begin auto-generated from blue.xml ) Extracts the blue value from a color, scaled to match current , `,colorMode(),` ,.</first>
<full>
Extracts the blue value from a color, scaled to match current `colorMode()` . This value is always returned as a  float so be careful not to assign it to an int value.

The `blue()` function is easy to use and undestand, but is slower than another technique. To achieve the same results when working in `colorMode(RGB, 255)` , but with greater speed, use a bit mask to remove the other color components. For example, the following two lines of code are equivalent:
&lt;pre&gt;float r1 = blue(myColor);
float r2 = myColor&amp;0xFF;&lt;/pre&gt;
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
<blocktag>@see_external rightshift</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="hue" kind="METHOD">
<body>
<first>( begin auto-generated from hue.xml ) Extracts the hue value from a color.</first>
<full>
Extracts the hue value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="saturation" kind="METHOD">
<body>
<first>( begin auto-generated from saturation.xml ) Extracts the saturation value from a color.</first>
<full>
Extracts the saturation value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#brightness(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="brightness" kind="METHOD">
<body>
<first>( begin auto-generated from brightness.xml ) Extracts the brightness value from a color.</first>
<full>
Extracts the brightness value from a color.
</full>
</body>
<blocktags>
<blocktag>@webref color:creating_reading</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param rgb any value of the color datatype</blocktag>
<blocktag>@see PGraphics#red(int)</blocktag>
<blocktag>@see PGraphics#green(int)</blocktag>
<blocktag>@see PGraphics#blue(int)</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PGraphics#hue(int)</blocktag>
<blocktag>@see PGraphics#saturation(int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="lerpColor" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@nowebref Interpolate between two colors. Like lerp(), but for the individual color components of a color supplied as an int value.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showDepthWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is only available with 3D.</first>
<full>
Display a warning that the specified method is only available with 3D.
</full>
</body>
<blocktags>
<blocktag>@param method The method name (no parentheses)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showDepthWarningXYZ" kind="METHOD">
<body>
<first>Display a warning that the specified method that takes x, y, z parameters can only be used with x and y parameters in this renderer.</first>
<full>
Display a warning that the specified method that takes x, y, z parameters can only be used with x and y parameters in this renderer.
</full>
</body>
<blocktags>
<blocktag>@param method The method name (no parentheses)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showMethodWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is simply unavailable.</first>
<full>
Display a warning that the specified method is simply unavailable.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showVariationWarning" kind="METHOD">
<body>
<first>Error that a particular variation of a method is unavailable (even though other variations are).</first>
<full>
Error that a particular variation of a method is unavailable (even though other variations are). For instance, if vertex(x, y, u, v) is not available, but vertex(x, y) is just fine.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="showMissingWarning" kind="METHOD">
<body>
<first>Display a warning that the specified method is not implemented, meaning that it could be either a completely missing function, although other variations of it may still work properly.</first>
<full>
Display a warning that the specified method is not implemented, meaning that it could be either a completely missing function, although other variations of it may still work properly.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="checkAlpha" kind="METHOD">
<body>
<first>Check the alpha on an image, using a really primitive loop.</first>
<full>
Check the alpha on an image, using a really primitive loop.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="get" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_get.xml ) Reads the color of any pixel or grabs a section of an image.</first>
<full>
Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned. Use the `x` and `y` parameters to get the value of one pixel. Get a section of the display window by specifying an additional `width` and `height` parameter. When getting an image, the `x` and `y` parameters define the coordinates for the upper-left corner of the image, regardless of the current `imageMode()` .

If the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with `colorMode(HSB)` , the numbers returned will be in RGB format.

Getting the color of a single pixel with `get(x, y)` is easy, but not as fast as grabbing the data directly from `pixels[]` . The equivalent statement to `get(x, y)` using `pixels[]` is `pixels[y*width+x]` . See the reference for `pixels[]` for more information.

Advanced
--------

Returns an ARGB "color" type (a packed 32 bit int with the color. If the coordinate is outside the image, zero is returned (black, but completely transparent).

If the image is in RGB format (i.e. on a PVideo object), the value will get its high bits set, just to avoid cases where they haven't been set already.

If the image is in ALPHA format, this returns a white with its alpha value set.

This function is included primarily for beginners. It is quite slow because it has to check to see if the x, y that was provided is inside the bounds, and then has to check to see what image type it is. If you want things to be more efficient, access the pixels[] array directly.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Reads the color of any pixel or grabs a rectangle of pixels</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param x x-coordinate of the pixel</blocktag>
<blocktag>@param y y-coordinate of the pixel</blocktag>
<blocktag>@see PApplet#set(int, int, int)</blocktag>
<blocktag>@see PApplet#pixels</blocktag>
<blocktag>@see PApplet#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="get" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param w width of pixel rectangle to get</blocktag>
<blocktag>@param h height of pixel rectangle to get</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="get" kind="METHOD">
<body>
<first>Returns a copy of this PImage.</first>
<full>
Returns a copy of this PImage. Equivalent to get(0, 0, width, height). Deprecated, just use copy() instead.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="set" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_set.xml ) Changes the color of any pixel or writes an image directly into the display window.,
, ,
, The , `,x,` , and , `,y,` , parameters specify the pixel to change and the , `,color,` , parameter specifies the color value.</first>
<full>
Changes the color of any pixel or writes an image directly into the display window.

The `x` and `y` parameters specify the pixel to change and the `color` parameter specifies the color value. The color parameter is affected by the current color mode (the default is RGB values from 0 to 255). When setting an image, the `x` and `y` parameters define the coordinates for the upper-left corner of the image, regardless of the current `imageMode()` .

Setting the color of a single pixel with `set(x, y)` is easy, but not as fast as putting the data directly into `pixels[]` . The equivalent statement to `set(x, y, #000000)` using `pixels[]` is `pixels[y*width+x] = #000000` . See the reference for `pixels[]` for more information.
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief writes a color to any pixel or writes an image into another</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param x x-coordinate of the pixel</blocktag>
<blocktag>@param y y-coordinate of the pixel</blocktag>
<blocktag>@param c any value of the color datatype</blocktag>
<blocktag>@see PImage#get(int, int, int, int)</blocktag>
<blocktag>@see PImage#pixels</blocktag>
<blocktag>@see PImage#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="set" kind="METHOD">
<body>
<first>

,Advanced</first>
<full>


Advanced
--------

Efficient method of drawing an image's pixels directly to this surface. No variations are employed, meaning that any scale, tint, or imageMode settings will be ignored.
</full>
</body>
<blocktags>
<blocktag>@param img image to copy into the original image</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="mask" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_mask.xml ) Masks part of an image from displaying by loading another image and using it as an alpha channel.</first>
<full>
Masks part of an image from displaying by loading another image and using it as an alpha channel. This mask image should only contain grayscale data, but only the blue color channel is used. The mask image needs to be the same size as the image to which it is applied.

In addition to using a mask image, an integer array containing the alpha channel data can be specified directly. This method is useful for creating dynamically generated alpha masks. This array must be of the same length as the target image's pixels array and should contain only grayscale data of values between 0-255.

Advanced
--------

Set alpha channel for an image. Black colors in the source image will make the destination image completely transparent, and white will make things fully opaque. Gray values will be in-between steps.

Strictly speaking the "blue" value from the source image is used as the alpha color. For a fully grayscale image, this is correct, but for a color image it's not 100% accurate. For a more accurate conversion, first use filter(GRAY) which will make the image into a "correct" grayscale by performing a proper luminance-based conversion.
</full>
</body>
<blocktags>
<blocktag>@webref pimage:method</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param img image to use as the mask</blocktag>
<blocktag>@brief Masks part of an image with another image as an alpha channel</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="filter" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_filter.xml ) Filters an image as defined by one of the following modes:,
,
,THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.</first>
<full>
Filters an image as defined by one of the following modes:

THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.

GRAY - converts any colors in the image to grayscale equivalents

INVERT - sets each pixel to its inverse value

POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter

BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is used, the blur is equivalent to Guassian blur of radius 1

OPAQUE - sets the alpha channel to entirely opaque

ERODE - reduces the light areas with the amount defined by the level parameter

DILATE - increases the light areas with the amount defined by the level parameter

Advanced
--------

Method to apply a variety of basic filters to this image.



* filter(BLUR) provides a basic blur.
* filter(GRAY) converts the image to grayscale based on luminance.
* filter(INVERT) will invert the color components in the image.
* filter(OPAQUE) set all the high bits in the image to opaque
* filter(THRESHOLD) converts the image to black and white.
* filter(DILATE) grow white/light areas
* filter(ERODE) shrink white/light areas
Luminance conversion code contributed by&lt;A HREF="http://www.toxi.co.uk"&gt;toxi&lt;/A&gt;&lt;P/&gt;Gaussian blur code contributed by&lt;A HREF="http://incubator.quasimondo.com"&gt;Mario Klingemann&lt;/A&gt;
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Converts the image to grayscale or black and white</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param kind Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE</blocktag>
<blocktag>@param param unique for each, see above</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="copy" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_copy.xml ) Copies a region of pixels from one image into another.</first>
<full>
Copies a region of pixels from one image into another. If the source and destination regions aren't the same size, it will automatically resize source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.

As of release 0149, this function ignores `imageMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Copies the entire image</blocktag>
<blocktag>@usage web_application</blocktag>
<blocktag>@param sx X coordinate of the source's upper left corner</blocktag>
<blocktag>@param sy Y coordinate of the source's upper left corner</blocktag>
<blocktag>@param sw source image width</blocktag>
<blocktag>@param sh source image height</blocktag>
<blocktag>@param dx X coordinate of the destination's upper left corner</blocktag>
<blocktag>@param dy Y coordinate of the destination's upper left corner</blocktag>
<blocktag>@param dw destination image width</blocktag>
<blocktag>@param dh destination image height</blocktag>
<blocktag>@see PGraphics#alpha(int)</blocktag>
<blocktag>@see PImage#blend(PImage, int, int, int, int, int, int, int, int, int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="copy" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param src an image variable referring to the source image.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.core.PApplet" name="blend" kind="METHOD">
<body>
<first>( begin auto-generated from PImage_blend.xml ) Blends a region of pixels into the image specified by the , `,img,` , parameter.</first>
<full>
Blends a region of pixels into the image specified by the `img` parameter. These copies utilize full alpha channel support and a choice of the following modes to blend the colors of source pixels (A) with the ones of pixels in the destination image (B):

BLEND - linear interpolation of colours: C = A*factor + B

ADD - additive blending with white clip: C = min(A*factor + B, 255)

SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)

DARKEST - only the darkest colour succeeds: C = min(A*factor, B)

LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)

DIFFERENCE - subtract colors from underlying image.

EXCLUSION - similar to DIFFERENCE, but less extreme.

MULTIPLY - Multiply the colors, result will always be darker.

SCREEN - Opposite multiply, uses inverse values of the colors.

OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.

HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.

SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.

DODGE - Lightens light tones and increases contrast, ignores darks. Called "Color Dodge" in Illustrator and Photoshop.

BURN - Darker areas are applied, increasing contrast, ignores lights. Called "Color Burn" in Illustrator and Photoshop.

All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the `srcImg` parameter is not used, the display window is used as the source image.

As of release 0149, this function ignores `imageMode()` .
</full>
</body>
<blocktags>
<blocktag>@webref image:pixels</blocktag>
<blocktag>@brief Copies a pixel or rectangle of pixels using different blending modes</blocktag>
<blocktag>@param src an image variable referring to the source image</blocktag>
<blocktag>@param sx X coordinate of the source's upper left corner</blocktag>
<blocktag>@param sy Y coordinate of the source's upper left corner</blocktag>
<blocktag>@param sw source image width</blocktag>
<blocktag>@param sh source image height</blocktag>
<blocktag>@param dx X coordinate of the destinations's upper left corner</blocktag>
<blocktag>@param dy Y coordinate of the destinations's upper left corner</blocktag>
<blocktag>@param dw destination image width</blocktag>
<blocktag>@param dh destination image height</blocktag>
<blocktag>@param mode Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN</blocktag>
<blocktag>@see PApplet#alpha(int)</blocktag>
<blocktag>@see PImage#copy(PImage, int, int, int, int, int, int, int, int)</blocktag>
<blocktag>@see PImage#blendColor(int,int,int)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="Parameters" kind="CLASS">
<body>
<first>This class stores the parameters for a texture: target, internal format, minimization filter and magnification filter.</first>
<full>
This class stores the parameters for a texture: target, internal format, minimization filter and magnification filter.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="BufferData" kind="CLASS">
<body>
<first>This class stores a buffer copied from the buffer source.</first>
<full>
This class stores a buffer copied from the buffer source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="TEX2D" kind="FIELD">
<body>
<first>Texture with normalized UV.</first>
<full>
Texture with normalized UV.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="TEXRECT" kind="FIELD">
<body>
<first>Texture with un-normalized UV.</first>
<full>
Texture with un-normalized UV.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="POINT" kind="FIELD">
<body>
<first>Point sampling: both magnification and minification filtering are set to nearest</first>
<full>
Point sampling: both magnification and minification filtering are set to nearest
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="LINEAR" kind="FIELD">
<body>
<first>Linear sampling: magnification filtering is nearest, minification set to linear</first>
<full>
Linear sampling: magnification filtering is nearest, minification set to linear
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="BILINEAR" kind="FIELD">
<body>
<first>Bilinear sampling: both magnification filtering is set to linear and minification either to linear-mipmap-nearest (linear interpolation is used within a mipmap, but not between different mipmaps).</first>
<full>
Bilinear sampling: both magnification filtering is set to linear and minification either to linear-mipmap-nearest (linear interpolation is used within a mipmap, but not between different mipmaps).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="TRILINEAR" kind="FIELD">
<body>
<first>Trilinear sampling: magnification filtering set to linear, minification to linear-mipmap-linear, which offers the best mipmap quality since linear interpolation to compute the value in each of two maps and then interpolates linearly between these two values.</first>
<full>
Trilinear sampling: magnification filtering set to linear, minification to linear-mipmap-linear, which offers the best mipmap quality since linear interpolation to compute the value in each of two maps and then interpolates linearly between these two values.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="modified" kind="FIELD">
<body>
<first>Modified portion of the texture</first>
<full>
Modified portion of the texture
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="init" kind="CONSTRUCTOR">
<body>
<first>Creates an instance of PTexture with size width x height.</first>
<full>
Creates an instance of PTexture with size width x height. The texture is initialized (empty) to that size.
</full>
</body>
<blocktags>
<blocktag>@param width int</blocktag>
<blocktag>@param height int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="init" kind="CONSTRUCTOR">
<body>
<first>Creates an instance of PTexture with size width x height and with the specified parameters.</first>
<full>
Creates an instance of PTexture with size width x height and with the specified parameters. The texture is initialized (empty) to that size.
</full>
</body>
<blocktags>
<blocktag>@param width int</blocktag>
<blocktag>@param height int</blocktag>
<blocktag>@param params Parameters</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="init" kind="METHOD">
<body>
<first>Sets the size of the image and texture to width x height.</first>
<full>
Sets the size of the image and texture to width x height. If the texture is already initialized, it first destroys the current OpenGL texture object and then creates a new one with the specified size.
</full>
</body>
<blocktags>
<blocktag>@param width int</blocktag>
<blocktag>@param height int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="init" kind="METHOD">
<body>
<first>Sets the size of the image and texture to width x height, and the parameters of the texture to params.</first>
<full>
Sets the size of the image and texture to width x height, and the parameters of the texture to params. If the texture is already initialized, it first destroys the current OpenGL texture object and then creates a new one with the specified size.
</full>
</body>
<blocktags>
<blocktag>@param width int</blocktag>
<blocktag>@param height int</blocktag>
<blocktag>@param params GLTextureParameters</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="init" kind="METHOD">
<body>
<first>Initializes the texture using GL parameters</first>
<full>
Initializes the texture using GL parameters
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="available" kind="METHOD">
<body>
<first>Returns true if the texture has been initialized.</first>
<full>
Returns true if the texture has been initialized.
</full>
</body>
<blocktags>
<blocktag>@return boolean</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="get" kind="METHOD">
<body>
<first>Copy texture to pixels.</first>
<full>
Copy texture to pixels. Involves video memory to main memory transfer (slow).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="usingMipmaps" kind="METHOD">
<body>
<first>Returns true or false whether or not the texture is using mipmaps.</first>
<full>
Returns true or false whether or not the texture is using mipmaps.
</full>
</body>
<blocktags>
<blocktag>@return boolean</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="usingRepeat" kind="METHOD">
<body>
<first>Returns true or false whether or not the texture is using repeat wrap mode along either U or V directions.</first>
<full>
Returns true or false whether or not the texture is using repeat wrap mode along either U or V directions.
</full>
</body>
<blocktags>
<blocktag>@return boolean</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="maxTexcoordU" kind="METHOD">
<body>
<first>Returns the maximum possible value for the texture coordinate U (horizontal).</first>
<full>
Returns the maximum possible value for the texture coordinate U (horizontal).
</full>
</body>
<blocktags>
<blocktag>@return float</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="maxTexcoordV" kind="METHOD">
<body>
<first>Returns the maximum possible value for the texture coordinate V (vertical).</first>
<full>
Returns the maximum possible value for the texture coordinate V (vertical).
</full>
</body>
<blocktags>
<blocktag>@return float</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="invertedX" kind="METHOD">
<body>
<first>Returns true if the texture is inverted along the horizontal direction.</first>
<full>
Returns true if the texture is inverted along the horizontal direction.
</full>
</body>
<blocktags>
<blocktag>@return boolean;</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="invertedX" kind="METHOD">
<body>
<first>Sets the texture as inverted or not along the horizontal direction.</first>
<full>
Sets the texture as inverted or not along the horizontal direction.
</full>
</body>
<blocktags>
<blocktag>@param v boolean;</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="invertedY" kind="METHOD">
<body>
<first>Returns true if the texture is inverted along the vertical direction.</first>
<full>
Returns true if the texture is inverted along the vertical direction.
</full>
</body>
<blocktags>
<blocktag>@return boolean;</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="invertedY" kind="METHOD">
<body>
<first>Sets the texture as inverted or not along the vertical direction.</first>
<full>
Sets the texture as inverted or not along the vertical direction.
</full>
</body>
<blocktags>
<blocktag>@param v boolean;</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="flipArrayOnX" kind="METHOD">
<body>
<first>Flips intArray along the X axis.</first>
<full>
Flips intArray along the X axis.
</full>
</body>
<blocktags>
<blocktag>@param intArray int[]</blocktag>
<blocktag>@param mult int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="flipArrayOnY" kind="METHOD">
<body>
<first>Flips intArray along the Y axis.</first>
<full>
Flips intArray along the Y axis.
</full>
</body>
<blocktags>
<blocktag>@param intArray int[]</blocktag>
<blocktag>@param mult int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="convertToRGBA" kind="METHOD">
<body>
<first>Reorders a pixel array in the given format into the order required by OpenGL (RGBA) and stores it into rgbaPixels.</first>
<full>
Reorders a pixel array in the given format into the order required by OpenGL (RGBA) and stores it into rgbaPixels. The width and height parameters are used in the YUV420 to RBGBA conversion.
</full>
</body>
<blocktags>
<blocktag>@param pixels int[]</blocktag>
<blocktag>@param format int</blocktag>
<blocktag>@param w int</blocktag>
<blocktag>@param h int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="convertToARGB" kind="METHOD">
<body>
<first>Reorders an OpenGL pixel array (RGBA) into ARGB.</first>
<full>
Reorders an OpenGL pixel array (RGBA) into ARGB. The array must be of size width * height.
</full>
</body>
<blocktags>
<blocktag>@param pixels int[]</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="allocate" kind="METHOD">
<body>
<first>Allocates the opengl texture object.</first>
<full>
Allocates the opengl texture object.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="dispose" kind="METHOD">
<body>
<first>Marks the texture object for deletion.</first>
<full>
Marks the texture object for deletion.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture" name="setParameters" kind="METHOD">
<body>
<first>Sets texture target and internal format according to the target and type specified.</first>
<full>
Sets texture target and internal format according to the target and type specified.
</full>
</body>
<blocktags>
<blocktag>@param target int</blocktag>
<blocktag>@param params GLTextureParameters</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="target" kind="FIELD">
<body>
<first>Texture target.</first>
<full>
Texture target.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="format" kind="FIELD">
<body>
<first>Texture internal format.</first>
<full>
Texture internal format.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="sampling" kind="FIELD">
<body>
<first>Texture filtering (POINT, LINEAR, BILINEAR or TRILINEAR).</first>
<full>
Texture filtering (POINT, LINEAR, BILINEAR or TRILINEAR).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="mipmaps" kind="FIELD">
<body>
<first>Use mipmaps or not.</first>
<full>
Use mipmaps or not.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="wrapU" kind="FIELD">
<body>
<first>Wrapping mode along U.</first>
<full>
Wrapping mode along U.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="wrapV" kind="FIELD">
<body>
<first>Wrapping mode along V.</first>
<full>
Wrapping mode along V.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.Texture.Parameters" name="init" kind="CONSTRUCTOR">
<body>
<first>Sets all the parameters to default values.</first>
<full>
Sets all the parameters to default values.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PSurfaceJOGL" name="profile" kind="FIELD">
<body>
<first>Selected GL profile</first>
<full>
Selected GL profile
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShapeOpenGL" name="init" kind="CONSTRUCTOR">
<body>
<first>Create a shape from the PRIMITIVE family, using this kind and these params</first>
<full>
Create a shape from the PRIMITIVE family, using this kind and these params
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShapeOpenGL" name="getVertexCode" kind="METHOD">
<body>
<first>One of VERTEX, BEZIER_VERTEX, CURVE_VERTEX, or BREAK.</first>
<full>
One of VERTEX, BEZIER_VERTEX, CURVE_VERTEX, or BREAK.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="init" kind="CONSTRUCTOR">
<body>
<first>Creates a shader program using the specified vertex and fragment shaders.</first>
<full>
Creates a shader program using the specified vertex and fragment shaders.
</full>
</body>
<blocktags>
<blocktag>@param parent the parent program</blocktag>
<blocktag>@param vertFilename name of the vertex shader</blocktag>
<blocktag>@param fragFilename name of the fragment shader</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="init" kind="CONSTRUCTOR">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vertURL network location of the vertex shader</blocktag>
<blocktag>@param fragURL network location of the fragment shader</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="bind" kind="METHOD">
<body>
<first>Initializes (if needed) and binds the shader program.</first>
<full>
Initializes (if needed) and binds the shader program.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="unbind" kind="METHOD">
<body>
<first>Unbinds the shader program.</first>
<full>
Unbinds the shader program.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="bound" kind="METHOD">
<body>
<first>Returns true if the shader is bound, false otherwise.</first>
<full>
Returns true if the shader is bound, false otherwise.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@webref rendering:shaders</blocktag>
<blocktag>@brief Sets a variable within the shader</blocktag>
<blocktag>@param name the name of the uniform variable to modify</blocktag>
<blocktag>@param x first component of the variable to modify</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param y second component of the variable to modify. The variable has to be declared with an array/vector type in the shader (i.e.: int[2], vec2)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param z third component of the variable to modify. The variable has to be declared with an array/vector type in the shader (i.e.: int[3], vec3)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param w fourth component of the variable to modify. The variable has to be declared with an array/vector type in the shader (i.e.: int[4], vec4)</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param vec modifies all the components of an array/vector uniform variable. PVector can only be used if the type of the variable is vec3.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param ncoords number of coordinates per element, max 4</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param mat matrix of values</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param use3x3 enforces the matrix is 3 x 3</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="set" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param tex sets the sampler uniform variable to read from this image texture</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="setup" kind="METHOD">
<body>
<first>Extra initialization method that can be used by subclasses, called after compiling and attaching the vertex and fragment shaders, and before linking the shader program.</first>
<full>
Extra initialization method that can be used by subclasses, called after compiling and attaching the vertex and fragment shaders, and before linking the shader program.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="getAttributeLoc" kind="METHOD">
<body>
<first>Returns the ID location of the attribute parameter given its name.</first>
<full>
Returns the ID location of the attribute parameter given its name.
</full>
</body>
<blocktags>
<blocktag>@param name String</blocktag>
<blocktag>@return int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="getUniformLoc" kind="METHOD">
<body>
<first>Returns the ID location of the uniform parameter given its name.</first>
<full>
Returns the ID location of the uniform parameter given its name.
</full>
</body>
<blocktags>
<blocktag>@param name String</blocktag>
<blocktag>@return int</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="compileVertexShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param shaderSource a string containing the shader's code</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PShader" name="compileFragmentShader" kind="METHOD">
<body>
<first></first>
<full>

</full>
</body>
<blocktags>
<blocktag>@param shaderSource a string containing the shader's code</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="gl" kind="FIELD">
<body>
<first>Basic GL functionality, common to all profiles</first>
<full>
Basic GL functionality, common to all profiles
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="glu" kind="FIELD">
<body>
<first>GLU interface</first>
<full>
GLU interface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="context" kind="FIELD">
<body>
<first>The rendering context (holds rendering state info)</first>
<full>
The rendering context (holds rendering state info)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="DRAW_TIMEOUT_MILLIS" kind="FIELD">
<body>
<first>Time that the Processing's animation thread will wait for JOGL's rendering thread to be done with a single frame.</first>
<full>
Time that the Processing's animation thread will wait for JOGL's rendering thread to be done with a single frame.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="capabilities" kind="FIELD">
<body>
<first>The capabilities of the OpenGL rendering surface</first>
<full>
The capabilities of the OpenGL rendering surface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="drawable" kind="FIELD">
<body>
<first>The rendering surface</first>
<full>
The rendering surface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="gl2" kind="FIELD">
<body>
<first>GLES2 functionality (shaders, etc)</first>
<full>
GLES2 functionality (shaders, etc)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="gl3" kind="FIELD">
<body>
<first>GL3 interface</first>
<full>
GL3 interface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="gl2x" kind="FIELD">
<body>
<first>GL2 desktop functionality (blit framebuffer, map buffer range, multisampled renderbuffers)</first>
<full>
GL2 desktop functionality (blit framebuffer, map buffer range, multisampled renderbuffers)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="gl3es3" kind="FIELD">
<body>
<first>GL3ES3 interface</first>
<full>
GL3ES3 interface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="drawException" kind="FIELD">
<body>
<first>Stores exceptions that ocurred during drawing</first>
<full>
Stores exceptions that ocurred during drawing
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="getFontMetrics" kind="METHOD">
<body>
<first>Convenience method to get a legit FontMetrics object.</first>
<full>
Convenience method to get a legit FontMetrics object. Where possible, override this any renderer subclass so that you're not using what's returned by getDefaultToolkit() to get your metrics.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PJOGL" name="getFontRenderContext" kind="METHOD">
<body>
<first>Convenience method to jump through some Java2D hoops and get an FRC.</first>
<full>
Convenience method to jump through some Java2D hoops and get an FRC.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="pgl" kind="FIELD">
<body>
<first>Interface between Processing and OpenGL</first>
<full>
Interface between Processing and OpenGL
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="currentPG" kind="FIELD">
<body>
<first>The renderer currently in use.</first>
<full>
The renderer currently in use.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="fontMap" kind="FIELD">
<body>
<first>Font cache for texture objects.</first>
<full>
Font cache for texture objects.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="initialized" kind="FIELD">
<body>
<first>Whether the PGraphics object is ready to render or not.</first>
<full>
Whether the PGraphics object is ready to render or not.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="FLUSH_CONTINUOUSLY" kind="FIELD">
<body>
<first>Flush modes: continuously (geometry is flushed after each call to endShape) when-full (geometry is accumulated until a maximum size is reached.</first>
<full>
Flush modes: continuously (geometry is flushed after each call to endShape) when-full (geometry is accumulated until a maximum size is reached.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="IMMEDIATE" kind="FIELD">
<body>
<first>Type of geometry: immediate is that generated with beginShape/vertex/ endShape, retained is the result of creating a PShapeOpenGL object with createShape.</first>
<full>
Type of geometry: immediate is that generated with beginShape/vertex/ endShape, retained is the result of creating a PShapeOpenGL object with createShape.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="flushMode" kind="FIELD">
<body>
<first>Current flush mode.</first>
<full>
Current flush mode.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="npotTexSupported" kind="FIELD">
<body>
<first>Extensions used by Processing</first>
<full>
Extensions used by Processing
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="maxTextureSize" kind="FIELD">
<body>
<first>Some hardware limits</first>
<full>
Some hardware limits
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="OPENGL_VENDOR" kind="FIELD">
<body>
<first>OpenGL information strings</first>
<full>
OpenGL information strings
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraFOV" kind="FIELD">
<body>
<first>Camera field of view.</first>
<full>
Camera field of view.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraX" kind="FIELD">
<body>
<first>Default position of the camera.</first>
<full>
Default position of the camera.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraY" kind="FIELD">
<body>
<first>Default position of the camera.</first>
<full>
Default position of the camera.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraZ" kind="FIELD">
<body>
<first>Default position of the camera.</first>
<full>
Default position of the camera.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraNear" kind="FIELD">
<body>
<first>Distance of the near and far planes.</first>
<full>
Distance of the near and far planes.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraFar" kind="FIELD">
<body>
<first>Distance of the near and far planes.</first>
<full>
Distance of the near and far planes.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraAspect" kind="FIELD">
<body>
<first>Aspect ratio of camera's view.</first>
<full>
Aspect ratio of camera's view.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="defCameraFOV" kind="FIELD">
<body>
<first>Default camera properties.</first>
<full>
Default camera properties.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="eyeDist" kind="FIELD">
<body>
<first>Distance between camera eye and center.</first>
<full>
Distance between camera eye and center.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="manipulatingCamera" kind="FIELD">
<body>
<first>Flag to indicate that we are inside beginCamera/endCamera block.</first>
<full>
Flag to indicate that we are inside beginCamera/endCamera block.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="sized" kind="FIELD">
<body>
<first>Marks when changes to the size have occurred, so that the camera will be reset in beginDraw().</first>
<full>
Marks when changes to the size have occurred, so that the camera will be reset in beginDraw().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="modelviewStack" kind="FIELD">
<body>
<first>Modelview matrix stack</first>
<full>
Modelview matrix stack
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="modelviewInvStack" kind="FIELD">
<body>
<first>Inverse modelview matrix stack</first>
<full>
Inverse modelview matrix stack
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraStack" kind="FIELD">
<body>
<first>Camera matrix stack</first>
<full>
Camera matrix stack
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="cameraInvStack" kind="FIELD">
<body>
<first>Inverse camera matrix stack</first>
<full>
Inverse camera matrix stack
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="projectionStack" kind="FIELD">
<body>
<first>Projection matrix stack</first>
<full>
Projection matrix stack
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightType" kind="FIELD">
<body>
<first>Light types</first>
<full>
Light types
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightPosition" kind="FIELD">
<body>
<first>Light positions</first>
<full>
Light positions
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightNormal" kind="FIELD">
<body>
<first>Light direction (normalized vector)</first>
<full>
Light direction (normalized vector)
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightAmbient" kind="FIELD">
<body>
<first>Ambient colors for lights.</first>
<full>
Ambient colors for lights.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightDiffuse" kind="FIELD">
<body>
<first>Diffuse colors for lights.</first>
<full>
Diffuse colors for lights.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightSpecular" kind="FIELD">
<body>
<first>Specular colors for lights.</first>
<full>
Specular colors for lights. Internally these are stored as numbers between 0 and 1.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightFalloffCoefficients" kind="FIELD">
<body>
<first>Light falloff</first>
<full>
Light falloff
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightSpotParameters" kind="FIELD">
<body>
<first>Light spot parameters: Cosine of light spot angle and concentration</first>
<full>
Light spot parameters: Cosine of light spot angle and concentration
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="currentLightSpecular" kind="FIELD">
<body>
<first>Current specular color for lighting</first>
<full>
Current specular color for lighting
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="currentLightFalloffConstant" kind="FIELD">
<body>
<first>Current light falloff</first>
<full>
Current light falloff
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="clipRect" kind="FIELD">
<body>
<first>Clipping rectangle.</first>
<full>
Clipping rectangle.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="textTex" kind="FIELD">
<body>
<first>Font texture of currently selected font.</first>
<full>
Font texture of currently selected font.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="texture" kind="FIELD">
<body>
<first>Texture containing the current frame</first>
<full>
Texture containing the current frame
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ptexture" kind="FIELD">
<body>
<first>Texture containing the previous frame</first>
<full>
Texture containing the previous frame
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="pixelBuffer" kind="FIELD">
<body>
<first>IntBuffer wrapping the pixels array.</first>
<full>
IntBuffer wrapping the pixels array.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="nativePixels" kind="FIELD">
<body>
<first>Array to store pixels in OpenGL format.</first>
<full>
Array to store pixels in OpenGL format.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="nativePixelBuffer" kind="FIELD">
<body>
<first>IntBuffer wrapping the native pixels array.</first>
<full>
IntBuffer wrapping the native pixels array.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="filterTexture" kind="FIELD">
<body>
<first>texture used to apply a filter on the screen image.</first>
<full>
texture used to apply a filter on the screen image.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="filterImage" kind="FIELD">
<body>
<first>PImage that wraps filterTexture.</first>
<full>
PImage that wraps filterTexture.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="drawing" kind="FIELD">
<body>
<first>True if we are inside a beginDraw()/endDraw() block.</first>
<full>
True if we are inside a beginDraw()/endDraw() block.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="smoothDisabled" kind="FIELD">
<body>
<first>Used to detect continuous use of the smooth/noSmooth functions</first>
<full>
Used to detect continuous use of the smooth/noSmooth functions
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lastBlendMode" kind="FIELD">
<body>
<first>Used to avoid flushing the geometry when blendMode() is called with the same blend mode as the last</first>
<full>
Used to avoid flushing the geometry when blendMode() is called with the same blend mode as the last
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="OP_NONE" kind="FIELD">
<body>
<first>Type of pixels operation.</first>
<full>
Type of pixels operation.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="viewport" kind="FIELD">
<body>
<first>Viewport dimensions.</first>
<full>
Viewport dimensions.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="MIN_POINT_ACCURACY" kind="FIELD">
<body>
<first>Used in round point and ellipse tessellation.</first>
<full>
Used in round point and ellipse tessellation. The number of subdivisions per round point or ellipse is calculated with the following formula: n = min(M, max(N, (TWO_PI * size / F))) where size is a measure of the dimensions of the circle when projected on screen coordinates. F just sets the minimum number of subdivisions, while a smaller F would allow to have more detailed circles. N = MIN_POINT_ACCURACY M = MAX_POINT_ACCURACY F = POINT_ACCURACY_FACTOR
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="QUAD_POINT_SIGNS" kind="FIELD">
<body>
<first>Used in quad point tessellation.</first>
<full>
Used in quad point tessellation.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="intBuffer" kind="FIELD">
<body>
<first>To get data from OpenGL.</first>
<full>
To get data from OpenGL.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="textLineImpl" kind="METHOD">
<body>
<first>Implementation of actual drawing for a line of text.</first>
<full>
Implementation of actual drawing for a line of text.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="textCharShapeImpl" kind="METHOD">
<body>
<first>Ported from the implementation of textCharShapeImpl() in 1.5.1 ,&lt;EM&gt;,No attempt has been made to optimize this code,&lt;/EM&gt;,</first>
<full>
Ported from the implementation of textCharShapeImpl() in 1.5.1&lt;EM&gt;No attempt has been made to optimize this code&lt;/EM&gt;

TODO: Implement a FontShape class where each glyph is tessellated and stored inside a larger PShapeOpenGL object (which needs to be expanded as new glyphs are added and exceed the initial capacity in a similar way as the textures in FontTexture work). When a string of text is to be rendered in shape mode, then the correct sequences of vertex indices are computed (akin to the texcoords in the texture case) and used to draw only those parts of the PShape object that are required for the text.

Some issues of the original implementation probably remain, so they are reproduced below:

Also a problem where some fonts seem to be a bit slight, as if the control points aren't being mapped quite correctly. Probably doing something dumb that the control points don't map to P5's control points. Perhaps it's returning b-spline data from the TrueType font? Though it seems like that would make a lot of garbage rather than just a little flattening.

There also seems to be a bug that is causing a line (but not a filled triangle) back to the origin on some letters (i.e. a capital L when tested with Akzidenz Grotesk Light). But this won't be visible with the stroke shut off, so tabling that bug for now.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="rotate" kind="METHOD">
<body>
<first>Two dimensional rotation.</first>
<full>
Two dimensional rotation. Same as rotateZ (this is identical to a 3D rotation along the z-axis) but included for clarity -- it'd be weird for people drawing 2D graphics to be using rotateZ. And they might kick our a-- for the confusion.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="rotate" kind="METHOD">
<body>
<first>Rotate around an arbitrary vector, similar to glRotate(), except that it takes radians (instead of degrees).</first>
<full>
Rotate around an arbitrary vector, similar to glRotate(), except that it takes radians (instead of degrees).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="scale" kind="METHOD">
<body>
<first>Same as scale(s, s, s).</first>
<full>
Same as scale(s, s, s).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="scale" kind="METHOD">
<body>
<first>Same as scale(sx, sy, 1).</first>
<full>
Same as scale(sx, sy, 1).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="scale" kind="METHOD">
<body>
<first>Scale in three dimensions.</first>
<full>
Scale in three dimensions.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="scaleImpl" kind="METHOD">
<body>
<first>Scale in three dimensions.</first>
<full>
Scale in three dimensions.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="applyMatrix" kind="METHOD">
<body>
<first>Apply a 4x4 transformation matrix to the modelview stack.</first>
<full>
Apply a 4x4 transformation matrix to the modelview stack.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="setMatrix" kind="METHOD">
<body>
<first>Set the current transformation to the contents of the specified source.</first>
<full>
Set the current transformation to the contents of the specified source.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="printMatrix" kind="METHOD">
<body>
<first>Print the current model (or "transformation") matrix.</first>
<full>
Print the current model (or "transformation") matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="beginCamera" kind="METHOD">
<body>
<first>Set matrix mode to the camera matrix (instead of the current transformation matrix).</first>
<full>
Set matrix mode to the camera matrix (instead of the current transformation matrix). This means applyMatrix, resetMatrix, etc. will affect the camera.

Note that the camera matrix is *not* the perspective matrix, it contains the values of the modelview matrix immediatly after the latter was initialized with ortho() or camera(), or the modelview matrix as result of the operations applied between beginCamera()/endCamera().

beginCamera() specifies that all coordinate transforms until endCamera() should be pre-applied in inverse to the camera transform matrix. Note that this is only challenging when a user specifies an arbitrary matrix with applyMatrix(). Then that matrix will need to be inverted, which may not be possible. But take heart, if a user is applying a non-invertible matrix to the camera transform, then he is clearly up to no good, and we can wash our hands of those bad intentions.

begin/endCamera clauses do not automatically reset the camera transform matrix. That's because we set up a nice default camera transform in setup(), and we expect it to hold through draw(). So we don't reset the camera transform matrix at the top of draw(). That means that an innocuous-looking clause like

```
beginCamera(); translate(0, 0, 10); endCamera();
```

at the top of draw(), will result in a runaway camera that shoots infinitely out of the screen over time. In order to prevent this, it is necessary to call some function that does a hard reset of the camera transform matrix inside of begin/endCamera. Two options are

```
camera(); // sets up the nice default camera transform resetMatrix(); // sets up the identity camera transform
```

So to rotate a camera a constant amount, you might try

```
beginCamera(); camera(); rotateY(PI / 8); endCamera();
```


</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="endCamera" kind="METHOD">
<body>
<first>Record the current settings into the camera matrix, and set the matrix mode back to the current transformation matrix.</first>
<full>
Record the current settings into the camera matrix, and set the matrix mode back to the current transformation matrix.

Note that this will destroy any settings to scale(), translate(), or whatever, because the final camera matrix will be copied (not multiplied) into the modelview.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="camera" kind="METHOD">
<body>
<first>Set camera to the default settings.</first>
<full>
Set camera to the default settings.

Processing camera behavior:

Camera behavior can be split into two separate components, camera transformation, and projection. The transformation corresponds to the physical location, orientation, and scale of the camera. In a physical camera metaphor, this is what can manipulated by handling the camera body (with the exception of scale, which doesn't really have a physcial analog). The projection corresponds to what can be changed by manipulating the lens.

We maintain separate matrices to represent the camera transform and projection. An important distinction between the two is that the camera transform should be invertible, where the projection matrix should not, since it serves to map three dimensions to two. It is possible to bake the two matrices into a single one just by multiplying them together, but it isn't a good idea, since lighting, z-ordering, and z-buffering all demand a true camera z coordinate after modelview and camera transforms have been applied but before projection. If the camera transform and projection are combined there is no way to recover a good camera-space z-coordinate from a model coordinate.

Fortunately, there are no functions that manipulate both camera transformation and projection.

camera() sets the camera position, orientation, and center of the scene. It replaces the camera transform with a new one.

The transformation functions are the same ones used to manipulate the modelview matrix (scale, translate, rotate, etc.). But they are bracketed with beginCamera(), endCamera() to indicate that they should apply (in inverse), to the camera transformation matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="camera" kind="METHOD">
<body>
<first>More flexible method for dealing with camera().</first>
<full>
More flexible method for dealing with camera().

The actual call is like gluLookat. Here's the real skinny on what does what:

```
camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz);
```

do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used.

Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following:

```
beginCamera(); rotateY(PI / 8); endCamera();
```

will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this:

```
beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera();
```

That will rotate a little off of the default view. Note that this is entirely equivalent to

```
camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera();
```

because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="printCamera" kind="METHOD">
<body>
<first>Print the current camera matrix.</first>
<full>
Print the current camera matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ortho" kind="METHOD">
<body>
<first>Calls ortho() with the proper parameters for Processing's standard orthographic projection.</first>
<full>
Calls ortho() with the proper parameters for Processing's standard orthographic projection.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ortho" kind="METHOD">
<body>
<first>Calls ortho() with the specified size of the viewing volume along the X and Z directions.</first>
<full>
Calls ortho() with the specified size of the viewing volume along the X and Z directions.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ortho" kind="METHOD">
<body>
<first>Sets an orthographic projection.</first>
<full>
Sets an orthographic projection.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="perspective" kind="METHOD">
<body>
<first>Calls perspective() with Processing's standard coordinate projection.</first>
<full>
Calls perspective() with Processing's standard coordinate projection.

Projection functions:

* frustrum()
* ortho()
* perspective()
Each of these three functions completely replaces the projection matrix with a new one. They can be called inside setup(), and their effects will be felt inside draw(). At the top of draw(), the projection matrix is not reset. Therefore the last projection function to be called always dominates. On resize, the default projection is always established, which has perspective.

This behavior is pretty much familiar from OpenGL, except where functions replace matrices, rather than multiplying against the previous.


</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="perspective" kind="METHOD">
<body>
<first>Similar to gluPerspective().</first>
<full>
Similar to gluPerspective(). Implementation based on Mesa's glu.c
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="frustum" kind="METHOD">
<body>
<first>Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix.</first>
<full>
Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix.

Implementation based on the explanation in the OpenGL blue book.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="printProjection" kind="METHOD">
<body>
<first>Print the current projection matrix.</first>
<full>
Print the current projection matrix.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lights" kind="METHOD">
<body>
<first>Sets up an ambient and directional light using OpenGL.</first>
<full>
Sets up an ambient and directional light using OpenGL. API taken from PGraphics3D.

```
The Lighting Skinny: The way lighting works is complicated enough that it's worth producing a document to describe it. Lighting calculations proceed pretty much exactly as described in the OpenGL red book. Light-affecting material properties:   AMBIENT COLOR   - multiplies by light's ambient component   - for believability this should match diffuse color   DIFFUSE COLOR   - multiplies by light's diffuse component   SPECULAR COLOR   - multiplies by light's specular component   - usually less colored than diffuse/ambient   SHININESS   - the concentration of specular effect   - this should be set pretty high (20-50) to see really     noticeable specularity   EMISSIVE COLOR   - constant additive color effect Light types:   AMBIENT   - one color   - no specular color   - no direction   - may have falloff (constant, linear, and quadratic)   - may have position (which matters in non-constant falloff case)   - multiplies by a material's ambient reflection   DIRECTIONAL   - has diffuse color   - has specular color   - has direction   - no position   - no falloff   - multiplies by a material's diffuse and specular reflections   POINT   - has diffuse color   - has specular color   - has position   - no direction   - may have falloff (constant, linear, and quadratic)   - multiplies by a material's diffuse and specular reflections   SPOT   - has diffuse color   - has specular color   - has position   - has direction   - has cone angle (set to half the total cone angle)   - has concentration value   - may have falloff (constant, linear, and quadratic)   - multiplies by a material's diffuse and specular reflections Normal modes: All of the primitives (rect, box, sphere, etc.) have their normals set nicely. During beginShape/endShape normals can be set by the user.   AUTO-NORMAL   - if no normal is set during the shape, we are in auto-normal mode   - auto-normal calculates one normal per triangle (face-normal mode)   SHAPE-NORMAL   - if one normal is set during the shape, it will be used for     all vertices   VERTEX-NORMAL   - if multiple normals are set, each normal applies to     subsequent vertices   - (except for the first one, which applies to previous     and subsequent vertices) Efficiency consequences:   There is a major efficiency consequence of position-dependent   lighting calculations per vertex. (See below for determining   whether lighting is vertex position-dependent.) If there is no   position dependency then the only factors that affect the lighting   contribution per vertex are its colors and its normal.   There is a major efficiency win if   1) lighting is not position dependent   2) we are in AUTO-NORMAL or SHAPE-NORMAL mode   because then we can calculate one lighting contribution per shape   (SHAPE-NORMAL) or per triangle (AUTO-NORMAL) and simply multiply it   into the vertex colors. The converse is our worst-case performance when   1) lighting is position dependent   2) we are in AUTO-NORMAL mode   because then we must calculate lighting per-face * per-vertex.   Each vertex has a different lighting contribution per face in   which it appears. Yuck. Determining vertex position dependency:   If any of the following factors are TRUE then lighting is   vertex position dependent:   1) Any lights uses non-constant falloff   2) There are any point or spot lights   3) There is a light with specular color AND there is a      material with specular color So worth noting is that default lighting (a no-falloff ambient and a directional without specularity) is not position-dependent. We should capitalize. Simon Greenwold, April 2005
```


</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="noLights" kind="METHOD">
<body>
<first>Disables lighting.</first>
<full>
Disables lighting.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ambientLight" kind="METHOD">
<body>
<first>Add an ambient light based on the current color mode.</first>
<full>
Add an ambient light based on the current color mode.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="ambientLight" kind="METHOD">
<body>
<first>Add an ambient light based on the current color mode.</first>
<full>
Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightFalloff" kind="METHOD">
<body>
<first>Set the light falloff rates for the last light that was created.</first>
<full>
Set the light falloff rates for the last light that was created. Default is lightFalloff(1, 0, 0).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="lightSpecular" kind="METHOD">
<body>
<first>Set the specular color of the last light created.</first>
<full>
Set the specular color of the last light created.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="report" kind="METHOD">
<body>
<first>Report on anything from glError().</first>
<full>
Report on anything from glError(). Don't use this inside glBegin/glEnd otherwise it'll throw an GL_INVALID_OPERATION error.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="filter" kind="METHOD">
<body>
<first>This is really inefficient and not a good idea in OpenGL.</first>
<full>
This is really inefficient and not a good idea in OpenGL. Use get() and set() with a smaller image area, or call the filter on an image instead, and then draw that.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="filter" kind="METHOD">
<body>
<first>This is really inefficient and not a good idea in OpenGL.</first>
<full>
This is really inefficient and not a good idea in OpenGL. Use get() and set() with a smaller image area, or call the filter on an image instead, and then draw that.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="blendModeImpl" kind="METHOD">
<body>
<first>Allows to set custom blend modes for the entire scene, using openGL.</first>
<full>
Allows to set custom blend modes for the entire scene, using openGL. Reference article about blending modes: http://www.pegtop.net/delphi/articles/blendmodes/ DIFFERENCE, HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN modes cannot be implemented in fixed-function pipeline because they require conditional blending and non-linear blending equations.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="getTexture" kind="METHOD">
<body>
<first>Not an approved function, this will change or be removed in the future.</first>
<full>
Not an approved function, this will change or be removed in the future. This utility method returns the texture associated to the renderer's. drawing surface, making sure is updated to reflect the current contents off the screen (or offscreen drawing surface).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="getTexture" kind="METHOD">
<body>
<first>Not an approved function either, don't use it.</first>
<full>
Not an approved function either, don't use it.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="getTexture" kind="METHOD">
<body>
<first>Not an approved function, this will change or be removed in the future.</first>
<full>
Not an approved function, this will change or be removed in the future. This utility method returns the texture associated to the image. creating and/or updating it if needed.
</full>
</body>
<blocktags>
<blocktag>@param img the image to have a texture metadata associated to it</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="getFrameBuffer" kind="METHOD">
<body>
<first>Not an approved function, test its use in libraries to grab the FB objects for offscreen PGraphics.</first>
<full>
Not an approved function, test its use in libraries to grab the FB objects for offscreen PGraphics.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL" name="addTexture" kind="METHOD">
<body>
<first>This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.</first>
<full>
This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.
</full>
</body>
<blocktags>
<blocktag>@param img the image to have a texture metadata associated to it</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGraphicsOpenGL.Tessellator.TessellatorCallback" name="combine" kind="METHOD">
<body>
<first>Implementation of the GLU_TESS_COMBINE callback.</first>
<full>
Implementation of the GLU_TESS_COMBINE callback.
</full>
</body>
<blocktags>
<blocktag>@param coords is the 3-vector of the new vertex</blocktag>
<blocktag>@param data is the vertex data to be combined, up to four elements. This is useful when mixing colors together or any other user data that was passed in to gluTessVertex.</blocktag>
<blocktag>@param weight is an array of weights, one for each element of "data" that should be linearly combined for new values.</blocktag>
<blocktag>@param outData is the set of new values of "data" after being put back together based on the weights. it's passed back as a single element Object[] array because that's the closest that Java gets to a pointer.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="GraphicsNotInitializedException" kind="CLASS">
<body>
<first>Exception for when attempting an operation requiring the graphics renderer, context, etc to have been initialized before that initialization.</first>
<full>
Exception for when attempting an operation requiring the graphics renderer, context, etc to have been initialized before that initialization.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="graphics" kind="FIELD">
<body>
<first>The PGraphics and PApplet objects using this interface</first>
<full>
The PGraphics and PApplet objects using this interface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="glThread" kind="FIELD">
<body>
<first>OpenGL thread</first>
<full>
OpenGL thread
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="glContext" kind="FIELD">
<body>
<first>ID of the GL context associated to the surface</first>
<full>
ID of the GL context associated to the surface
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="primaryPGL" kind="FIELD">
<body>
<first>true if this is the GL interface for a primary surface PGraphics</first>
<full>
true if this is the GL interface for a primary surface PGraphics
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="USE_DIRECT_BUFFERS" kind="FIELD">
<body>
<first>Switches between the use of regular and direct buffers.</first>
<full>
Switches between the use of regular and direct buffers.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MIPMAPS_ENABLED" kind="FIELD">
<body>
<first>Enables/disables mipmap use.</first>
<full>
Enables/disables mipmap use.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="DEFAULT_IN_VERTICES" kind="FIELD">
<body>
<first>Initial sizes for arrays of input and tessellated data.</first>
<full>
Initial sizes for arrays of input and tessellated data.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MAX_LIGHTS" kind="FIELD">
<body>
<first>Maximum lights by default is 8, the minimum defined by OpenGL.</first>
<full>
Maximum lights by default is 8, the minimum defined by OpenGL.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MAX_VERTEX_INDEX" kind="FIELD">
<body>
<first>Maximum index value of a tessellated vertex.</first>
<full>
Maximum index value of a tessellated vertex. GLES restricts the vertex indices to be of type unsigned short. Since Java only supports signed shorts as primitive type we have 2^15 = 32768 as the maximum number of vertices that can be referred to within a single VBO.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="FLUSH_VERTEX_COUNT" kind="FIELD">
<body>
<first>Count of tessellated fill, line or point vertices that will trigger a flush in the immediate mode.</first>
<full>
Count of tessellated fill, line or point vertices that will trigger a flush in the immediate mode. It doesn't necessarily be equal to MAX_VERTEX_INDEX1, since the number of vertices can be effectively much large since the renderer uses offsets to refer to vertices beyond the MAX_VERTEX_INDEX limit.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MIN_FONT_TEX_SIZE" kind="FIELD">
<body>
<first>Minimum/maximum dimensions of a texture used to hold font data.</first>
<full>
Minimum/maximum dimensions of a texture used to hold font data.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MIN_CAPS_JOINS_WEIGHT" kind="FIELD">
<body>
<first>Minimum stroke weight needed to apply the full path stroking algorithm that properly generates caps and joins.</first>
<full>
Minimum stroke weight needed to apply the full path stroking algorithm that properly generates caps and joins.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MAX_CAPS_JOINS_LENGTH" kind="FIELD">
<body>
<first>Maximum length of linear paths to be stroked with the full algorithm that generates accurate caps and joins.</first>
<full>
Maximum length of linear paths to be stroked with the full algorithm that generates accurate caps and joins.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="MIN_ARRAYCOPY_SIZE" kind="FIELD">
<body>
<first>Minimum array size to use arrayCopy method().</first>
<full>
Minimum array size to use arrayCopy method().
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="STROKE_DISPLACEMENT" kind="FIELD">
<body>
<first>Factor used to displace the stroke vertices towards the camera in order to make sure the lines are always on top of the fill geometry</first>
<full>
Factor used to displace the stroke vertices towards the camera in order to make sure the lines are always on top of the fill geometry
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="usingFrontTex" kind="FIELD">
<body>
<first>Flags used to handle the creation of a separate front texture</first>
<full>
Flags used to handle the creation of a separate front texture
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="fboAllowed" kind="FIELD">
<body>
<first>Defines if FBO Layer is allowed in the given environment.</first>
<full>
Defines if FBO Layer is allowed in the given environment. Using FBO can cause a fatal error during runtime for Intel HD Graphics 3000 chipsets (commonly used on older MacBooks)&lt;a href="https://github.com/processing/processing/issues/4104"&gt;#4104&lt;/a&gt;. Changed to private because needs to be accessed via isFboAllowed().&lt;a href="https://github.com/processing/processing4/pull/76"&gt;#76&lt;/a&gt;and&lt;a href="https://github.com/processing/processing4/issues/50"&gt;#50&lt;/a&gt;
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="texturingTargets" kind="FIELD">
<body>
<first>Which texturing targets are enabled</first>
<full>
Which texturing targets are enabled
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="maxTexUnits" kind="FIELD">
<body>
<first>Used to keep track of which textures are bound to each target</first>
<full>
Used to keep track of which textures are bound to each target
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="geomCount" kind="FIELD">
<body>
<first>Used to register amount of geometry rendered in each frame.</first>
<full>
Used to register amount of geometry rendered in each frame.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="clearColor" kind="FIELD">
<body>
<first>Used to register calls to background.</first>
<full>
Used to register calls to background.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="SIZEOF_SHORT" kind="FIELD">
<body>
<first>Size of different types in bytes</first>
<full>
Size of different types in bytes
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="FLOAT_EPS" kind="FIELD">
<body>
<first>Machine Epsilon for float precision.</first>
<full>
Machine Epsilon for float precision.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="BIG_ENDIAN" kind="FIELD">
<body>
<first>Set to true if the host system is big endian (PowerPC, MIPS, SPARC), false if little endian (x86 Intel for Mac or PC).</first>
<full>
Set to true if the host system is big endian (PowerPC, MIPS, SPARC), false if little endian (x86 Intel for Mac or PC).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="drawTexture" kind="METHOD">
<body>
<first>Not an approved function, this will change or be removed in the future.</first>
<full>
Not an approved function, this will change or be removed in the future.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="drawTexture" kind="METHOD">
<body>
<first>Not an approved function, this will change or be removed in the future.</first>
<full>
Not an approved function, this will change or be removed in the future.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="nativeToJavaARGB" kind="METHOD">
<body>
<first>Converts input native OpenGL value (RGBA on big endian, ABGR on little endian) to Java ARGB.</first>
<full>
Converts input native OpenGL value (RGBA on big endian, ABGR on little endian) to Java ARGB.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="nativeToJavaARGB" kind="METHOD">
<body>
<first>Converts input array of native OpenGL values (RGBA on big endian, ABGR on little endian) representing an image of width x height resolution to Java ARGB.</first>
<full>
Converts input array of native OpenGL values (RGBA on big endian, ABGR on little endian) representing an image of width x height resolution to Java ARGB. It also rearranges the elements in the array so that the image is flipped vertically.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="nativeToJavaRGB" kind="METHOD">
<body>
<first>Converts input native OpenGL value (RGBA on big endian, ABGR on little endian) to Java RGB, so that the alpha component of the result is set to opaque (255).</first>
<full>
Converts input native OpenGL value (RGBA on big endian, ABGR on little endian) to Java RGB, so that the alpha component of the result is set to opaque (255).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="nativeToJavaRGB" kind="METHOD">
<body>
<first>Converts input array of native OpenGL values (RGBA on big endian, ABGR on little endian) representing an image of width x height resolution to Java RGB, so that the alpha component of all pixels is set to opaque (255).</first>
<full>
Converts input array of native OpenGL values (RGBA on big endian, ABGR on little endian) representing an image of width x height resolution to Java RGB, so that the alpha component of all pixels is set to opaque (255). It also rearranges the elements in the array so that the image is flipped vertically.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="javaToNativeARGB" kind="METHOD">
<body>
<first>Converts input Java ARGB value to native OpenGL format (RGBA on big endian, BGRA on little endian).</first>
<full>
Converts input Java ARGB value to native OpenGL format (RGBA on big endian, BGRA on little endian).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="javaToNativeARGB" kind="METHOD">
<body>
<first>Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian).</first>
<full>
Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian). It also rearranges the elements in the array so that the image is flipped vertically.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="javaToNativeRGB" kind="METHOD">
<body>
<first>Converts input Java ARGB value to native OpenGL format (RGBA on big endian, BGRA on little endian), setting alpha component to opaque (255).</first>
<full>
Converts input Java ARGB value to native OpenGL format (RGBA on big endian, BGRA on little endian), setting alpha component to opaque (255).
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="javaToNativeRGB" kind="METHOD">
<body>
<first>Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian), while setting alpha component of all pixels to opaque (255).</first>
<full>
Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian), while setting alpha component of all pixels to opaque (255). It also rearranges the elements in the array so that the image is flipped vertically.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL" name="getString" kind="METHOD">
<body>
<first>Get a configuration or status string from the underlying renderer.</first>
<full>
Get a configuration or status string from the underlying renderer.
</full>
</body>
<blocktags>
<blocktag>@param name The name or ID of the attribute to request.</blocktag>
<blocktag>@return The requested value as a string.</blocktag>
<blocktag>@throws GraphicsNotInitializedException Thrown if an attribute is requested that is not    available until graphics initialization before that initialization compeltes. For example,    if requesting a GL string before GL context is available.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.PGL.GraphicsNotInitializedException" name="init" kind="CONSTRUCTOR">
<body>
<first>Create a new exception indicating that an action could not be fulfilled because the rendering context or equivalent is not ready.</first>
<full>
Create a new exception indicating that an action could not be fulfilled because the rendering context or equivalent is not ready.
</full>
</body>
<blocktags>
<blocktag>@param msg Further details about the issue.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LineStroker" name="init" kind="CONSTRUCTOR">
<body>
<first>Empty constructor.</first>
<full>
Empty constructor.&lt;code&gt;setOutput&lt;/code&gt;and&lt;code&gt;setParameters&lt;/code&gt;must be called prior to calling any other methods.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LineStroker" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructs a ,&lt;code&gt;,LineStroker,&lt;/code&gt;,.</first>
<full>
Constructs a&lt;code&gt;LineStroker&lt;/code&gt;.
</full>
</body>
<blocktags>
<blocktag>@param output an output &lt;code&gt;LineStroker&lt;/code&gt;.</blocktag>
<blocktag>@param lineWidth the desired line width in pixels, in S15.16 format.</blocktag>
<blocktag>@param capStyle the desired end cap style, one of &lt;code&gt;CAP_BUTT&lt;/code&gt;,          &lt;code&gt;CAP_ROUND&lt;/code&gt; or &lt;code&gt;CAP_SQUARE&lt;/code&gt;.</blocktag>
<blocktag>@param joinStyle the desired line join style, one of &lt;code&gt;JOIN_MITER&lt;/code&gt;,          &lt;code&gt;JOIN_ROUND&lt;/code&gt; or &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.</blocktag>
<blocktag>@param miterLimit the desired miter limit, in S15.16 format.</blocktag>
<blocktag>@param transform a &lt;code&gt;Transform4&lt;/code&gt; object indicating the transform that has          been previously applied to all incoming coordinates. This is          required in order to produce consistently shaped end caps and          joins.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LineStroker" name="setOutput" kind="METHOD">
<body>
<first>Sets the output ,&lt;code&gt;,LineStroker,&lt;/code&gt;, of this ,&lt;code&gt;,LineStroker,&lt;/code&gt;,.</first>
<full>
Sets the output&lt;code&gt;LineStroker&lt;/code&gt;of this&lt;code&gt;LineStroker&lt;/code&gt;.
</full>
</body>
<blocktags>
<blocktag>@param output an output &lt;code&gt;LineStroker&lt;/code&gt;.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LineStroker" name="setParameters" kind="METHOD">
<body>
<first>Sets the parameters of this ,&lt;code&gt;,LineStroker,&lt;/code&gt;,.</first>
<full>
Sets the parameters of this&lt;code&gt;LineStroker&lt;/code&gt;.
</full>
</body>
<blocktags>
<blocktag>@param lineWidth the desired line width in pixels, in S15.16 format.</blocktag>
<blocktag>@param capStyle the desired end cap style, one of &lt;code&gt;CAP_BUTT&lt;/code&gt;,          &lt;code&gt;CAP_ROUND&lt;/code&gt; or &lt;code&gt;CAP_SQUARE&lt;/code&gt;.</blocktag>
<blocktag>@param joinStyle the desired line join style, one of &lt;code&gt;JOIN_MITER&lt;/code&gt;,          &lt;code&gt;JOIN_ROUND&lt;/code&gt; or &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.</blocktag>
<blocktag>@param miterLimit the desired miter limit, in S15.16 format.</blocktag>
<blocktag>@param transform a &lt;code&gt;Transform4&lt;/code&gt; object indicating the transform that has          been previously applied to all incoming coordinates. This is          required in order to produce consistently shaped end caps and          joins.</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="WIND_EVEN_ODD" kind="FIELD">
<body>
<first>The winding rule constant for specifying an even-odd rule for determining the interior of a path.</first>
<full>
The winding rule constant for specifying an even-odd rule for determining the interior of a path. The even-odd rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments an odd number of times.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="WIND_NON_ZERO" kind="FIELD">
<body>
<first>The winding rule constant for specifying a non-zero rule for determining the interior of a path.</first>
<full>
The winding rule constant for specifying a non-zero rule for determining the interior of a path. The non-zero rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments a different number of times in the counter-clockwise direction than the clockwise direction.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="SEG_MOVETO" kind="FIELD">
<body>
<first>Starts segment at a given position.</first>
<full>
Starts segment at a given position.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="SEG_LINETO" kind="FIELD">
<body>
<first>Extends segment by adding a line to a given position.</first>
<full>
Extends segment by adding a line to a given position.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="SEG_CLOSE" kind="FIELD">
<body>
<first>Closes segment at current position.</first>
<full>
Closes segment at current position.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="JOIN_MITER" kind="FIELD">
<body>
<first>Joins path segments by extending their outside edges until they meet.</first>
<full>
Joins path segments by extending their outside edges until they meet.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="JOIN_ROUND" kind="FIELD">
<body>
<first>Joins path segments by rounding off the corner at a radius of half the line width.</first>
<full>
Joins path segments by rounding off the corner at a radius of half the line width.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="JOIN_BEVEL" kind="FIELD">
<body>
<first>Joins path segments by connecting the outer corners of their wide outlines with a straight segment.</first>
<full>
Joins path segments by connecting the outer corners of their wide outlines with a straight segment.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="CAP_BUTT" kind="FIELD">
<body>
<first>Ends unclosed subpaths and dash segments with no added decoration.</first>
<full>
Ends unclosed subpaths and dash segments with no added decoration.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="CAP_ROUND" kind="FIELD">
<body>
<first>Ends unclosed subpaths and dash segments with a round decoration that has a radius equal to half of the width of the pen.</first>
<full>
Ends unclosed subpaths and dash segments with a round decoration that has a radius equal to half of the width of the pen.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="CAP_SQUARE" kind="FIELD">
<body>
<first>Ends unclosed subpaths and dash segments with a square projection that extends beyond the end of the segment to a distance equal to half of the line width.</first>
<full>
Ends unclosed subpaths and dash segments with a square projection that extends beyond the end of the segment to a distance equal to half of the line width.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructs a new empty single precision ,{@code LinePath}, object with a default winding rule of ,{@link #WIND_NON_ZERO},.</first>
<full>
Constructs a new empty single precision{@code LinePath}object with a default winding rule of{@link #WIND_NON_ZERO}.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructs a new empty single precision ,{@code LinePath}, object with the specified winding rule to control operations that require the interior of the path to be defined.</first>
<full>
Constructs a new empty single precision{@code LinePath}object with the specified winding rule to control operations that require the interior of the path to be defined.
</full>
</body>
<blocktags>
<blocktag>@param rule the winding rule</blocktag>
<blocktag>@see #WIND_EVEN_ODD</blocktag>
<blocktag>@see #WIND_NON_ZERO</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="init" kind="CONSTRUCTOR">
<body>
<first>Constructs a new ,{@code LinePath}, object from the given specified initial values.</first>
<full>
Constructs a new{@code LinePath}object from the given specified initial values. This method is only intended for internal use and should not be made public if the other constructors for this class are ever exposed.
</full>
</body>
<blocktags>
<blocktag>@param rule the winding rule</blocktag>
<blocktag>@param initialCapacity the size to make the initial array to store the path segment types</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="moveTo" kind="METHOD">
<body>
<first>Adds a point to the path by moving to the specified coordinates specified in float precision.</first>
<full>
Adds a point to the path by moving to the specified coordinates specified in float precision.

This method provides a single precision variant of the double precision{@code moveTo()}method on the base{@code LinePath}class.
</full>
</body>
<blocktags>
<blocktag>@param x the specified X coordinate</blocktag>
<blocktag>@param y the specified Y coordinate</blocktag>
<blocktag>@see LinePath#moveTo</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="lineTo" kind="METHOD">
<body>
<first>Adds a point to the path by drawing a straight line from the current coordinates to the new specified coordinates specified in float precision.</first>
<full>
Adds a point to the path by drawing a straight line from the current coordinates to the new specified coordinates specified in float precision.

This method provides a single precision variant of the double precision{@code lineTo()}method on the base{@code LinePath}class.
</full>
</body>
<blocktags>
<blocktag>@param x the specified X coordinate</blocktag>
<blocktag>@param y the specified Y coordinate</blocktag>
<blocktag>@see LinePath#lineTo</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="getPathIterator" kind="METHOD">
<body>
<first>The iterator for this class is not multi-threaded safe, which means that the ,{@code LinePath}, class does not guarantee that modifications to the geometry of this ,{@code LinePath}, object do not affect any iterations of that geometry that are already in process.</first>
<full>
The iterator for this class is not multi-threaded safe, which means that the{@code LinePath}class does not guarantee that modifications to the geometry of this{@code LinePath}object do not affect any iterations of that geometry that are already in process.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="closePath" kind="METHOD">
<body>
<first>Closes the current subpath by drawing a straight line back to the coordinates of the last ,{@code moveTo},.</first>
<full>
Closes the current subpath by drawing a straight line back to the coordinates of the last{@code moveTo}. If the path is already closed then this method has no effect.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="getWindingRule" kind="METHOD">
<body>
<first>Returns the fill style winding rule.</first>
<full>
Returns the fill style winding rule.
</full>
</body>
<blocktags>
<blocktag>@return an integer representing the current winding rule.</blocktag>
<blocktag>@see #WIND_EVEN_ODD</blocktag>
<blocktag>@see #WIND_NON_ZERO</blocktag>
<blocktag>@see #setWindingRule</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="setWindingRule" kind="METHOD">
<body>
<first>Sets the winding rule for this path to the specified value.</first>
<full>
Sets the winding rule for this path to the specified value.
</full>
</body>
<blocktags>
<blocktag>@param rule an integer representing the specified winding rule</blocktag>
<blocktag>@exception IllegalArgumentException if {@code rule} is not either {@link #WIND_EVEN_ODD} or              {@link #WIND_NON_ZERO}</blocktag>
<blocktag>@see #getWindingRule</blocktag>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="reset" kind="METHOD">
<body>
<first>Resets the path to empty.</first>
<full>
Resets the path to empty. The append position is set back to the beginning of the path and all coordinates and point types are forgotten.
</full>
</body>
<blocktags>
</blocktags>
</commenttree>
<commenttree class="processing.opengl.LinePath" name="createStrokedPath" kind="METHOD">
<body>
<first>Constructs a solid ,&lt;code&gt;,LinePath,&lt;/code&gt;, with the specified attributes.</first>
<full>
Constructs a solid&lt;code&gt;LinePath&lt;/code&gt;with the specified attributes.
</full>
</body>
<blocktags>
<blocktag>@param src the original path to be stroked</blocktag>
<blocktag>@param weight the weight of the stroked path</blocktag>
<blocktag>@param caps the decoration of the ends of the segments in the path</blocktag>
<blocktag>@param join the decoration applied where path segments meet</blocktag>
<blocktag>@param miterlimit</blocktag>
<blocktag>@param transform</blocktag>
</blocktags>
</commenttree>
</commenttrees>
